= The flaka manual =
author wh@haefelinger.it
1.0, February 2010

== About Flaka ==

In the world of http://en.wikipedia.org/wiki/Java_(programming_language)[Java], build scripts are traditionally written in http://en.wikipedia.org/wiki/Apache_Ant[Ant] and recently also in http://en.wikipedia.org/wiki/Apache_Maven[Maven].

When it comes to write a build script using Ant, it feels like using a Shell script in a rather awkward language (XML). Each Ant task solves a particular problem. This is similar to a Shell where you have this small masterpieces like `mkdir`, `cp`, `tar` plus some control structures to eventually being able to put the one big thing together.

Writing a build script using a Shell is serious business. And so it is when using Ant. Ant does not provide you any abstraction how the project needs to be build. There is no underlying logic. In fact you, the author, need to know what to do. Step by step. What's more, you have to use the unfriendly http://en.wikipedia.org/wiki/XML[XML] syntax and restrictions, a control structure is missing and you have to use immutable properties to communicate between tasks. Therefore, Ant scripts are large, notoriously difficult to understand, usually not portable (usuallyt they just work on the authors host) and each author uses a different set of targets and properties.

Maven on the other side provides a high abstraction of building a project. Instead of describing how the project needs to be build, just describe project details and reports you like to have and Maven figures out what needs to be done. This is probably the reason why Maven got so much attention recently.

Despite better knowledge I wrote that Maven figures out how a project needs to be build automatically. That’s actually not quite true. In fact, Maven only works fine when following conventions setup by the Maven team. When not “en route”, Maven gets difficult as well. But even when following conventions, the possibilities in Maven are now endless and the http://maven.apache.org/ref/current/maven-model/maven.html[POM seems to be a endless stream of XML tags]. At the end, I found myself using Ant again.

Still I'm not happy with Ant. 

What I'm missing is the full power of a programming language. Yes, I want to have conditionals, loops and exception handling. I want to have typeless variables which I can set or remove for pleasure. No, I don't want string based properties which I can't remove. At least not if that is the only option. And then I want to have some kind of higher abstraction which does the right thing most of the time. This is what Flaka is about.

Flaka is a framework build on top of Ant. It’s main goal is to simplify the process of writing a build script. It comes with a high abstraction a la Maven while providing a dark force to escape from defaults and conventions.

This is how a Flaka build script will look like in the near future:

-------------------------------------------------
<project xmlns:c="antlib:net.haefelingerit.net">
 <c:init />
 <c:dependencies>
  <c:dependency artefactid="log4j" groupid="log4j" version="1.2.13" />
 <c:/dependencies>
</project>
-------------------------------------------------


It will essentially a Ant build script. All what should be done by the author is to list dependencies (if they can't be figured out automatically) and _all the rest_ would be done by the Flaka framework (`<c:init/>`). All the rest means:

* figure out what type of project should be build (jar, war, ear ..)
* figure out where project's source code, test cases etc are
* handle dependencies
* create targets like `clean`, `compile`, `package`, `test` automatically
* generate Javadoc and other reports
* _etc_ 

The next targeted version, *version 1.0*, will not reach all this goals. Instead a set of essential programming tasks will be made available. Furthermore, [http://en.wikipedia.org/wiki/Unified_Expression_Language unified expression language] will be used to eventually glue this control structures together to a higher leveled framework.

=== Where to go from here? ===

 * http://code.google.com/p/flaka/downloads/list[Download] Flaka and read the [Installation installation page].
 * Have a look a [BasicScriptingConstructs basic scripting elements] to see tasks, types, macros etc introduced by Flaka.
 * Have a look at the [Tasks task],[Types type] and [Macros macro] reference manuals for gory details.
 * Don't forget to look into [EL expression language], it contains a lot of information on this enormous useful extension.
 * Start writing good build scripts..


== Installation For The Impatient ==

Download latest version of Flaka and *drop* `ant-flaka.x.y.z.jar` into your local Ant installation. There are various techniques how to _drop_. Please read-on for refreshment.

=== Before You Start! ===

The following *requirements* must be satisfied before you start:

* Flaka requires http://java.sun.com/javase/downloads/index.jsp[Java 1.5] or newer. You can change the version by setting environment variable `JAVA_HOME`. Have also a look at http://ant.apache.org/manual/index.html[Ant's Manual] for other environment variables to be used.
* http://ant.apache.org[Ant] version 1.7.0 or newer. 


=== How to _drop_ the `ant-flaka` jar? ===
The most primitive technique is to save `ant-flaka-x.y.z.jar` in Ant's library folder `lib`. If you have no clue where Ant is installed, try 

-------------------------------------

 $ ant -diagnostics | grep ant.home
 ant.home: /opt/ant/1.7.1

-------------------------------------

Saving something in Ant's library folder may not work due to lack of permission. There's also the disadvantage that when switching to another Ant installation *Flaka* needs to be installed again. Therefore consider to use Ant's standard option `-lib`: 


-------------------------------------

 $ ant -lib ant-flaka-x.y.z.jar

-------------------------------------


A pretty nice feature of option `-lib` is that if the argument is a directory, that directory is scanned for jar files. Therefore you may instead want to do something like this:

-------------------------------------

 $ mkdir $HOME/lib/ant
 $ cp ant-flaka-x.y.z.jar $HOME/lib/ant
 $ ant -lib $HOME/lib/ant

-------------------------------------

This approach has the nice advantage that you simply can drop other jar files into folder `$HOME/lib/ant` to make them reachable  without touching the original Ant installation. As already mentioned, this will get handy when you have either multiple Ant installations. Btw, notice that option `-lib` can be applied more than once if the jars to use reside in various folders. Finally notice that folders are not recursively searched.

When working from the command line it's a bit annoying to provide option `-lib` for each and every call of Ant. Fortunatley, Ant recognizes environment variable `ANT_ARGS` which can be used to let `-lib` disappear:

-------------------------------------

 $ ANT_ARGS="-lib $HOME/lib/ant"
 $ export ANT_ARGS

-------------------------------------

The drawback with this technique is that you need to make sure that this variable is set in every environment you start up Ant. This sounds easier than done. Luckily, Ant reads file `$HOME/.antrc` and `$HOME/.ant/ant.conf` on each and every startup. It's is therefore recommended to set `ANT_ARGS ` in one of this files (without the need to export) to make just every plain call to `ant` *Flaka* aware. For example:

-------------------------------------

 $ cat $HOME/.antrc
 ANT_ARGS="-lib $HOME/lib/ant"

-------------------------------------


=== Check whether Flaka works! ===
To check whether your setup of `Flaka` works,  create a local Java project and try to build it. For example, 

-------------------------------------

 $ mkdir -p hello/src/demo && cd hello 
 $ cat > src/demo/Hello.java << EOF
   public class Hello {}
 ^D
 $ cat > build.xml << EOF
 <project xmlns:c="antlib:net.haefelingerit.flaka">
   <c:init />
 </project>
 ^D
 $ # let ant build this project
 $ ant
 :::::::::::::::::::::::::::::::::::::::::::::::::::
 ::               HELLO, FLAKA 1.0                ::
 ::  use `ant -p' to get a list of useful targets ::
 :::::::::::::::::::::::::::::::::::::::::::::::::::
 [..]
 BUILD SUCCESSFUL
 Total time: 2 seconds

-------------------------------------

The call to `ant` builds the package. The result will be file `hello-SNAPSHOT.jar` found in folder `build/dist`:

-------------------------------------

 $ jar tvf dist/hello-SNAPSHOT.jar
     0 Thu Jan 17 17:04:08 CET 2009 META-INF/
   667 Thu Jan 17 17:04:06 CET 2009 META-INF/MANIFEST.MF
   120 Thu Jan 17 17:04:08 CET 2009 Hello.class

-------------------------------------

##
## This should all go into Part 1 (so wee need to have a book here instead of an article)
##

== Programming Constructs ==

This chapter provides an overview of programming constructs Flaka provides. This programming constructs are one of the Flaka's pillars.

=== Strings ===
Like Ant, Flaka supports currently strings and, when applicable, pointer to resources (by referencing a symbol). Ant provides no functionality manipulate a string value and neither does Flaka. However, Flaka's expression language contains string functions to create new strings.

=== Symbols ===

Symbols are names carrying associated data. The name of a symbol is a sequence of characters. The allowed characters are basically unlimited. It is recommended to stick with well known characters [a-zA-Z0-9._-]. Symbols can be used as variables, target, task, type or macro names. 

 * `<property name=sym value=expr />` Use sym as variable: assign the value of _expr_ to _sym_. *A symbol associated with a string value is called a property*. Notice that Ant and Flaka provide further ways of creating properties. 
 * `<macrodef name=sym>`  Use _sym_ as macro name
 * `<target namesym>` Use _sym_ as target name
 * `<taskdef name=sym>` Use _sym_ as task name
 * `<typedef name=sym>` Use _sym_ as type name
 * `id=sym` Use sym as reference: assign the evaluation of task (or macro) to _id_ 

=== Properties === 

To reference a property, enclose it's symbol name with curly braces and prefix with the dollar character like:


-------------------------------------

<property name="x" value="99" />
<echo>
  value of property x is ${x}    -- .. is 99
</echo>

-------------------------------------


When referencing a non existing property, i.e. a symbol name not associated with a string value, the reference expression evaluates to itself, i.e. `${not-a-property}` evaluates to _${not-a-property}_. Standard Ant does not allow to change the association between a symbol name and it's string value once established:


-------------------------------------

<property name="x" value="99" />
<property name="x" value="The quick brown fox .."/>
<echo>
  value of property x is ${x}    -- .. is 99
</echo>

-------------------------------------


It can be done using Flaka's task [Tasks#let] or [Task#unset] as the following snippet demonstrates.


-------------------------------------

<property name="x" value="99" />
<c:let>
   x ::= "The quick brown fox .."
</c:let>
<echo>
  value of property x is ${x}    -- .. is The quick brown ..
</echo>

-------------------------------------


Properties have their own symbol table (as targets, tasks, macros and types have). This means for example that it is possible to have a property and a task _sharing_ the same symbol name:


-------------------------------------

  <property name="foobar" ../>
  <macrodef name="foobar" ../>  -- property foobar not harmed!

-------------------------------------


=== Sequencing ===

To evaluate a sequence of expressions (tasks or macros) where only one expression is allowed, use http://ant.apache.org/manual/CoreTasks/sequential.html[Ant's sequential task]:


-------------------------------------

 <sequential>
   -- any sequence of tasks or macros
 </sequential>

-------------------------------------


Note that _sequential_ returns nothing. Use properties to communicate with the caller if necessary.

=== Conditionals ===

With standard Ant, task http://ant.apache.org/manual/CoreTasks/condition.html[condition] is used to set a property if a condition is given. Then a macro, task or target can be conditionally executed  by checking the existence or absence of that property (using standard attributes _if_ or _unless_. Flaka defines a couple of control structures to handle conditionals in a simpler way.

=== when and unless ===

Task [Tasks#when when] evaluates an [EL EL expr]. If the evaluation gives `true`, the sequence of tasks are executed. Nothing else happens in case of `false`. 


-------------------------------------

<c:when test=" expr ">
   -- executed if expr evaluates to true
</c:when>

-------------------------------------


The logical negation of `when` is task [Tasks#unless unless] which executes the sequence of tasks only in case the evaluation of _expr_ returns `false`.


-------------------------------------

 <c:unless test=" expr ">
   -- executed if expr evaluates to false
 </c:unless>

-------------------------------------


The body of `when` and `unset` may contain any sequence of tasks or macros (or a combination of both).

=== choose ===

Task [Tasks#choose choose] tests each `when` condition in turn until an _expr_ evalutes to `true`. It executes then the body of that when condition. Subsequent `whens` are then not further tested (nor executed). If all expressions evaluate to `false`, an optional _catch-all_ clause gets executed.


-------------------------------------

 <c:choose>
  <when test="expr_1">
    -- body_1
  </when>
  ..
  <otherwise> -- optional_
    -- catch all body
  </otherwise>
 <c:/choose>

-------------------------------------


=== switch ===

A programming task often seen is to check whether a (string) value matches a given (string) value. If so, a particular action shall be carried out. This can be done via a series of _when_ statements. The nasty thing is to keep track of whether a value matched already. Flaka provides a handy task for this common scenario, the [Tasks#switch switch] task:


-------------------------------------

 <c:switch value=" 'some string' ">
  <matches re="regular expression or pattern" >
    -- body_1
  </case>
  ..
  <otherwise> -- optional
    -- catch all body
  </otherwise>
 </c:switch>

-------------------------------------


Each case is tried in turn _to match_ the string value (given as [EL] expression). If a case matches, the appropriate case body is executed. If it happens that no case matches, then the optional default body is executed. To be of greater value, a regular expression or pattern expression can be used in a case condition.

=== Repetition ===

Flaka has a looping statement. Use task [Tasks#for for] to iterate over a _list_ of items. Use [Tasks#break break] and [Tasks#continue continue] to terminate the loop or to continue the loop with the next item.


-------------------------------------

 <c:for var=" name " in=" ''.tofile.list ">
    -- sequence of task or macros
    -- used <c:continue /> to continue ; and
    -- <c:break /> to stop looping
    -- use #{name} to refer to current item (as shown below)
    <c:echo>#{name}</c:echo>
 </c:for>

-------------------------------------


Attribute `in` will be evaluated as [EL] expression. In the example above, that [EL] expression is `''.tofile.list` which, when evaluated, creates a list of all files in the folder containing the current build script. To understand the expression, have a look at [EL#String_Properties properties of a string] and [EL#File_Properties properties of a file].


=== Exception Handling ===

Flaka has been charged with exception handling tasks.

=== trycatch ===

Flaka contains a task to handle exceptions thrown by tasks, [Tasks#trycatch trycatch]. This task implements the usual _try/catch/finally_ trinity found in various programming languages (like in Java for example):


-------------------------------------

 <c:trycatch>
   <try>
     -- sequence of task or macros
   </try>
   <catch>
     -- sequence of task or macros
   </catch>
   <finally>
     -- sequence of task or macros
   </finally>
 </c:trycatch> 

-------------------------------------


Element _try_, _catch_ and _finally_ are all optional or can appear multiple times. If _catch_ is used without any argument, then that catch clause will match any *build exception*. To differentiate between different exception types, _catch_ can additionally be used with a _type_ and _match_ argument. The former can be used to select a particular exception type (like a 'java.lang.NullPointerException), the latter can be used to select an exception based on the message carried. Both arguments are interpreted as pattern expression. For example:


-------------------------------------

 <c:trycatch>
   <try>
      ..
      <fail message="#PANIC!" unless="ant.file"/>
      ..
   </try>
   <catch match="*#PANIC!*">
      <echo>Ant initialization problem!!</echo>
      <fail/>
   <catch type="java.lang.*">
     -- handle Java runtime problems
   </catch>
   <catch>
     -- handle all other build exceptions
   </catch>
  </c:trycatch>

-------------------------------------


Property _ant.file_ is a standard Ant property that should always be set. If not, there's something seriously wrong and it does not make much sense to continue. Use attribute _type_ to catch (runtime) exceptions thrown by the underlying implementation.

=== throw ===

Task [Tasks#throw throw] throws a (build) exception.


-------------------------------------

 <c:throw [var="sym"] />

-------------------------------------


This task can also be used to rethrow an existing exception.

=== Macros  ===

The (almost) equivalent of a function is a macro in Ant and Flaka. For example:

-------------------------------------

 <macrodef name="hello">
  <attribute name="msg" />
  <element name="body" implicit="true" />
  <sequential>
   <body />
  </sequential>
 </macrodef>

-------------------------------------


Once defined, simply use it:

-------------------------------------

<hello msg="Hello, world!">
 <echo>@{msg}</echo>
</hello>

-------------------------------------


This macro evaluates into 

-------------------------------------

 <echo>Hello, world!</echo>

-------------------------------------

which eventually prints the desired greeting.

Macros are a standard feature of Ant.


== EL, The Expression Language ==

The http://en.wikipedia.org/wiki/Unified_Expression_Language[Java Unified Expression Language] http://www.jcp.org/en/jsr/detail?id=245[(JSR-245)] is a special purpose programming (albeit not turing complete) language offering a simple way of accessing data objects. The language has its roots in Java web applications for embedding expressions into web pages. While the expression language is part of the JSP specification, it does in no way depend on the JSP specification. To the contrary, the language can be made available in a variety of contexts.

One such context is Ant scripting. Ant makes it difficult to access data objects. For example, there is no way of querying the underlying data object for the base folder (the folder containing the build script). All that Ant offers is the path name of this folder as _string_ object. This makes it for example rather cumbersome to report the last modification time of this folder. With the help of EL (sort for Unified Expression Language) this becomes an easy task:


-------------------------------------

<c:echo>
  ;; basedir is a standard Ant property 
  basedir is ${basedir}

  ;; report last modification time (as Date object)
  was last modified at #{ '${basedir}'.tofile.mtime }

  ;; dump the full name of this build file 
  ;; where 'ant.file' is a standard property
  this is #{property['ant.file'] } reporting!
</c:echo>

-------------------------------------


Being executed, this snippet produces something like 

-------------------------------------

[c:echo] basedir is /projects/flaka/test
[c:echo] 
[c:echo] was last modified at Mon Mar 09 13:52:29 CET 2009
[c:echo] 
[c:echo] this is /projects/flaka/test/tryme.xml reporting!

-------------------------------------

as output. Notice the usage of task [Tasks#echo echo]. When being tried with http://ant.apache.org/manual/CoreTasks/echo.html[Ant's standard echo task], a totally different output needs to be expected. Most important, [#EL_References EL references] `#{..}` are not resolved but rather print as given.

=== Another EL Example ===

The code snippet following shows _EL_ in action. The idea is to list all unreadable files in a certain directory (here the root folder). The snippet shows how EL is used in [#EL_Ready_Tasks Flaka various EL enabled tasks].

-------------------------------------

<c:let>
  root = '/'.tofile
  list = list()
</c:let>

<c:for var="file" in=" root.list ">
  <c:when test=" file.isdir and not file.isread ">
    <c:let>
      list = append(file,list)
    </c:let>
  </c:when>
</c:for>

<c:echo>
  ;; how many unreadable directories ??
  There are #{size(list)} unreadable directories in #{root}.
  And here they are #{list}.
</c:echo>

-------------------------------------


Executed on MacOS 10.5.6 (aka "Leopard"), this gives:

-------------------------------------

[c:echo] There are 2 unreadable directories in /.
[c:echo] And here they are [/.Trashes, /.Spotlight-V100].

-------------------------------------



=== Disabling EL ===

By default, _EL_ is enabled. _EL_ can be disabled by setting property `ant.el` to `false` (exactly as written). For example:

-------------------------------------

<!-- globally disable EL --->
<property name="ant.el" value="false" />

-------------------------------------
 
If the property is not set, or set to a different value, then _EL_ is enabled.

=== EL Ready Tasks ===

_EL_ expressions can only be used in tasks which are _EL_ ready. This are:

 * [Tasks#let let]
 * [Tasks#properties properties]
 * [Tasks#when when], [Tasks#unless unless]
 * [Tasks#for for]
 * [Tasks#echo echo]

Further tasks to follow. See also how to enable EL on a [#Globally_Enabling_EL global level].

=== Globally Enabling EL ===

To enable handling of EL references on a global level - i.e. on all tasks, types or  macros and independent of the vendor - use task [Tasks#install-reference-handler install-reference-handler].  

=== EL References ===

Those _not_ familiar with the specification of http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf[EL], http://en.wikipedia.org/wiki/JavaServer_Pages[JSP] or http://en.wikipedia.org/wiki/JavaServer_Faces[JSF] may safely skip this section. All other please read on, cause the implementation of EL has slightly be changed footnote:[EL has its roots in the context of Java Web Development and some specification details do not make sense when EL is used in a different domain content].

For those familiar, the _term EL expression_ is used in a slightly different way in this documentation than in the specification. According to the specification, `#{..}` is an EL expression. 

Not so in this documentation. Here only the inner part, denoted by `..` is a _EL expression_ while `#{ ..}` is considered a _reference to an EL expression_. A reference to an expression is used in contexts which are partially evaluated. Take task [Tasks#echo echo] as example. Clearly, when writing 

-------------------------------------

<c:echo>
 I said 'Hello world'!
</c:echo>

-------------------------------------

we expect an output exactly as written. It would be nice to indicate however, that we want to have a part of the input evaluated as EL expression. This and only this is what `#{..}` is good for:

-------------------------------------

<c:echo>
 I said '#{ what }'!
</c:echo>

-------------------------------------


In other contexts, like in `<c:when test=" condition " />`, a EL expression is expected anyway and it does not make the slightest sense to require the expression to be referenced. As an example, assume that we want to check whether a property named 'foobar' exists. Instead of writing

-------------------------------------

<c:when test=" #{has.property['foobar']} " />   -- don't!

-------------------------------------

as seen in popular JSP tag libraries, just write

-------------------------------------

<c:when test=" has.property['foobar'] " />   -- yes!!!

-------------------------------------

And forget about that unnecessary clutter.

Notice however, that in all contexts where a expression is expected, a expression reference can be used. This allows for advanced meta programming like shown in the following example:

-------------------------------------

<c:when test=" has.property['#{propertyname}'] " />   -- sic!

-------------------------------------


=== Handling of `${..}` ===

_EL_ defines two types of references:
 * *deferred*, indicated by `#{..}` ; and
 * *dynamic*, indicated by `${..}`

Dynamic references `${..}` are handled by Ant to resolve properties. There are two execptions to this however. Ant will leave a dynamic reference as is if the reference value does not denote a (existing) property. Secondly, Ant allows to escape a reference by by doubling character `$` as in `$${a}`. In any case, `${..}` does not denote a legal EL reference and will be left as is (notice that you can install a property handler to get rif of unresolved `${..}` property references. 

=== Handling of `#{..}` ===
Deferred references `#{..}` are evaluated according to regular EL rules. Each reference is evaluated independently. Thus 

-------------------------------------

 The #{ 'Good' }, the Bad and the #{ 'Ug' 'ly' }, a well known #{ 'movie' }.

-------------------------------------

Would print

-------------------------------------

 The Good, the Bad and the , a well known movie.

-------------------------------------

cause the second reference is illegal. Notice however that all valid references are evaluated.

=== Nested References ===

Nested references are not supported. The following reference is therefore illegal

-------------------------------------

 #{ item[ #{index} ] }

-------------------------------------


=== The Great Escape ===

This section is about how to stop a EL reference from being evaluated and treated as text instead:
 # Use character backslash like in `\#{abc}` ; or use this rather awkward
 # `#{'#{'}abc}` construct.
Both variants have the same result, the string `#{abc}`.


=== Gory EL Details  ===

The gory details of _EL_ are laid out in the http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf[the official JSR 245 specification] and are not repeated here. In short however, _EL_ let's you formulate http://en.wikipedia.org/wiki/Expression_(programming)[programming expressions] like 

-------------------------------------

  7 * (5.0+x) >= 0        ;; 1
  a and not (b || false)  ;; 2
  empty x ? 'foo' : x[0]  ;; 3

-------------------------------------

The expression in line (1) is a algebraic while (2) contains a boolean expression. The result of (1) depends on the resolution of variable `x` and similar does (2) on `a` and `b`. Line (3) shows the usage of two buildin operators, [#Operators see below for details].

The rest of this chapter introduces relevant details of EL in order to use it within Flaka.

=== Data Types ===
_EL_'s data types are integral and floating point numbers, strings, boolean and type `null`. Example data values of each type, except type `null`, are given above (1-3). Type `null` has once instance value also named `null`. While `null` can't be used to formulate an expression, it is important to understand that the result of evaluating an expression can be `null`. For example, the evaluation of a variable named `x` is the data object associated with that name. If no data is associcated however (i.e. if `x` is undefined), then `x` evaluates to `null`.

=== Strings ===
A EL string starts and ends with the same quotation character. Possible quotation characters are single the quote `'` and double quote `"` character. If string uses `'` as quotation character, then there is no need to _escape_ quoation character `"` within that string. Thus the following strings are valid:

-------------------------------------

 "a'b"   --> a'b
 'a"b'   --> a"b

-------------------------------------

If however the string's quotation character is to be used within the string, then the quoation character needs to be escaped from it's usual meaning. This is done by prepending character backslash:

-------------------------------------

 "a\"b"  --> a"b
 'a\'b'  --> a'b

-------------------------------------

To escape the backslash character from it's usual meaning (escaping that is), escape the backslash character with a backslash:

-------------------------------------

 "a\\"   --> a\
 'a\\'   --> a\

-------------------------------------

Other characters than the quotation and backslash character can't be escaped. Thus 

-------------------------------------

 "a\bc"  --> a\bc, NOT abc

-------------------------------------

However, a escaped backslash evaluates always into a single backslash character:

-------------------------------------

 "a\\b"  --> a\b,  NOT a\\b

-------------------------------------

This rules allow for an easy handling of strings. Just take an quoation character. Then, escape any occurences of the quoation and escape character within the string to preserve the original input string.

Here are same further examples strings:

-------------------------------------

"abc"        -- abc
'abc'        -- abc
"a'c'        -- illegal
"a'c"        -- a'c
'a\'c'       -- a'c
'a\bc'       -- a\bc
'a\\bc'      -- a\\bc
'a\"bc'      -- a\"bc
'a\\"bc'     -- a\\"bc
'ab\'        -- illegal
'ab\\'       -- ab\

-------------------------------------



=== Operators ===
Four _operators_ are defined in _EL_:
 # `empty` checks whether a variable is empty or not and returns either `true` or `false`. It is important to understand that `null` is considered empty.
 #  condition operator `c ? a : b` evaluates `c` in a boolean context and returns the evaluation of expression `a` if `c` evaluates to `true`; otherwise `eval(b)` will be the result of this operator.
 # `.` and ;
 # `[]` are property operators described in [#Properties Properties] below.

=== Properties ===

Every data object in _EL_ may have properties associated. Which properties are available has not been standardized in the http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf[specification]. In fact, this depends heavily on the underlying implementation and usage domain. What _EL_ specifies however, is how to query a property:

-------------------------------------

a.b.c

-------------------------------------

This expression can be translated into pseudo code as

-------------------------------------

 (property 'c' (property 'b' (eval a)))

-------------------------------------

which means that first variable `a` is evaluted, then property `b` is looked up on the evaluation result (giving a new evaluation result) and finally `c` is looked up giving the final result. 

Perhaps the most important point to notice is looking up a property on `null` is not an error but perfectly legal. No exception gets raised and no warning message generated. In fact, the result of such a operation is just `null` again.

From a practial point a question might be asked how to query a property which happens to contain the dot (`.`) character. In `a.b.c` example shown above, how would we lookup property `b.c` on `a`? Operator `[]` comes to rescue:

-------------------------------------

 a['b']        => a.b
 (a['b'])['c'] => a.b.c
 a['b']['c']   => a.b.c
 a[b]          => can't be expressed using '.'
 a[b.c]        => neither this ..
 a['b.c']      => query property 'b.c' on a 

-------------------------------------


So far, properties don't seem of any good use. The picture changes perhaps with this example:

-------------------------------------

 'abc'.toupper           => 'ABC'
 'abc'.length*4          => 12
 'abc'['tofile'].mkdir   => true/false

-------------------------------------

The last example demonstrates that there might also be http://en.wikipedia.org/wiki/Side_effect_(computer_science)[side effects] querying a property. In the example above, which is specific for Flaka, a directory `abc` gets created and the whole expression evaluates to `true` if the directory could get created and `false` otherwise.

See further down which properties are available on various data types.

=== Implicit Objects ===

Properties are good to query the state of data objects. The question is however, how do we get a data object to query in the first place? To start with _something_, [EL] allows the implementation to provide _implicit_ objects and [#Functions top level functions (see below)]. 

The following implicit objects are defined by Flaka:
|| Implicit Object || Type || Description ||
|| _name_          ||      || If _name_ is not a predefined name as listed in the rest of this table, then _name_ will be the same as `var[name]`, i.e. _name_ will resolve to the object associated with variable _name_. ||
|| project         || ||  Ant's underlying project object. It can be used to query the default target, base folder and other things. If you want to query properties, references, targets, tasks, taskdefs, macrodefs, filters etc., use appropriate implicit object instead. ||
|| property || || Use this object to query project properties. ||
|| var || || A object containing all project references.  ||
|| reference || || Same as `var` ||
|| target|| || Use this object to query a target ||
|| taskdef|| || Query taskdefs ||
|| macrodefs|| || Macros ||
|| tasks|| ||  Either taskdef or macrodef. Macros are specialized task and thus same the same namespace. ||
|| filter|| ||  A object containing all filters defined in this project. ||
|| e || double || The mathematical http://en.wikipedia.org/wiki/E_(mathematical_constant)[constant e], also known as http://en.wikipedia.org/wiki/Euler[Euler]'s number. || 
|| pi || double || The  mathematical http://en.wikipedia.org/wiki/P[constant pi] || 


An example for an EL expression fetching property `foo` is:

-------------------------------------

property.foo
project.properties.foo

-------------------------------------


Similar, a variable named `foo` is fetched like

-------------------------------------

foo                     -- (1)
var.foo                 -- (2)
reference.foo           -- (3)
project.references.foo  -- (4)

-------------------------------------



=== Functions ===

_EL_ also allows the implementation to provide top level functions. The following sections describe functions provided by Flaka. Some functions take an arbitrary number of arguments (inclusive no argument at all). This is denoted by two dots (`..`). An example of such a function is `list(object..)` which takes an arbitrary number of object to create a list.

|| Function || Type || Meaning ||
|| `typeof(object)` || string || The type of `object`, `int`, `string`, `file` etc ||
|| `size(object)`   || int  || Returns the object's size. The size of the object is given by the number of entities it contains. This is 0 (zero) for all primitive types. Otherwise the size is determined by an underlying `size()` method or `size` or `length` attribute of the object in question. || 
|| `sizeof(object)` || int  || same as `size(object)`, see above ||
|| `null(object)`    || bool || Evaluates to `true` if object is the `nil` entity; otherwise `false`. This function can be used to check whether a reference (var) or property exists. Operator `empty` can't be used for this task, cause `empty` returns `true` if either not existing or if literatly _empty_ (for example the empty string). ||
|| `file(object)`   || File || Creates and returns a file object out of `object`. If `object` is already a file, the object is simply returned. Otherwise, the object is streamed into a string and that string is taken as the file's path name. ||
|| concat(object..) || string || Creates a string by concatenating all stringized objects. If no object is provided, the empty string is returned. ||
|| list(object..) || list || Returns a list where the list's elements consists of the objects provided. If no objects are provided, the empty list is returned. ||
|| append(object..) || list || This function is similar to `list`. It takes the objects in order and creates a list elements out of them. If a object is a list, then elements of that list are inserted instead of the list object itself. For example `append('a,list('b'),'c')` evaluates to list `('a','b','c')` ||

Some mathematical functions are defined as well:

|| sin(double) || double || The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[sine] function ||
|| cos(double) || double || The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[cosine] function ||
|| tan(double) || double || The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[tangent] function ||
|| exp(double) || double || The mathematical exponential function, `e` raised to the power of the given argument ||
|| log(double) || double || The mathematical logarithm function of base `e` ||
|| pow(double) || double || Returns the value of the first argument raised to the power of the second argument. || 
|| sqrt(double) || double || Returns the correctly rounded positive square root of a double value. ||
|| abs(double) || double || Returns the absolute value of a double value. ||
|| min(double,double) || double || Returns the smaller of two double values. ||
|| max(double,double) || double || Returns the larget of two double values. ||
|| rand()      || double || Returns a double value with a positive sign, greater than or equal to 0.0 and less than 1.0. ||

=== Available Properties ===

In general properties are mapped as _attribute_ on the underlying data object. In Java, every _getX_ method taking no arguments identifies property _x_. As an example, assume that we have 

-------------------------------------

public class Foo {
 public .. getBar() { .. }
}

-------------------------------------

then an data object of type _Foo_ will have property _bar_ and thus the following expression `x.bar` would eventually call `Foo.getBar()` assuming that `x` evaluates to an object of type `Foo`. Such properties are the *natural* properties of a type.

=== Primitve Types ===

Primite data types (int, double, bool, null) have no properties.

=== List and Arrays ===

Besides their _natural_ properties (see discussion above) are _index_ properties available:

-------------------------------------

list('a','b')[1]  => 'b'

-------------------------------------

Negative indexes are currently not supported. If an index is specfies an not existing element, `null` is returned.


=== String Properties ===

Besides _natural_ properties (see discussion above) are the following properties supported:

|| Property || Type || Description ||
|| length   || int  || number of characters in this string ||
|| size     || int  || same as property `length` ||
|| tolower  || string || return this string in lowercase characters only ||
|| toupper  || string || return this string in uppercase characters only ||
|| trim     || string || remove leading and trailing whitespace characters ||
|| tofile   || file  || create a file based on this string; the so created will be relative to the current build file's base folder if the string's value does not denote a absolute path. Furthermore, the empty string will create a file object denoting the project's base folder (i.e. the folder containing the build script currently executed). Notice that `.` and `..` denote absolute paths, not relative ones. || 

=== File Properties ===

Files and folders is Ant's bread and butter. A couple of properties are defined on file objects to simplify scripting (see below). Most important is however how to _get_ a file object in the first place. This is most easily done by using string property `tofile`:

-------------------------------------

  'myfolder'.tofile.isdir 

-------------------------------------

In this example of an EL expression, string `myfolder` is converted in a File object using property `tofile`. In addition, the so created object is checked whether it is a folder or not.

The following _properties_ are defined on File objects:
|| Property || Type || Description ||
|| `parent` || File || parent of file or folder as file object ||
|| `toabs`|| File || file or folder as absolute file object ||
|| `exists` || bool || check whether file or folder exists ||
|| `isfile` || bool || check whether a file ||
|| `isdir`  || bool || check whether a folder (directory) ||
|| `ishidden` || bool || check whether a hidden file or folder ||
|| `isread` || bool || check whether a file or folder is readable ||
|| `iswrite` || bool || check whether a file or folder is writable ||
|| `size`   || int  || number of bytes in a (existing) file; 0 otherwise||
|| `length` || int  || same as `size` ||
|| `mtime`  || Date || last modification date  ||
|| `list`   || File[] || array of files in folder ; otherwise `null` ||
|| `tostr` || String || file name as string object ||
|| `touri`    || URI  || file as URI object ||
|| `tourl`    || URL  || file as URL object ||
|| `delete` || bool || deletes the file or folder (true); false otherwise ||
|| `mkdir`  || bool || creates the folder (and intermediate) folders (true); false otherwise ||

=== Matcher Properties ===

A _matcher object_ is created by task [Tasks#switch switch] if a regular expression matches a input value. Such a matcher object contains details of the match like the start and end position, the pattern used to match and it allows to explore details of capturing groups (also known as _marked subexpression).

|| Property || Type     || Description ||
|| `start`   || int     || The position within the input where the match starts. ||
|| `s`       || int     || Same as `start` ||
|| `end`     || int     || The position within the input where the match ends (the character at `end` is the last matching character)  ||
|| `e`       || int     || Same as `end`   ||
|| `groups`  || int     || The number of capturing groups in the (regular) expression. ||
|| `size`    || int     || Same as `groups` ||
|| `length`  || int     || Same as `groups` ||
|| `n`       || int     || Same as `groups` ||
|| `pattern` || string  || The regular expression that was used for this match. Notice that glob expressions are translated into regular expressions. ||
|| `p`       || string  || Same as `pattern` ||
|| _i_       || matcher || The matcher object for _i_'th capturing group. See task [Tasks#switch switch] for examples. ||


=== Evaluating in a boolean context ===

When evaluation a expr in a string context, a string representation of the final object is created. Similar, when a evaluation in a boolean context takes place, a conversion into a boolean value of the evaluated object takes place. The following table describes this boolean conversion:

|| evaluated object type || `true` || `false` ||
|| file                  || if the file exists || `false` otherwise ||
|| string                || if string is empty || `false` otherwise ||
|| null                  || never  || always || 
|| boolean               || if true || otherwise ||
|| _other_               || always  || never ||


== Howto Flaka ==

A chapter with questions and answers about how to do things with Flaka.

=== How to check whether a property is defined? ===


-------------------------------------

 <c:when test=" has.property[name] ">
  ...
 </c:when>

-------------------------------------


=== How to check whether a variable is defined? ===


-------------------------------------

 <c:when test=" has.var[name] ">
  ...
 </c:when>

-------------------------------------


=== How to check whether a reference is defined? ===


-------------------------------------

 <c:when test=" has.reference[name] ">
  ...
 </c:when>

-------------------------------------


=== How to check whether a target is defined? ===


-------------------------------------

 <c:when test=" has.target[name] ">
  ..
 </c:when>

-------------------------------------



=== How to check whether a Macro or Task is defined? ===

To check whether a macro or task exists use test -M as shown below:


-------------------------------------

 <c:when test=" has.task[name] ">
   <echo>either a macro or a task</echo>
 </c:when>

-------------------------------------


To check for a specific taskdef or macrodef, use `has.taskdef` or `has.macrodef`. 


=== How to check whether a property is empty? ===

A property is considered _empty_ if either not defined or consists only of whitespace characters.


-------------------------------------

 <c:when test=" empty property[name] ">
   ..
 </c:notempty>

-------------------------------------



=== How can I dynamically execute a target? ===
Use task run-target to run any target. For example


-------------------------------------

  <c:run-target name="hello" fail="false" />

-------------------------------------


This would execute the target hello if this target exists. Otherwise this task will simply be ignored in case attribute fail is set to false (which is the default). If fail is true, then calling a non-existing target throws an exception. Note that targets and macros are in a different namespace.

=== How do I dynamically execute a macro or task? ===
Use task run-macro for this task.


-------------------------------------

 -- just a normal macro .. 
 <macrodef name="greeting">
  <attribute name="message" />
  <sequential>
   <echo>@{message}</echo>
  </sequential>
 </macrodef>

 -- call it statically
 <greeting message="hello, static" />

 -- or dynamically
 <c:run-macro name="greeting">
   <arg name="message" value="hello, world"/>
 </c:run-macro>

-------------------------------------


Note that there is currently no way to call a macro with elements. Only attributes are supported.



== Flaka Glossary ==

A compilation of words and their meaning in Flaka.

=== Continuation Lines ===

A continuation line is a sequence of characters ending in `\NL` and not in `\\NL` (where NL is the line ending characters `CR LF` or `LF`. Tasks supporting continuation lines will accumulate the content of such a line with the (accumulated) content of the following line. The continuation character and the line ending characters are not accumulated.

-------------------------------------

a \
b\\
c\

-------------------------------------
 
Defines two accumulated lines: (1) `a b\` and (2) `c`.

=== Property Reference ===
A reference to a http://ant.apache.org/manual/using.html#properties[property] is written as `${..}`. Property references are handled by the Ant property handler. If not changed, then `${x}` will be replaced by the value of property `x` if such a property exists. Otherwise, the reference will be left as is.

=== Expression Reference ===

A reference to an [EL] expression is written as `#{..}`. [EL] is not part of Ant and can thus only be handled by certain tasks. References may appear in attribute values or in text elements. Not all attributes can handled EL references and neither all text elements. If a attribute or text element can handle EL references, it is specifically mentioned.

=== Base Folder ===

Relative files are usually meant to be relative to the current working directory. Not so in Ant, where a file is relative to the folder containing the build script of the current project. This folder is called the base directory or base folder. Ant defines property `basedir` to contain the (absolute) path name of this folder. When using [EL] expressions you can use the empty string to create the base folder as file object, like in ` ''.tofile `.

See also http://ant.apache.org/manual/using.html#built-in-props[built-in-props] for a list of standard Ant properties.


