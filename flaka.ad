= The flaka manual =
author wh@haefelinger.it
1.0, February 2010

== Introduction ==

In the world of http://en.wikipedia.org/wiki/Java_(programming_language)[Java], build scripts are traditionally written in http://en.wikipedia.org/wiki/Apache_Ant[Ant] and recently also in http://en.wikipedia.org/wiki/Apache_Maven[Maven].

When it comes to write a build script using Ant, it feels like using a Shell script in a rather awkward language (XML). Each Ant task solves a particular problem. This is similar to a Shell where you have this small masterpieces like `mkdir`, `cp`, `tar` plus some control structures to eventually being able to put the one big thing together.

Writing a build script using a Shell is serious business. And so it is when using Ant. Ant does not provide you any abstraction how the project needs to be build. There is no underlying logic. In fact you, the author, need to know what to do. Step by step. What's more, you have to use the unfriendly http://en.wikipedia.org/wiki/XML[XML] syntax and restrictions, a control structure is missing and you have to use immutable properties to communicate between tasks. Therefore, Ant scripts are large, notoriously difficult to understand, usually not portable (usuallyt they just work on the authors host) and each author uses a different set of targets and properties.

Maven on the other side provides a high abstraction of building a project. Instead of describing how the project needs to be build, just describe project details and reports you like to have and Maven figures out what needs to be done. This is probably the reason why Maven got so much attention recently.

Despite better knowledge I wrote that Maven figures out how a project needs to be build automatically. That’s actually not quite true. In fact, Maven only works fine when following conventions setup by the Maven team. When not “en route”, Maven gets difficult as well. But even when following conventions, the number of options in Maven are now endless and question the idear of a declarative approach. Have a look at Maven's http://maven.apache.org/ref/current/maven-model/maven.html[POM] being a never ending series of XML tags]. At the end, I found myself using Ant again.

Still I'm not happy with Ant. 

What I'm missing is the full power of a programming language. Yes, I want to have conditionals, loops and exception handling. I want to have variables which I can set or remove for pleasure. Such variables can reference any kind of object not only strings. And I need a nice expression language to retrieve and calculate in a simple yet elegant way. And there is no need to have each and everything expressed in XML. And then I want to have some kind of higher abstraction which does the right thing most of the time. This is what Flaka is about:

* Programming Tasks (conditional, loops, exception handling, ..)
* Embedded Expression Language (EL)
* Framework to do the _right_ thing, yet allows to use standard Ant when necessary
* Dependency handling (legacy, to be replaced by Ivy)

This four pillars are Flakas approach to simplify the process of writing a build script with Ant. Notice that you are by no means forced to use all four pillars. You can for example just use the  programming tasks with or without elements of EL while you don't need to get in touch with Flakas dependency handling instruments and neither with the framework. 

The folling example of a complete build script shall demonstrate the idear how a build script using Flaka looks like:

-------------------------------------------------
<project xmlns:c="antlib:it.haefelinger.flaka">
 <c:build />
 <c:dependency alias="log4j" />
</project>
-------------------------------------------------

The author just lists the dependencies required to build the project. Flaka would do the rest by checking the underlying project structure:

* figure out what type of project should be build (jar, war, ear ..)
* figure out where project's source code, test cases etc are
* handle dependencies
* create targets like `clean`, `compile`, `package`, `test` automatically
* generate Javadoc and other reports

=== Current Status ===

Not all targets have been reached in the current version of Flaka (Release candidate 1). Programming tasks and EL are working fine and can be used. The other two pillars work partially but generally not recommended (yet) to be used.

=== Where to go from here? ===

 * http://code.google.com/p/flaka/downloads/list[Download] Flaka and read the <<installation,installation page>>.
 * Have a look at the <<scripting,basic scripting elements>> to get an overview of tasks, types and macros provided by Flaka. Have a closer look in the reference part of this manual for all the gory details of those tasks, types and macros. 
 * Make sure to look into the chapter about the <<el,expression language>>, it contains a lot of information on this enormous useful extension.
 * Start writing build scripts using Flaka and give mailto:flaka@haefelinger.it[feedback].

//include::install.ad[]

//
// This should all go into Part 1 (so wee need to have a book here instead of an article)
//

== Programming Constructs ==

This chapter provides an overview of programming constructs Flaka provides. This programming constructs are one of the Flaka's pillars.

=== Strings ===
Like Ant, Flaka supports currently strings and, when applicable, pointer to resources (by referencing a symbol). Ant provides no functionality manipulate a string value and neither does Flaka. However, Flaka's expression language contains string functions to create new strings.

=== Symbols ===

Symbols are names carrying associated data. The name of a symbol is a sequence of characters. The allowed characters are basically unlimited. It is recommended to stick with well known characters [a-zA-Z0-9._-]. Symbols can be used as variables, target, task, type or macro names. 

 * `<property name=sym value=expr />` Use sym as variable: assign the value of _expr_ to _sym_. *A symbol associated with a string value is called a property*. Notice that Ant and Flaka provide further ways of creating properties. 
 * `<macrodef name=sym>`  Use _sym_ as macro name
 * `<target namesym>` Use _sym_ as target name
 * `<taskdef name=sym>` Use _sym_ as task name
 * `<typedef name=sym>` Use _sym_ as type name
 * `id=sym` Use sym as reference: assign the evaluation of task (or macro) to _id_ 

=== Properties === 

To reference a property, enclose it's symbol name with curly braces and prefix with the dollar character like:


-------------------------------------

<property name="x" value="99" />
<echo>
  value of property x is ${x}    -- .. is 99
</echo>

-------------------------------------


When referencing a non existing property, i.e. a symbol name not associated with a string value, the reference expression evaluates to itself, i.e. `${not-a-property}` evaluates to _${not-a-property}_. Standard Ant does not allow to change the association between a symbol name and it's string value once established:


-------------------------------------

<property name="x" value="99" />
<property name="x" value="The quick brown fox .."/>
<echo>
  value of property x is ${x}    -- .. is 99
</echo>

-------------------------------------


It can be done using Flaka's task <<task_let>> or <<task_unset>> as the following snippet demonstrates.


-------------------------------------

<property name="x" value="99" />
<c:let>
   x ::= "The quick brown fox .."
</c:let>
<echo>
  value of property x is ${x}    -- .. is The quick brown ..
</echo>

-------------------------------------


Properties have their own symbol table (as targets, tasks, macros and types have). This means for example that it is possible to have a property and a task _sharing_ the same symbol name:


-------------------------------------

  <property name="foobar" ../>
  <macrodef name="foobar" ../>  -- property foobar not harmed!

-------------------------------------


=== Sequencing ===

To evaluate a sequence of expressions (tasks or macros) where only one expression is allowed, use http://ant.apache.org/manual/CoreTasks/sequential.html[Ant's sequential task]:


-------------------------------------

 <sequential>
   -- any sequence of tasks or macros
 </sequential>

-------------------------------------


Note that _sequential_ returns nothing. Use properties to communicate with the caller if necessary.

=== Conditionals ===

With standard Ant, task http://ant.apache.org/manual/CoreTasks/condition.html[condition] is used to set a property if a condition is given. Then a macro, task or target can be conditionally executed  by checking the existence or absence of that property (using standard attributes _if_ or _unless_. Flaka defines a couple of control structures to handle conditionals in a simpler way.

=== when and unless ===

Task <<task_when>> evaluates an <<el>> expressio. If the evaluation gives `true`, the sequence of tasks are executed. Nothing else happens in case of `false`. 


-------------------------------------

<c:when test=" expr ">
   -- executed if expr evaluates to true
</c:when>

-------------------------------------


The logical negation of `when` is task <<task_unless>> which executes the sequence of tasks only in case the evaluation of _expr_ returns `false`.


-------------------------------------

 <c:unless test=" expr ">
   -- executed if expr evaluates to false
 </c:unless>

-------------------------------------


The body of `when` and `unset` may contain any sequence of tasks or macros (or a combination of both).

=== choose ===

Task <<task_choose>> tests each `when` condition in turn until an _expr_ evalutes to `true`. It executes then the body of that when condition. Subsequent `whens` are then not further tested (nor executed). If all expressions evaluate to `false`, an optional _catch-all_ clause gets executed.


-------------------------------------

 <c:choose>
  <when test="expr_1">
    -- body_1
  </when>
  ..
  <otherwise> -- optional_
    -- catch all body
  </otherwise>
 <c:/choose>

-------------------------------------


=== switch ===

A programming task often seen is to check whether a (string) value matches a given (string) value. If so, a particular action shall be carried out. This can be done via a series of _when_ statements. The nasty thing is to keep track of whether a value matched already. Flaka provides a handy task for this common scenario, the <<task_switch>> task:


-------------------------------------

 <c:switch value=" 'some string' ">
  <matches re="regular expression or pattern" >
    -- body_1
  </case>
  ..
  <otherwise> -- optional
    -- catch all body
  </otherwise>
 </c:switch>

-------------------------------------


Each case is tried in turn _to match_ the string value (given as <<el>> expression). If a case matches, the appropriate case body is executed. If it happens that no case matches, then the optional default body is executed. To be of greater value, a regular expression or pattern expression can be used in a case condition.

=== Repetition ===

Flaka has a looping statement. Use task <<task_for>> to iterate over a _list_ of items. Use <<task_break>> and <<tasks_continue>> to terminate the loop or to continue the loop with the next item.


-------------------------------------

 <c:for var=" name " in=" ''.tofile.list ">
    -- sequence of task or macros
    -- used <c:continue /> to continue ; and
    -- <c:break /> to stop looping
    -- use #{name} to refer to current item (as shown below)
    <c:echo>#{name}</c:echo>
 </c:for>

-------------------------------------


Attribute `in` will be evaluated as <<el>> expression. In the example above, that <<el>> expression is `''.tofile.list` which, when evaluated, creates a list of all files in the folder containing the current build script. To understand the expression, have a look at <<el_string_properties,properties>> of a string] and <<el_file_properties,properties>> of a file.


=== Exception Handling ===

Flaka has been charged with exception handling tasks.

=== trycatch ===

Flaka contains a task to handle exceptions thrown by tasks, <<task_trycatch>>. This task implements the usual _try/catch/finally_ trinity found in various programming languages (like in Java for example):


-------------------------------------

 <c:trycatch>
   <try>
     -- sequence of task or macros
   </try>
   <catch>
     -- sequence of task or macros
   </catch>
   <finally>
     -- sequence of task or macros
   </finally>
 </c:trycatch> 

-------------------------------------


Element _try_, _catch_ and _finally_ are all optional or can appear multiple times. If _catch_ is used without any argument, then that catch clause will match any *build exception*. To differentiate between different exception types, _catch_ can additionally be used with a _type_ and _match_ argument. The former can be used to select a particular exception type (like a 'java.lang.NullPointerException), the latter can be used to select an exception based on the message carried. Both arguments are interpreted as pattern expression. For example:


-------------------------------------

 <c:trycatch>
   <try>
      ..
      <fail message="#PANIC!" unless="ant.file"/>
      ..
   </try>
   <catch match="*#PANIC!*">
      <echo>Ant initialization problem!!</echo>
      <fail/>
   <catch type="java.lang.*">
     -- handle Java runtime problems
   </catch>
   <catch>
     -- handle all other build exceptions
   </catch>
  </c:trycatch>

-------------------------------------


Property _ant.file_ is a standard Ant property that should always be set. If not, there's something seriously wrong and it does not make much sense to continue. Use attribute _type_ to catch (runtime) exceptions thrown by the underlying implementation.

=== throw ===

Task <<task_throw>> throws a (build) exception.


-------------------------------------

 <c:throw [var="sym"] />

-------------------------------------


This task can also be used to rethrow an existing exception.

=== Macros  ===

The (almost) equivalent of a function is a macro in Ant and Flaka. For example:

-------------------------------------

 <macrodef name="hello">
  <attribute name="msg" />
  <element name="body" implicit="true" />
  <sequential>
   <body />
  </sequential>
 </macrodef>

-------------------------------------


Once defined, simply use it:

-------------------------------------

<hello msg="Hello, world!">
 <echo>@{msg}</echo>
</hello>

-------------------------------------


This macro evaluates into 

-------------------------------------

 <echo>Hello, world!</echo>

-------------------------------------

which eventually prints the desired greeting.

Macros are a standard feature of Ant.

//
// The EL chapter.
//

include::sections/el.ad[]

//
//include::howto.ad[]
//

== Part II ==

Each of the following chapters describes a task in all it\'s details.

include::sections/task_echo.ad[]
include::sections/task_let.ad[]
include::sections/task_list.ad[]
include::sections/install-property-handler.ad[]
//include::sections/task_properties.ad[]
//include::sections/todo.ad[]
//include::sections/not-yet-ready.ad[]
