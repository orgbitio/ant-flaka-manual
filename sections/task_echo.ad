

== echo ==

Ant has an echo task to dump some text on a screen or into a file. A problem with this task is, that the output produced is rather fragile when it comes to reformatting your XML source. Here is a simple example. 

-------------------------------------
<echo>foobar</echo>
-------------------------------------

When executed by Ant, this dumps 

-------------------------------------
[echo] foobar
-------------------------------------

However, one day you reformat your XML build file footnote::[ http://xmlsoft.org/xmllint.html[xmlint] is a good choice] and you end up in

-------------------------------------
<echo>
...foobar
</echo>
-------------------------------------

Notice that I'm using here the dot character `.` to make whitespace characters (except line ending characters) visible. If you execute this, you will get 
-------------------------------------
[echo] 
[echo] ...foobar
[echo]
-------------------------------------

This is definitly not what you had in mind.

Task `<c:echo/> is an extension of Ant's standard `echo` task. It uses Ant's standard `echo` task for doing the low level work, i.e. dumping text on streams on loggers while some features have been implemented intented to generate nicly formatted output.

Here is the `foobar` example again:

-------------------------------------
<c:echo>

  foo\
  bar
  ; supports continuation and \
  comment lines
</c:echo>
-------------------------------------

This would output

-------------------------------------
[c:echo] foobar
-------------------------------------

which I believe is just what you had in mind.

=== Attributes ===

This tasks supports all attributes inherited from Ant's echo task. In addition, further supported attributes are:
[cols="3*15%,55%"]
|=============================
| Attribute | Type    | Default | Description 
| `debug`   | boolean | false   | Enables additional debug output for this particular task.
| `comment` | string  | `;`      | Allows for comments. 
| `shift`   | string  | ``       | Allows to prefix each line with `shift` characters. See also Behaviour below. 
| `ic`      | string  | `>`       | Allows to set the indentation character (see explanation below). 
|=============================

Notice that *debug* output will be written on stream `stderr` regardless whether `debug` has been globally enabled on Ant or not. Also standard Ant loggers and listeneres are ignored. The default value is `false`, i.e. no additional output is created. 

The trimmed *`comment`* attribute value is used to construct a regular expression like `^\s*\Q<<comment>>\E`. Every line matching this regular expression will not show up in the output. Notice that the comment value given does not allow for regular expression meta characters. Thus something like `(;|#)` does _not_ mean either `;` or `#`. Instead it means that a line starting with `(;#)` is ignored from output. By default, lines starting with character `;` - like in Lisp - are ignored.

=== Elements ===

This task accepts implicit text. Text may contain Ant property references `${..}` or [EL Flaka EL] references `#{..}`.


=== Behaviour ===

*Continuation Lines* are lines where the last character before the line termination character is the backslash character. Such a line is continued, i.e. the line will be merged with the next one (which could also be a continuation line).   

A (merge continuation) line starting with an arbitrary number of whitespace characters followed by the characters given in attribute `comment` is a *comment line*. Such lines are removed from output. The characters given are taken literaly and have no meta character functionality. To disable comment lines altogether use an empty string footnote::[A string consisting only of whitespace characters].

To allow a *decent formatting* unnecessary whitespace characters are removed. The process is illustrated footnote::[Again character dot `.` is used to illustrate a whitespace character with the exception of line ending characters] using the introduction example used above:

------------------------------------
<c:echo>

..foo\
..bar
</c:echo>
-------------------------------------

In a first step is the first non-whitespace character determined. In the example above, this is character `f`. From there Flaka counts backwards until a line termination character or the begin of input is reached. The counted number is the amount of whitespace characters stripped from the begin of each line. If a line starts with less than that amount of whitespace characters, then only those available are removed. Additionally, all whitespace characters before the first non-whitespace character are removed from the input.

There are two whitespace characters before `foo\`. If support for continuation lines would have been disabled, Flaka would dump the following:

-------------------------------------
[c:echo] foo\
[c:echo] bar
-------------------------------------

Handling of continuation lines takes place *after* whitespace has been stripped. Thus Flaka prints

-------------------------------------
[c:echo] foobar
-------------------------------------

as shown in the introduction example. A slight variation of the example above is given next:
------------------------------------
<c:echo>

..foo\
.bar
...indended by one character, right?
</c:echo>
-------------------------------------

Notice that in front of `bar` is only one whitespace character while there are three in the line after. What will be Flaka's output?
 
-------------------------------------
[c:echo] foobar
[c:echo] .indended by one character, right?
-------------------------------------

As you can see, no more than the initial counted amount of whitespace is removed from each line.

However, assume that you really want to have a couple of empty lines dumped before any real content. How can this be done. There are two options. Firstly you can always fall back to use Ant's standard `echo` task. Secondly, you can use a comment line like shown next

------------------------------------
<c:echo>
..; two empty lines following


..foobar
</c:echo>
-------------------------------------

which would dump:

-------------------------------------
[c:echo] 
[c:echo] 
[c:echo] foobar
-------------------------------------


Here we have a situation like in real life's politics. There are thousand opinions how to do it proper and finally we end up in a mess. For example, take your favorite editor and format the above and you will end up in something like

-------------------------------------

<echo>
..foobar
</echo>

-------------------------------------

To better illustrate the point, I have used `.` to indicate a whitespace character (typically either the blank or tab character). Running the _formatted_ build script again, we end up in

-------------------------------------

[echo]
[echo] ..foobar

-------------------------------------

As already mentioned, this is like politics because now we get something we definitly didn't want to have in the first place: _Two_ lines are printed and additionally those whitespace characters are popping up. Oh no ..

Let's try and see Flaka's `echo` behaviour:

-------------------------------------

<c:echo>
..foobar
</c:echo>

-------------------------------------

This ouputs 

-------------------------------------

[c:echo] foobar

-------------------------------------

and this is exactly what we want to have. Only a single line is printend and now matter how much whitespace there is in front of `foobar`, it's all discarded.

Another example where, again, character `.` indicates a whitespace character:

-------------------------------------

<c:echo>
..hello,
....world
</c:echo>

-------------------------------------

The author's intention is to have `world` intended by two characters. Again, the overall problem is that formatting this snippet with some (XML) editor will very likely remove this extra indentation level. Let's see how Flaka behaves:

-------------------------------------

[c:echo] hello
[c:echo] world

-------------------------------------

All _extra_ whitespace has been removed! Ok, that's not what we wanted. However, there is something called a `indentation character`, `ic` for short:

-------------------------------------

<c:echo ic=">">
..hello
..>>world
</c:echo>

-------------------------------------

The overall idea is simply to treat the indendentation characgter as whitespace character if appearing before the first non-whitespace character in each line. Then all leading whitespace would be discarded and all `indentation` characters would be printed as whitespace. This gives:

-------------------------------------

[c:echo] hello
[c:echo] ..world

-------------------------------------

Excellent, now our output is idempotent regarding XML formatting.

As a last wish, how about shifting the whole output by `N` whitespace characters? This is achieved by setting attribute `shift` to the desired level. For example:

-------------------------------------

<c:echo shift="2">
..hello
..>>world
</c:echo>

-------------------------------------

Notice that attribute `ic` is not used here cause `>` is the default ic character. This gives

-------------------------------------

[c:echo] ..hello
[c:echo] ....World

-------------------------------------


If you want to use a different prefix character, use `amount*character` as argument for attribute `shift` as shown below:

-------------------------------------

<c:echo shift="3*%">
        >
</c:echo>

-------------------------------------

This gives:

-------------------------------------

[c:echo] %%%

-------------------------------------


=== Further Links ===
 * http://javadoc.haefelinger.it/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Echo.html[Javadoc]
 * http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Echo.java[Source]

