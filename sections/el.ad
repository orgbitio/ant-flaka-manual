
The _Unified Expression Language_ footnote:[http://en.wikipedia.org/wiki/Unified_Expression_Language], further in this document abbreviated as _EL_, is a special purpose programming language typically used for embedding expressions in web applications. While EL is part of the JSP Specification, it does not depend on JSP and can therefore be used in a variety of other contexts. One such context is Ant. Consider the following example footnote:[To make this example work, one need to globally enable EL for all string contexts. By default, EL is _not_ globally enabled. To enable it globally, use Flaka\'s task `<c:install-property-handler/>`]:

-------------------------------------
<echo>
  Modified #{ format('%tD', file(project).mtime) }
<echo>
-------------------------------------

The EL expression here, a function call with two arguments, utilizes two standard of Flaka\'s standard functions, namely `format()` for creating a string and `file()` for turning something into a file object. Function `format()` accepts an arbitrary number of arguments. Two arguments are provided in this example. A string argument as the first argument while the second argument is the object returned by querying property `mtime` on the file object returned `file(project)`.  Argument `project` is one of Flaka\'s implicit objects. In particular, `project` represents the current Ant project. The evaluation of `file(project)` is the project\'s base directory as file object. Such a file object has various properties. One property is the file\'s last modification time available as property `mtime`. The whole EL expression is embedded in the textual context of Ant\'s standard `echo` task.  The embedment is done using `#{` and `}` respectively. When executed, this snippet produces something like
 
-------------------------------------
[echo] Modified 10/29/10
-------------------------------------

Here are some further examples of EL expressions:

-------------------------------------
7 * (5.0+x) >= 0             ; (1)
a and not (b || false)       ; (2)
empty L ? null : L[0]        ; (3)
list('a','b')                ; (4)
split('a,b',',')             ; (5)
project.name                 ; (6)
size(file('.').list)         ; (7)
-------------------------------------

The first expression (1) shows a algebraic equation. Notice the usage of `5.0` being of type float, `7` being an integral type and furthermore `x` as variable. A Boolean expression is shown in the second example using operators `and`, `not` and operator `||`. The same expression could also have been written like `a && !(b or false)`. Example (3) shows operator `empty` and conditional operator `?:`. The expression could be read like: check whether a (list) object is empty. If empty, return `null`, otherwise return the list\'s first item. The fourth and fifth expression shows two list generating functions - `list()` just collects all arguments into a list while `split()` breaks a string apart based on a regular expression. The project\'s name is queried in example (6) while example (7), calculates the number of files and folders in the current working directory.

[[el_enabling_el,Embedding EL]]
=== EL References ===

It turned out that it is a good idea to have a clear distinction between properties and EL expressions. Therefore, an EL expression must be enclosed by `#{..}` rather than by `${..}`. A enclosed EL expression is called an reference to a EL expression. Similarly is `${..}` named a reference to a Ant property. Consider:

---------------------------
<echo>
 ${3 * 4}   ; Property reference
 #{3 * 4}   ; EL expression reference
</echo>
---------------------------

Ant is by default not aware of EL. Thus the EL reference `#{3 * 4}` would not be evaluated and would be passed as is. To let Ant evaluate EL expression references, EL must be enabled footnote:[see task <<task_install_property_handler,`install-property-handler`>> for how to do this]. Once enabled, EL references can be used wherever Ant property references can be used. Consider:

---------------------------
<echo>
 #{3 * 4}   ; still #{3 * 4}
</echo>
<c:install-property-handler />
<property name="twelve" value="#{ 3 * 4 }" />
<echo>
 #{3 * 4}   ; 12  
 ${twelve}  ; 12
</echo>
---------------------------
==== Enabling ====

To enable EL references in addition to Ant property references, Ant\'s standard property helper engine must be exchanged. This is best done using Flaka\'s  <<task_install_property_handler,`install-property-handler`>> task. This task can be used everywhere. It is however recommended to (a) call it only once (b) to call it as early as possible.

Starting with version 1.8 Ant provides a task for switching property helpers. This task can also be used to change the characteristics how Ant property references are handled. To support this new property API, Flaka provides a second Antlib in addition to the standard one. Consider:

---------------------------
<project xmlns:prop="antlib:it.haefelinger.flaka.prop">
 <propertyhelper>
    <prop:elreferences />
 </propertyhelper>
 <echo>
   #{ 3 * 4 }   ; 12
 </echo>
</project>
---------------------------

For those who want to stay more in-line with Ant property references, Flaka ships with a property evaluator. When this evaluator is plugged in, `${..}` will be evaluated as EL reference. Consider:

---------------------------
<project xmlns:prop="antlib:it.haefelinger.flaka.prop">
 <propertyhelper>
    <prop:elevaluator />
 </propertyhelper>
 <echo>
   ${ 3 * 4 }   ; 12
 </echo>
</project>
---------------------------

==== Conversion ====

Ant properties are strings, thus Ant properties are used in string contexts and consequently the same applies for EL references. When an EL reference is seen, the EL expression is firstly evaluated into an object of some type _T_. Then, in a second step, that object value is coerced footnote::[implicitly type converted] into a string value.

==== Nested References ====

Nested references are _not_ supported. The following example, which tries to do some sort of meta-programming on implicit object `project`, is therefore illegal

-------------------------------------
<c:echo>
     #{ project.#{ property } }   ; illegal
</c:echo>
-------------------------------------

==== Nested Properties ====

Ant property references `${..}` are resolved before any EL reference is resolved. Consider:

-------------------------------------
<property name="pname" value="basedir" />
<c:echo>
     #{ project.${pname} }        ; project.basedir
     ${ project.#{ 'basedir' }}   ; no way
</c:echo>
-------------------------------------

==== The Great Escape ====

How about getting a character sequence like `#{ 3 * 4}`?. In other words, how to prevent a EL reference from being evaluated? There are basically two techniques available. Consider:
-------------------------------------
<echo>
 #{ '#{3 * 4}' }        ;    #{ 3 * 4 }
     \#{ 3 * 4 }        ;    #{ 3 * 4 }
</echo>
-------------------------------------

The first line shows the recommended technique, i.e. embed the character sequence `#{` in a EL string. The second line demonstrates the usage of `\#{` as escape sequence. Using this escape sequence is counter intuitive. Consider:
-------------------------------------
<echo>
     #{ 3 * 4 }        ;    12
    \#{ 3 * 4 }        ;    #{ 3 * 4 }
   \\#{ 3 * 4 }        ;   \#{ 3 * 4 }
  \\\#{ 3 * 4 }        ;  \\#{ 3 * 4 }
 \\\\#{ 3 * 4 }        ; \\\#{ 3 * 4 }
</echo>
-------------------------------------

In other words, when character sequence `\#{` is seen, then character `\` is consumed and `#{` does not start an EL reference, i.e. the sequence is taken literally.  It has to be noted, that character `\` alone does not have any meaning and is especially not a general escape character. Thus any number of contiguous backslash characters before an EL reference successfully disables its evaluation. 

Given this behaviour, how is it then possible to create backslash characters before an evaluated EL reference? As an example, assume that we have a EL variable named `host` and our task is to generate a UNC footnote:[Uniform Naming Convention, see also http://en.wikipedia.org/wiki/Path_(computing)#Uniform_Naming_Convention] notation. Consider:

-------------------------------------
<echo>
 \\#{ host }                   ;    \#{ host }  
 #{ format('\\\\%s',host) }    ;    \\myhostname
</echo>
-------------------------------------

Please notice that escaping a property reference is different than escaping a EL reference. A property reference is taken literally if prefixed by character `$`. In addition, _every_ double dollar sequence `$$` is reduced into a single dollar character. Consider:

-------------------------------------
<echo>
   ${foo}          ; bar
  $${foo}          ; ${foo}
 $$${foo}          ; $bar
$$$${foo}          ; $${foo}
 foo $ bar         ; foo $ bar
foo $$ bar         ; foo $ bar
</echo>
-------------------------------------


==== Whitespace ====

Trailing and leading whitespace is meaningless within EL references. This is different from Ant properties where whitespace is meaning full. Consider:

-------------------------------------
<property name=" p " value="weired name ' p '" />
<property name="p" value="regular name 'p'" />
<c:echo>
     ${p}                 ; regular name 'p'
     ${ p }               ; weired name ' p '
     #{ p }               ; regular name 'p'
     #{ property[' p '] } ; weired name ' p '
</c:echo>
-------------------------------------

==== Syntax Errors ====

A syntax error in a EL expression will be silently ignored. Furthermore, the EL engine will tries to recover by ignoring all characters until either character `}` or `<eof>`, the end of input, is seen. Consider:

-------------------------------------
0#{ 3 * 3    ; 0
0#{ 3 * }3   ; 03
0#{ 3 * 4 }3 ; 0123 
-------------------------------------


==== EL Awareness ====

Flaka is naturally EL aware. Regardless of whether EL has been enabled or not, all Flaka tasks understand EL references `#{..}` without any additional action.

In addition, attributes of tasks provided by Flaka can be _typed_. A argument provided to a _typed_ attribute is expected to be an EL expression. Evaluating that expression will be done in the context of an expected _type_. Consider attribute `test` of Flaka\'s <<task_when,`when`>> task:

-------------------------------------
<c:when test=" file(path).isdir ">
  <!-- do something with that dir folder .. -->
</c:when>
-------------------------------------

Attribute `test` is typed and it\'s expected type is `boolean`. The argument must be a an EL expression, here `file(path).isdir`. That EL expression will be evaluated into some object and then, in a second step coerced into a boolean value.

Notice that Ant and EL references can be used in typed attributes. After all, a typed attribute is a regular attribute as far as Ant is concerned. It is just Flaka who is evaluating the expression as EL. Thus consider this kind of meta-programming , that all attributes are handled by the currently installed property handler. Thus even for attribute `test` the normal attribute rules apply. Consider this kind of meta-programming where by default an object is queried for property `isdir` subject to whether variable `prop` is empty or not. If not empty, then the value is queried for property `prop`:

-------------------------------------
<c:when test=" obj.#{ empty prop ? 'isdir' : prop} ">
 ..
</c:when>
-------------------------------------

The following sections will handle some advanced issues regarding EL references and especially their relation with Ant property references.



[[el_data_types,EL Data Types]]
=== Data Types ===

The following types can be used when writing EL expressions:

* _null_ to represent the absence of any data  
* _integer_ for integer values
* _float_ for any floating point values
* _boolean_ to express Boolean logic
* _string_ to represent char sequences
* _list_ for iterable types
* _map_ for dictionary like types
* _file_ representing file objects
* _project_ representing Ant project instances
* _object_ for all other data values

The question is how to get a element of those? EL defines literals denoting elements of type `null`, `integer`, `float`, `boolean`, and `string`. Furthermore there are implicit objects and functions, see below.


==== Null Literals ====

The `null` type contains only one data element also called `null`. From a semantic point of view it is used to represent the absence of any data. Within EL, `null` has an interesting characteristic: it can be asked whether it has a certain property and the answer will always be `null` again. Consider:

-------------------------------------
null['any property']   ; null
null.mtime             ; null
-------------------------------------

This rather different from other languages where asking `null` for a property is asking for trouble, i.e. null pointer exception and the like. Notice also the following differences between operator `empty` and function `nullp()` when working with value `null`:

-------------------------------------
empty null     ; true
empty list()   ; true
empty ''       ; true
nullp(null)    ; true
nullp(list())  ; false
nullp('')      ; false
-------------------------------------

==== String Literals ====

A string literal starts and ends with the same quotation character. Quotation characters are either the single quote `'` or the double quote `"` character. If the quotation character is needed within the literal, then the escape character `\` must be used. The escape character must also be used if the escape character itself is to be expressed in the literal. The escape character can\'t be used to escape other characters than the quotation character and the escape character.
-------------------------------------
"abc"        ; abc
'abc'        ; abc
'abc"        ; illegal
"a'c"        ; a'c
'a"c'        ; a"c
'a\'c'       ; a'c
'a\"c'       ; a\"c
"a\"c"       ; a"c
'a\bc'       ; a\bc
'a\\bc'      ; a\bc
'ab\'        ; illegal
'ab\\'       ; ab\
-------------------------------------

==== Object  Literals ====

Well, EL has no notation for _object_ literals like literals for type integer and boolean. So, how to get an object in the first place? There are two possibilities:

* use an implicit object; and
* use a function 

Once you have an object, you can in addition
* use an object\'s property 
to retrieve another object. When does a property exist and how to retrieve it? This and other questions are answered in section <<el_properties>> while section <<el_implicit_objects>> lists available implicit objects and section <<el_functions>> is about functions to be used.

Notice that EL does also not provide a notation for arrays or list objects nor is there a `list` data type. Nevertheless, Flaka provides a `list()` function to create a collection of arbitrary objects. There is also task `for` able to iterate over collection types and there is function `size()` which returns the number of items in a collection. How does this work? EL uses a concept called _duck typing_ where a object\'s type is not given by a class but rather by it\'s properties: _I call every object that walks, swims and quacks like a duck, a duck_. Thus properties are looked up during runtime and a object provides all required properties, the object is applied.

[[el_variables]]
=== Variables ===

The EL language does not allow you to create variables and must thus be created by other means footnote:[See task <<task_let>> for creating EL variables, properties and overriding properties]. Nevertheless, variables can be used within expressions. When a _name_ is evaluated, then _name_ is looked up 

* as implicit object; or
* as entry in EL\'s variable dictionary; or
* as Ant property name

in this particular order, consider:

-------------------------------------
<property name="p" value="property" />
<property name="q" value="property" />
<c:let>
 q = 'variable'
</c:let>
<echo>
 ${p}           ; 'property'
 #{p}           ; 'property'
 ${q}           ; 'property'
 #{q}           ; 'variable'
 #{property.q } ; 'property'
</echo>
-------------------------------------

If no entry can be associated with _name_, then `null` will be the look-up\'s result. This has the interesting consequence, that EL references are _always_ disappearing, i.e. can always be resolved. Whereas unknown properties remain as  property references. Consider:

-------------------------------------
<echo>
 ${not_a_name}  ; ${not_a_name}
 #{not_a_name}  ; ''
</echo>
-------------------------------------


[[el_operators]]
=== Operators ===

The following operators are defined in <<el,EL>>:

* operator `empty` checks whether a variable is empty or not and returns either `true` or `false`. It is important to understand that `null` is considered empty. 
* condition operator `?:` can be used for branching in expressions. The expression `cond ? a : b` evaluates expression `cond` in a Boolean context. If `eval(cond)` returns `true` then the result of the expression is `eval(a)` and otherwise `eval(b)`.
* operators `.` and  `[]` are used to query properties on objects. See also section <<el_properties,Properties_>>.
* logical operators `not`, `and` and `or`
* relational operators `==`, '!=`, `<`, `>`, `<=` and `>=` (resp. `eq`, `ne`, `lt`, `gt`, `le` and `ge`).
* usual arithmetic operators like `+`, `-`, `*`, `/`, `mod` and `div` etc.


[[el_implicit_objects,EL Implicit Object]]
=== Implicit Objects ===

Flaka provides implicit objects that can be utilized writing <<el>> expressions:

[cols="1*25%,75%",frame="topbot",grid="none",options="header,footer"]
|==================================
| Implicit Object | Description 
| project         | The current Ant project as object. To query the project\'s default target, base folder and other things (see also <<el_project_properties,project properties>> and <<el_natural_properties,natural properties>>). 
| property | Use this object to query project properties. 
| e | The mathematical number http://en.wikipedia.org/wiki/E_(mathematical_constant)[e], also known as http://en.wikipedia.org/wiki/Euler[Euler]'s number.
| pi | The number http://en.wikipedia.org/wiki/PI[PI] 
|==================================

The following implicit objects are deprecated:

[cols="1*25%,75%",frame="topbot",grid="none",options="header,footer"]
|==================================
| Implicit Object | Alternative
| reference | `project.references`
| var | `project.references`
| target| `project.targets`
| taskdef| `project.taskdefs`
| macrodefs| `project.macrodefs`
| tasks| `project.tasks`
| filter| `project.filters`
|==================================


[[el_functions,EL Functions]]
=== Functions ===

This sections presents functions defined by Flaka and which are available without any further action. Notice that providing own functions is currently not possible. A note about the conventions used in the notation of function signatures:

* _T_ is a placeholder meaning any type
* _T.._ means that a variable list of arguments of type _T_ can be used 
* _name:T_ is used to give a parameter a name which is then used in the follow up explanation of this function. 



==== Generic Functions ====

===== `typeof(T):string` =====

A function to determine the object\'s type:
-------------------------------------
typeof(null)               ; 'null'
typeof('')                 ; 'string'
typeof(3)                  ; 'integer'
typeof(pi)                 ; 'float'
typeof(true)               ; 'boolean'
typeof(list())             ; 'list'
typeof(file('.'))          ; 'file'
typeof(project)            ; 'project'
typeof(project.properties) ; 'map'
typeof(other)              ; 'object'
-------------------------------------

===== `nativetype(T):string` =====

Use this function to determine native type, the type of the underlying implementation, of the given argument.
-------------------------------------
nativetype(null)                ; ''
nativetype('')                  ; 'java.lang.String'
nativetype(3)                   ; 'java.lang.Long'
nativetype(pi)                  ; 'java.lang.Double'
nativetype(true)                ; 'java.lang.Boolean'
nativetype(list())              ; 'java.util.ArrayList'
nativetype(file(project))       ; 'java.io.File'
nativetype(project)             ; 'org.apache.ant.tools.Project'
nativetype(project.properties)  ; 'java.util.Hashtable'
nativetype(file(project).mtime) ; 'java.util.Date'
-------------------------------------


===== `size(T):integer` =====

The size of the object is given by the number of entities it contains. This is 0 (zero) for all primitive types like `integer`, `null`, `float`, `boolean`. Otherwise the object\'s size is determined via a `size` or `length` property.
-------------------------------------
size(null)            ; 0
size(3)               ; 0
size(pi)              ; 0
size(true)            ; 0
size('abc')           ; 3
size(list(1,2))       ; 2
size(file(..))        ; see below
size(project)         ; 0
size(object)          ; object.size or object.length or 0
-------------------------------------

If the argument of `size()` is of type _file_ and the argument denotes an existing and accessible directory _d_, then `size(d)` returns the amount of files and folders in _d_. Otherwise, if the argument denotes an existing and accessible file, then the length of that file is returned. Otherwise, size() will return 0.

===== `nullp(T):boolean` =====

Evaluates to `true` if object is the `null` entity and `false` otherwise. Compare this function with operator `empty` which returns `true` if either the object in question does not exist or if literally empty, for example the empty list or the empty string.

-------------------------------------
nullp(null)            ; true
nullp(list())          ; false
nullp('')              ; false
empty null             ; true
empty list()           ; true
empty ''               ; true
-------------------------------------

==== File and Folder Functions ====

===== `file(T..):file` =====
A function to create a `file` object. If `file()` is called without argument, then the current working directory is returned. Otherwise, if the function is called with one argument and that argument is already a file, the argument is simply returned. Otherwise, if the argument\'s type is `project`, then the base directory of that Ant project is returned. If the argument is a `list` type, the a file is constructed based on the list\'s elements. Otherwise the argument stringized. If the stringized argument consists only of whitespace, then the current working directory is returned while otherwise that string is taken as the file\'s path name. If `file()` is called with two or more arguments, then the behaviour is the same as if `file()` would have been called with one list argument where the list consists of the function\'s arguments.

-------------------------------------
file()               ; your JVM current work directory
file('.')            ; file()
file(file(arg))      ; file(arg)
file(project)        ; project.basedir
file(list('/',a))    ; file('/',file(a))
file(other)          ; file(format('%s',other)) 
file(a,b,c)          ; file(list(a,b,c))
file(a,list(b,c),d)  ; file(list(a,b,c,d))
-------------------------------------

==== String Functions ====

===== `concat(T..):string` =====
Creates a string by concatenating all _stringized_ objects. If no object is provided, the empty string is returned. Thus to create the string `foobar`, try
-------------------------------------
concat('foo','bar')  ; 'foobar'
-------------------------------------

===== `format(string,T..):string` =====
This function is a Swiss army knife for creating a string based on existing objects. The functions expects a format string as first argument followed by any number of arguments. The optional arguments are used to construct the result string based on format instructions embedded in the first argument. Some examples:
-------------------------------------
format('foobar')           ; 'foobar'
format('foo%s','bar')      ; 'foobar'
format('%s%S','foo','bar') ; 'fooBAR'
format('%s',list('a',2))   ; '[a, 2]'
-------------------------------------

The number of format options to be used are almost infinite footnote:[Compare http://download.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html].

===== `replace(string, subst:T, regex:T):string` =====

Create a new string by replacing substrings. Substrings to be replaced are described via regular expressions. If no substitute string is given, the empty string is used. The default regular expression is `\s*,\s*` which means, that all commas - including leading and trailing whitespace - are replaced. Arguments are stringized before used.
-------------------------------------
replace('a, b')              ; 'ab'
replace('a, b','')           ; 'ab'
replace('a, b','','\s*,\s*')  ; 'ab'
replace(true,'false','true') ; 'false' 
-------------------------------------

The behaviour of this function is undefined if called without arguments.

===== `split(string, regex:T):list` =====

A function to tokenize a string into a list of strings. Tokens are separated from each other by text matching a given regular expression. Arguments are stringized before used. If no regular expression is given, then `\*s,\s*` is used. The behaviour is undefined if no arguments are given.
-------------------------------------
split('a,b')          ; list('a','b')
split('a:b',':')      ; list('a','b')
-------------------------------------

===== `trim(string):string` =====

A convenience function to remove leading and trailing whitespace from a string (stringized object). This function can be expressed in terms of function `replace()` like
-------------------------------------
trim(s)              ; replace(s,'','^\s*|\s*$')
-------------------------------------

===== `ltrim(string):string` =====
Similar to function `trim()` above but only leading whitespace is being removed.
-------------------------------------
ltrim(s)              ; replace(s,'','^\s*')
-------------------------------------

===== `rtrim(string):string` =====
Similar to function `trim()` above but only trailing whitespace is being removed.
-------------------------------------
rtrim(s)              ; replace(s,'','\s*$')
-------------------------------------

===== `matches(text:object:regex:object):boolean` =====
A function to match a charater sequence against a regular expression. If the regular expression matches a subsequence of text, the function returns `true`. If the regular expression is invalid, the function's behaviour is undefined.
-------------------------------------
matches('aZc','aZc')    ; true
matches('aZc','Z')      ; true (!)
matches('aZc','^Z$')    ; false
matches('aZc','^\w+')   ; true
matches('aZc,'[^ab[')   ; undef.
-------------------------------------
Be aware that `matches()` works on subsequences whereas Java\'s String method `matches()` works on the entire input sequence. However, it is rather easy to let `matches()` return `true` only if the entire input sequence is covered by the regular expression: wrap the original regex using anchors:
-------------------------------------
matches(concat('^',myregex,'$'),..)
-------------------------------------

===== `glob(text:object:regex:object):boolean` =====
Similar to function `matches()` described in the previous section: the input is matched against a glob expression. A glob expression may contain wildcard characters like `*` for any number of characters, `?` for exactly one character and `[..]` for a set of known characters. Furthermore wildcard characters can be escaped using character backslash `\\`. Function `glob()` always takes the whole input sequence into account, thus

-------------------------------------
glob('','')            ; true
glob('a','a')          ; true
glob('a','\w')         ; false, '\w' means just 'w'
glob('w','\w')         ; true
glob('abc','ab')       ; false
glob('abc','ab*')      ; true
glob('abc','ab?')      ; true
glob('abc','ab[c]')    ; true
glob('ab*','ab\*')     ; true
-------------------------------------

==== List Functions ====

This sections lists EL functions operating on lists where a list is a synonym for any collection of elements. In case you are missing a function to retrieve the n-th list element, then try 
-------------------------------------
list('a','b','c')[1]           ; 'b'
-------------------------------------


===== `list(T..):list` ===== 
A function taking a arbitrary number of elements to create a list object. Returns the empty list when called without arguments.
-------------------------------------
list()                ; []
list('a',2)           ; ['a',2]
list(list('a',2))     ; [['a',2]]
-------------------------------------

===== `append(T..):list` ===== 
This function is similar to `list` by creating a list based on given arguments. However, each argument being a list is treated in a special way by appending the list elements rather the list itself.

-------------------------------------
append()                       ; list()
append('a',2)                  ; list('a',2)
append(1,list('a',2),true)     ; list(1,'a',2,true)
-------------------------------------

===== `join(string,list):string` =====

This functions creates a string by joining elements in `list` with the first argument. The first argument is stringized. If the second argument not given, the empty string is returned. Otherwise, if the second argument is not a list, then the stringized second argument is returned. The behaviour is undefined if called without arguments.
-------------------------------------
join(':')                    ; ''
join(':',5)                  ; '5'
join(':',list('a',2))        ; 'a:2'
-------------------------------------

If this function is called with more then two arguments, then all arguments but the first are collected into a list object and then processed like described above. 
-------------------------------------
join(':','a',2)              ; join(':',list('a',2))  
-------------------------------------


==== Mathematical Functions ====
[cols="45%,55%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Function | Description 
| `sin(double):double` | The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[sine] function 
| `cos(double):double` | The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[cosine] function 
| `tan(double):double` | The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[tangent] function 
| `exp(double):double` | The mathematical exponential function, `e` raised to the power of the given argument 
| `log(double):double` | The mathematical logarithm function of base `e` 
| `pow(double,double):double` | Returns the value of the first argument raised to the power of the second argument. 
| `sqrt(double):double` | Returns the correctly rounded positive square root of a double value. 
| `abs(double):double` | Returns the absolute value of a double value. 
| `min(double, double):double` | Returns the smaller of two double values. 
| `max(double, double):double` | Returns the larger of two double values. 
| `rand():double` | Returns a double value with a positive sign, greater than or equal to 0.0 and less than 1.0. 
|=================================

[[el_properties,EL Properties]]
=== Properties ===

It\'s best to introduce properties with three simple examples. It\'s about to ask a string about his uppercase variant, about it\'s length and about to create a folder with the string\'s value. 

-------------------------------------
'abc'.toupper           ; 'ABC'
'abc'.length            ; 3
'abc'['tofile'].mkdir   ; true/false
-------------------------------------

The specification of EL provides only a notation to query an object for a property. EL does not specify which properties must exist nor does it require that an object must have any properties. Each implementation is free to define properties according to the underlying implementation and usage domain. What is specified however is, how to query a property. Consider:

-------------------------------------
obj.name
obj['name.with.dot']
-------------------------------------

The first variation is the standard notation to look-up property `name` on object `obj`. Here `name` can be composed of almost any character but character `.` itself. After all, `.` is the look-up operator here. This limitation can cause problems in certain domains. Therefore, an alternative look-up operator `[]` has been defined by the specification.

Another important point to keep in mind is about looking up a property on the `null` object and what is the result of asking for a property which does not exist? The perhaps surprising answer is that both case do not cause an error or worse but are perfectly legal and well defined. The result is in both cases the `null` object. Consider:

-------------------------------------
null.someproperty        ; null
obj.notexisting          ; null
-------------------------------------

Now it\'s about time to tell, which properties are available.

[[el_natural_properties,Natural Properties]]
==== Natural Properties ====

A _natural_ property `x` exits if the underlying Java object has a public getter method with the same name as `x` and where the names are compared case-insensitively. Assume that we have on object `f` of type `java.io.File` footnote:[see http://download.oracle.com/javase/1.5.0/docs/api/java/io/File.html]. The following listing shows two natural properties on object `f` and how `f` will be used by the underlying EL implementation:

-------------------------------------
f.name              ; f.getName()
f['parentfile']     ; f.getParentFile()
-------------------------------------


==== Primitive Type Properties ====

Primitive data types (integer, float, boolean and null) have no properties.

==== List and Array Properties ====

Besides _natural_ properties can lists and arrays be queried with an _index_ returning the element at that position or `null` if the index is out of range. Consider:

-------------------------------------
list('a','b')[1]    ; 'b'
list('a','b')[-1]   ; null
list('a','b')[2]    ; null
-------------------------------------

[[el_string_properties,String Properties]]
==== String Properties ====

Table above lists properties that can be queried besides natural properties:

[cols="2*15%,70%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Property | Type | Description 
| length   | int  | number of characters in this string 
| size     | int  | same as property `length` 
| tolower  | string | return this string in lowercase characters only 
| toupper  | string | return this string in uppercase characters only 
| trim     | string | remove leading and trailing whitespace characters 
| tofile   | file  | create a file based on this string; the so created will be relative to the current build file\'s base folder if the string\'s value does not denote a absolute path. Furthermore, the empty string will create a file object denoting the project\'s base folder (i.e. the folder containing the build script currently executed). Notice that `.` and `..` denote absolute paths, not relative ones. 
|=================================

[[el_file_properties,File Properties]]
==== File Properties ====

Files and folders is Ant\'s bread and butter. A couple of properties are defined on file objects to simplify scripting (see below). Consider:

[cols="30%,10%,60%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Property | Type | Description 
| `absolutefile` | file | The absolute form of this abstract pathname
| `absolutepath` | string | The absolute form of this abstract pathname
| `canonicalfile` | file | The canonical form of this abstract pathname
| `canonicalpath` | string | The canonical form of this abstract pathname
| `delete` | boolean | deletes the file or folder (true); false otherwise 
| `exists` | boolean | check whether file or folder exists 
| `isdir`  | boolean | check whether a folder (directory) 
| `isfile` | boolean | check whether a file 
| `ishidden` | boolean | check whether a hidden file or folder 
| `isread` | boolean | check whether a file or folder is readable 
| `iswrite` | boolean | check whether a file or folder is writable 
| `length` | integer  | same as `size` 
| `list`   | list | array of files in folder  
| `mkdir`  | boolean | creates the folder (and intermediate) folders (true); false otherwise 
| `mtime`  | Date | last modification date  
| `name`   | string | The basename 
| `parent` | file | parent of file or folder as file object 
| `path`   | string |abstract pathname into a pathname string.
| `size`   | integer  | number of bytes in a (existing) file; 0 otherwise
| `toabs`| file | file or folder as absolute file object 
| `tostr` | string | file name as string object 
| `touri`    | URI  | file as URI object 
| `tourl`    | URL  | file as URL object 
|=================================

[[el_matcher_properties,Matcher Properties]]
==== Matcher Properties ====

A _matcher object_ is created by task <<task_switch>> if a regular expression matches a input value. Such a matcher object contains details of the match like the start and end position, the pattern used to match and it allows to explore details of capturing groups (also known as _marked_ subexpression).

[cols="2*15%,70%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Property | Type     | Description 
| `start`   | int     | The position within the input where the match starts. 
| `s`       | int     | Same as `start` 
| `end`     | int     | The position within the input where the match ends (the character at `end` is the last matching character)  
| `e`       | int     | Same as `end`   
| `groups`  | int     | The number of capturing groups in the (regular) expression. 
| `size`    | int     | Same as `groups` 
| `length`  | int     | Same as `groups` 
| `n`       | int     | Same as `groups` 
| `pattern` | string  | The regular expression that was used for this match. Notice that glob expressions are translated into regular expressions. 
| `p`       | string  | Same as `pattern` 
| _i_       | matcher | The matcher object for _i_-th capturing group. See task <<task_switch>> for examples. 
|=================================

The following example shows how to utilize matcher properties:

--------------------------------------
<c:switch value="foobar">
   <re expr="^(.*)(b.*)$" var="m">
     <echo>
       #{ m          }   ; 'foobar'
       #{ m[0]       }   ; 'foobar'
       #{ m.start    }   ; 0
       #{ m.end      }   ; 5
       #{ m.groups   }   ; 2
       #{ m.pattern  }   ; '^(.*)(b.*)$'
       #{ m[1]       }   ; 'foo'
       #{ m[2]       }   ; 'bar'
       #{ m[1].end   }   ; 2
       #{ m[2].start }   ; 3
     <echo>
   </re>
</c:switch>
--------------------------------------

[[el_project_properties,Project Properties]]
==== Project Properties ====

This sections lists additional properties that can be queried on an object of type `project`, i.e. of an Ant project. For natural properties, checkout the Javadoc of class org.apache.tools.ant.Project footnote:[for example http://javadoc.haefelinger.it/org.apache.ant/1.7.1/org/apache/tools/ant/Project.html].

[cols="25%,15%,60%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Property  | Type | Description 
| `basedir` | file     | The project\'s base directory as file object. 
| `targets` | list     | A list of all target names
| `tasks`   | list     | A list of all taskdef and macrodef names
| `taskdefs`| list     | A list of all taskdef names 
| `macrodefs` | list   | A list of all macrodef names
|=================================


[[el_type_conversion,Type Conversion]]
=== Type Conversion ===

Every EL expression is evaluated in the context of an _expected_ type. When a evaluated expression does not match it\'s expected type, implicit type conversion takes place. The following sections list the rules which apply.

==== Type boolean ====

The following table describes the conversion of object `obj` into an boolean value:

[cols="30%,70%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Type        | Result 
| null        | `false`
| string      | `false` if obj is `""`, otherwise `Boolean.valueof(obj)`
| boolean     | obj
| file        | `true` if the file described by obj exists
| _other_     | false
|=================================

