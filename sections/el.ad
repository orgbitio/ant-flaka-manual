
<<part1>> <<el>> The http://en.wikipedia.org/wiki/Unified_Expression_Language[Java Unified Expression Language] (EL) footnote::[The gory details of _EL_ are laid out in the http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf[the official JSR 245 specification] and are not repeated here.] offers a simple way of accessing data objects. While the expression language is part of the JSP specification, it does in no way depend on the JSP itself. To the contrary, the language can be made available in a variety of contexts. One such context is Ant:

-------------------------------------
<c:echo>
  Modified #{ format('%tA, %1$tD', file(project).mtime) }
</c:echo>
-------------------------------------

The EL expression - here a function call with two arguments - utilizes two standard functions provided by Flaka, namely function `format()` for creating a string and function `file()` for creating a file object. Function `format()` takes an arbitrary name of arguments. The first argument - the format string - contains embedded formatting expressions like `%1$tA`. This particular format expression interprets second argument a date object and evaluates to the particular day in the week. The argument of `file()` -- `project` -- is an implict object, namely an object representing the current Ant project. The evaluation of `file(project)` is the project\'s base directory as file object. Such a file object has various properties. One property is the file\'s last modification time which can be queried using property `mtime`. The whole expression is embedded in a textual context footnote::[The reason Flaka\'s echo task is used here is due to the fact, that EL is by default _not_ globally enabled. To enable it globally, use Flaka\'s task `<c:install-property-handler/>`] and enclosed by `#{` and `}` respectively. This indicates that within this textual context, everything wrapped by  `#{..}` must be evaluated as EL expression while everything outside is left as is. When executed, this snippet produces something like
 
-------------------------------------
[c:echo] Modified Friday, 10/29/10
-------------------------------------

Here are some further examples, demonstrating the power EL offers:

-------------------------------------
7 * (5.0+x) >= 0             ; (1)
a and not (b || false)       ; (2)
empty L ? null : L[0]        ; (3)
list('a','b')                ; (4)
split('a,b',',')             ; (5)
project.name                 ; (6)
size(file('.').list)         ; (7)
-------------------------------------


The first expression (1) shows a algebraic equation. Notice the usage of `5.0` being of type float, `7` being an integral type and furthermore `x` as untyped variable. A boolean expression is shown in the second example. Notice the usage of operator `and`, operator `not` and of operator `||`. The expression could also have been written like `a && !(b or false)`. Example (3) shows operator `empty` and the conditional operator `c ? t : e`. The expression could be read like: check whether a (list) object is empty. If empty return object `null`m, otherwise return the list\'s first item. The fourth and fifth expression shows two list generating functions - `list()` just collects all arguments into a list while `split()` breaks a string apart based on a regular expression. The project\'s name is queried in example (6) while example (7), calculates the number of files and folders in the current working directory.

[[el_enabling_el,Deploying EL]]
=== Deploying EL ===

Assume that you already know how to formulate a proper EL expression, i.e. you are aware of the EL syntax and you are aware of implicit objects and EL functions. Still, how can you use them in your Ant build file? Thus the probably most important question to be answered is 

* _Where can I use EL expressions?_

This chapter answers this question and other, more advanced questions. 

==== Globally Enabling EL References ====
Ant does by default not understand EL expressions cause EL is not one of Ant\'s standard features. What Ant understands by default are property references `${..}` in textuel contexts like attribute values and textuel tasks, like the well known `echo` task. A standard Ant feature is however, that an extension is able to let Ant understand in addition other reference entities. This is exactly what Flaka\'s `install-property-handler` task does, it makes Ant EL aware. Consider:

---------------------------
<echo message="before: #{ 3 * 4 }" />    ; before: #{ 3 * 4}
<c:install-property-handler />
<echo message="after:  #{ 3 * 4 }" />    ; after:  12
---------------------------

In other words: Having used task `install-property-handler` once, one can make use of EL references `#{..}` everywhere where Ant property references `${..}` can be used. For example when setting up a property:

---------------------------
<property name="twelve" value="#{ 3 * 4 }" />
---------------------------

As mentioned before, EL references can be used in any context one can apply Ant property references. Ant properties are strings, thus Ant properties are used in string contexts and consequently the same applies for EL references. When a EL reference is seen, then the expression is evaluated according to EL rules into an object of some type. Then, in a second step, that object value is coerced footnote::[implicitly type converted] into a string.

==== Typed Attributes ====

Flaka on the other hand is EL aware by default which means, that EL can be used in all tasks provided by Flaka without having used  task `install-property-handler`. Take task `when` as an example:

-------------------------------------
<c:when test=" file(path).isdir ">..</c:when>
-------------------------------------

Here, attribute `test` is used to express a condition. Evaluating this condition will either execute tasks embedded in `when` or not. The standard Ant way would be to evaluate this condition into a string and then parse the string whether it matches `true`, `false`, `yes`, `no` and so on. Not so in this Flaka task. Task `when` expects for attribute `test` a pure EL expression. This expression is then evaluated in the context of a boolean data type. In other words: attribute `test` of task `when` is a _typed_ attribute. Be aware that most - while not all - of Flaka\'s attributes are typed!

Notice however, that all attributes are handled by the currently installed property handler. Thus even for attribute `test` the normal attribute rules apply. Consider this kind of meta-programming

-------------------------------------
<c:when test=" file('${mypath}').#{ empty fprop ? 'isdir' : fprop} ">..</c:when>
-------------------------------------

which combines a Ant property and a EL reference to express a EL expression.

==== Nested EL References? ====

Nested references are _not_ supported. The following example, which tries to do some sort of meta-programming on implicit object `project`, is therefore illegal

-------------------------------------
<c:echo>
     #{ project.#{ property } }   ; illegal
</c:echo>
-------------------------------------

==== Evaluation Order ====

All Ant property references `${..}` are resolved before any EL reference is resolved:

-------------------------------------
<c:echo>
     #{ project.${ property } }   ; good
     ${ project.#{ 'basedir' }}   ; no
</c:echo>
-------------------------------------

==== The Great Escape ====

Assume that EL references have been globally enabled and your task is to echo a text sequence like `#{ 3 * 4}`. How can you disable EL references from being evaluated? The following example snippet provides the answer:
-------------------------------------
<c:echo>
     #{ 3 * 4 }        ; 12
    \#{ 3 * 4 }        ; #{ 3 * 4 }
  #{'{'}3 * 4 }        ; #{ 3 * 4 }
</c:echo>
-------------------------------------

[[el_data_types,EL Data Types]]
=== Data Types ===

Elements of the following types can be used when writing EL expressions:

* _null_ to represent the absence of any data  
* _integer_ for integer values
* _float_ for any floating point values
* _boolean_ to express boolean logic
* _string_ to represent char sequences
* _object_ for all other data values

The question is how to get a element of those types and which elements exist? EL defines literals which can be used to define elements of all but type `object`. 



 
==== Null Literals ====

The `null` type contains only one data element also called `null`. From a semantic point of view it is used to represent the absence of any data. Within EL, `null` has an interesting characteristic: it can be asked whether it has a certain property and the answer will always be `null` again.

-------------------------------------
null['any property']   ; null
-------------------------------------

This rather different from other languages where asking `null` for a property is asking for trouble, i.e. null pointer exception and the like. Notice also the following differences between operator `empty` and function `null()` when working with value `null`:
-------------------------------------
empty null    ; true
empty list()  ; true
empty ''      ; true
null(null)    ; true
null(list())  ; false
null('')      ; false
-------------------------------------

==== String Literals ====

A string literal starts and ends with the same quotation character. Quotation characters are either the single quote `'` or the double quote `"` character. If the quotation character is needed within the literal, then the escape character `\\` must be used. The escape character must also be used if the escape character itself is to be expressed in the literal. The escape character can\'t be used to escape other characters than the quotation character and the escape character.
-------------------------------------
"abc"        ; abc
'abc'        ; abc
'abc"        ; illegal
"a'c"        ; a'c
'a"c'        ; a"c
'a\'c'       ; a'c
'a\"c'       ; a\"c
"a\"c"       ; a"c
'a\bc'       ; a\bc
'a\\bc'      ; a\bc
'ab\'        ; illegal
'ab\\'       ; ab\
-------------------------------------

==== Object  Literals ====

Well, EL has no notation for _object_ literals like literals for type integer and boolean. So, how to get an object in the first place? There are two possibilities:

* use an implicit object; and
* use a function 

Once you have an object, you can in addition
* use an object\'s property 
to retrieve another object. When does a property exist and how to retrieve it? This and other questions are answered in section <<el_properties>> while section <<el_implicit_objects>> lists available implicit objects and section <<el_functions>> is about functions to be used.

Notice that EL does also not provide a notation for arrays or list objects nor is there a `list` data type. Nevertheless, Flaka provides a `list()` function to create a collection of arbitrary objects. There is also task `for` able to iterate over collection types and there is function `size()` which returns the number of items in a collection. How does this work? EL uses a concept called _duck typing_ where a object\'s type is not given by a class but rather by it\'s properties: _I call every object that walks, swims and quacks like a duck, a duck_. Thus properties are looked up during runtime and a object provides all required properties, the object is applied.


[[el_operators]]
=== Operators ===

This are the most important operators defined in EL:

* `empty` checks whether a variable is empty or not and returns either `true` or `false`. It is important to understand that `null` is considered empty.
*  condition operator `c ? a : b` evaluates `c` in a boolean context and returns the evaluation of expression `a` if `c` evaluates to `true`; otherwise `eval(b)` will be the result of this operator.
* `.` and  `[]` are property operators described in <<el_properties,section _Properties_>> below.
* logical operators `not`, `and` and `or`
* relational operators `==`, '!=`, `<`, `>`, `<=` and `>=` (resp. `eq`, `ne`, `lt`, `gt`, `le` and `ge`).
* usual arithmetic operators like `+`, `-`, `*`, `/`, `mod` and `div` etc.


[[el_implicit_objects,EL Implicit Object]]
=== Implicit Objects ===

Flaka provides a couple of implicit objects that can be utilized when writing <<el>> expressions:

[cols="1*25%,75%"]
|==================================
| Implicit Object | Description 
| project         | Ant's underlying project object. It can be used to query the default target, base folder and other things. If you want to query properties, references, targets, tasks, taskdefs, macrodefs, filters etc., use appropriate implicit object instead. 
| property | Use this object to query project properties. 
| var | A object containing all project references.  
| reference | A synonym for `var` 
| target| Contains all `target`s
| taskdef| Contains all `taskdef`s 
| macrodefs| Contains all `macrodef`s
| tasks| Either taskdef or macrodef. Macros are specialized task and thus same the same namespace. 
| filter| A object containing all filters defined in this project. 
| e | The mathematical number http://en.wikipedia.org/wiki/E_(mathematical_constant)[e], also known as http://en.wikipedia.org/wiki/Euler[Euler]'s number.
| pi | The number http://en.wikipedia.org/wiki/PI[PI] 
|==================================

As an example how to make use of this implicit objects assume that there is a Ant build script like

-------------------------------------
<project xmlns:c="antlib:it.haefelinger.flaka" name="helloworld">
  <property name="foo" value="bar" />
  <c:let>x = list('a','b')</c:let>
  ..
</project>
-------------------------------------

Then you could use implicit object `project` to query the project's name, the value of property `foo` and the object value of variable `x` like
-------------------------------------
project.name            ;; `helloworld'
property.foo            ;; `bar'
var.x                   ;; [a, b]
-------------------------------------

[[el_functions,EL Functions]]
=== Functions ===

==== Generic Functions ====

===== `typeof(object):string` =====

A function to determine the object\'s type:
-------------------------------------
typeof(null)            ;; 'null'
typeof('')              ;; 'string'
typeof(3)               ;; 'int'
typeof(pi)              ;; 'float'
typeof(true)            ;; 'bool'
typeof(list())          ;; 'list'
typeof(file('.'))       ;; 'file'
typeof(other)           ;; 'object'
-------------------------------------

===== `size(object):int` =====

The size of the object is given by the number of entities it contains. This is 0 (zero) for all primitive typeslike `int`, `null`, `float`, `bool`. Otherwise the object\'s size is determined via a `size` or `length` property.
-------------------------------------
size(null)            ;; 0
size(3)               ;; 0
size(pi)              ;; 0
size(true)            ;; 0
size(file(..))        ;; 0
size(object)          ;; object.size or object.length or 0
-------------------------------------
 
===== `null(object):bool` =====

Evaluates to `true` if object is the `null` entity and `false` otherwise. Compare this function with operator `empty` which returns `true` if eiher the object in question does not exist or if literally empty, for example the empty list or the empty string.

-------------------------------------
null(null)            ;; true
null(other)           ;; false
empty(null)           ;; true
empty(list())         ;; true
empty(list('a'))      ;; false
empty('')             ;; true
-------------------------------------

==== File and Folder Functions ====

===== `file(object):File` =====
Creates and returns a file object out of `object`. If `object` is already a file, the object is simply returned. Otherwise if the object is not of type Project, the object is stringized and that string is taken as the file\'s path name. 

If the argument is an Ant project, then the project's base directory is returned as file object. Thus the following example iterates over all files and folders in the project's base directory:
-------------------------------------
<c:for var="f" in=" file(project).list ">
 <c:echo>#{f}</c:echo>
</c:for>
-------------------------------------
This function can be used to return the current working directory - which might be very different from the project's base directory. To do so, simply try `file('.')`.

If no argument is given, then object `null` is returned.


==== String Functions ====

===== `concat(object..):string` =====
Creates a string by concatenating all _stringized_ objects. If no object is provided, the empty string is returned. Thus to create the string `foobar`, try
-------------------------------------
concat('foo','bar')  ; `foobar'
-------------------------------------

===== `format(string,object..):string` =====
This function is a swiss army knife for creating a string based on existing objects. The functions expects a format string as first argument followed by any number of arguments. The optional arguments are used to construct the result string based on format instructions embedded in the first argument. Some examples:
-------------------------------------
format('foobar')           ; `foobar'
format('foo%s','bar')      ; `foobar'
format('%s%S','foo','bar'  ; `fooBAR'
format('%s',list('a',2))   ; `[a, 2]'
-------------------------------------

The number of format options to be used are almost infinite. As a reference, checkout http://download.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html[corresponding Javadoc documentation of class Formatter].

===== `replace(string, subst, regex):string` =====

Create a new string by replacing substrings. Substrings to be replaced are described via regular expressions. If no substitute string is given, the empty string is used. The default regular expression is `\s*,\s*` which means, that all commas - including leading and trailing whitespace - are replaced. Arguments are stringized before used.
-------------------------------------
replace('a, b')              ; 'ab'
replace('a, b','')           ; 'ab'
replace('a, b','','\s*,\s*)  ; 'ab'
replace(true,'false','true') ; 'false' 
-------------------------------------

The behaviour of this function is undefined if called without arguments.

===== `split(string, regex):list` =====

A function to tokenize a string into a list of strings. Tokens are seperated from each other by text matching a given regular expression. Arguments are stringized before used. If no regular expression is given, then `\*s,\s*` is used. The behaviour is undefined if no arguments are given.
-------------------------------------
split('a,b')          ; list('a','b')
split('a:b',':')      ; list('a','b')
-------------------------------------

===== `trim(string):string` =====

A convenience function to remove leading and trailing whitespice from a string (stringized object). This function can be expressed in terms of function `replace()` like
-------------------------------------
trim(s)              ; replace(s,'','^\s*|\s*$')
-------------------------------------

===== `ltrim(string):string` =====
Similar to function `trim()` above but only leading whitespace is being removed.
-------------------------------------
ltrim(s)              ; replace(s,'','^\s*')
-------------------------------------

===== `rtrim(string):string` =====
Similar to function `trim()` above but only trailing whitespace is being removed.
-------------------------------------
rtrim(s)              ; replace(s,'','\s*$')
-------------------------------------

==== List Functions ====

This sections lists EL functions operating on lists where a list is a synonym for any collection of elements. In case you are missing a function to retrieve the n-th list element, then try 
-------------------------------------
list('a','b','c')[1]           ; 'b'
-------------------------------------


===== `list(object..):list` ===== 
A function taking a arbitrary number of elements to create a list object. Returns the empty list when called without arguments.
-------------------------------------
list()                ; []
list('a',2)           ; ['a',2]
list(list('a',2))     ; [['a',2]]
-------------------------------------

===== `append(object..):list` ===== 
This function is similar to `list` by creating a list based on given arguments. However, each argument being a list is treated in a special way by appending the list elements rather the list itself.

-------------------------------------
append()                       ; list()
append('a',2)                  ; list('a',2)
append(1,list('a',2),true)     ; list(1,'a',2,true)
-------------------------------------

===== `join(string,list):string` =====

This functions creates a string by joining elements in `list` with the first argument. The first argument is stringized. If the second argument not given, the empty string is returned. Otherwise, if the second argument is not a list, then the stringized second argument is returned. The behaviour is undefined if called without arguments.
-------------------------------------
join(':')                    ; `'
join(':',5)                  ; `5'
join(':',list('a',2))        ; `a:2'
-------------------------------------

If this function is called with more then two arguments, then all arguments but the first are collected into a list object and then processed like described above. 
-------------------------------------
join(':','a',2)              ; join(':',list('a',2))  
-------------------------------------


==== Mathematical Functions ====
[cols="35%,65%"]
|=================================
| `sin(double):double` | The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[sine] function 
| `cos(double):double` | The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[cosine] function 
| `tan(double):double` | The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[tangent] function 
| `exp(double):double` | The mathematical exponential function, `e` raised to the power of the given argument 
| `log(double):double` | The mathematical logarithm function of base `e` 
| `pow(double,double):double` | Returns the value of the first argument raised to the power of the second argument. 
| `sqrt(double):double` | Returns the correctly rounded positive square root of a double value. 
| `abs(double):double` | Returns the absolute value of a double value. 
| `min(double, double):double` | Returns the smaller of two double values. 
| `max(double, double):double` | Returns the larget of two double values. 
| `rand():double` | Returns a double value with a positive sign, greater than or equal to 0.0 and less than 1.0. 
|=================================

[[el_properties,EL Properties]]
=== Properties ===

Every data object in _EL_ may have properties associated. Which properties are available has not been standardized in the http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf[specification]. In fact, this depends heavily on the underlying implementation and usage domain. What _EL_ specifies however, is how to query a property:

-------------------------------------

a.b.c

-------------------------------------

This expression can be translated into pseudo code as

-------------------------------------

 (property 'c' (property 'b' (eval a)))

-------------------------------------

which means that first variable `a` is evaluted, then property `b` is looked up on the evaluation result (giving a new evaluation result) and finally `c` is looked up giving the final result. 

Perhaps the most important point to notice is looking up a property on `null` is not an error but perfectly legal. No exception gets raised and no warning message generated. In fact, the result of such a operation is just `null` again.

From a practial point a question might be asked how to query a property which happens to contain the dot (`.`) character. In `a.b.c` example shown above, how would we lookup property `b.c` on `a`? Operator `[]` comes to rescue:

-------------------------------------

 a['b']        => a.b
 (a['b'])['c'] => a.b.c
 a['b']['c']   => a.b.c
 a[b]          => can't be expressed using '.'
 a[b.c]        => neither this ..
 a['b.c']      => query property 'b.c' on a 

-------------------------------------


So far, properties don't seem of any good use. The picture changes perhaps with this example:

-------------------------------------

 'abc'.toupper           => 'ABC'
 'abc'.length*4          => 12
 'abc'['tofile'].mkdir   => true/false

-------------------------------------

The last example demonstrates that there might also be http://en.wikipedia.org/wiki/Side_effect_(computer_science)[side effects] querying a property. In the example above, which is specific for Flaka, a directory `abc` gets created and the whole expression evaluates to `true` if the directory could get created and `false` otherwise.

==== Natural Properties ====
In general, properties are mapped as _attribute_ on the underlying data object. In Java, every _getX_ method taking no arguments identifies property _x_. As an example, assume that we have 

-------------------------------------
public class Foo {
 public .. getBar() { .. }
}
-------------------------------------

then an data object of type _Foo_ will have property _bar_ and thus the following expression `x.bar` would eventually call `Foo.getBar()` assuming that `x` evaluates to an object of type `Foo`. Such properties are the *natural* properties of a type.

==== Primitve Type Properties ====

Primite data types (int, double, bool, null) have no properties.

==== List and Array Properties ====

Besides their _natural_ properties (see discussion above) are _index_ properties available:

-------------------------------------
list('a','b')[1]  => 'b'
-------------------------------------

Negative indexes are currently not supported. If an index is specfies an not existing element, `null` is returned.

[[el_string_properties,String Properties]]
==== String Properties ====

Besides _natural_ properties (see discussion above) are the following properties supported:

[cols="2*15%,70%"]
|=================================
| Property | Type | Description 
| length   | int  | number of characters in this string 
| size     | int  | same as property `length` 
| tolower  | string | return this string in lowercase characters only 
| toupper  | string | return this string in uppercase characters only 
| trim     | string | remove leading and trailing whitespace characters 
| tofile   | file  | create a file based on this string; the so created will be relative to the current build file's base folder if the string's value does not denote a absolute path. Furthermore, the empty string will create a file object denoting the project's base folder (i.e. the folder containing the build script currently executed). Notice that `.` and `..` denote absolute paths, not relative ones. 
|=================================

[[el_file_properties,File Properties]]
==== File Properties ====

Files and folders is Ant's bread and butter. A couple of properties are defined on file objects to simplify scripting (see below). Most important is however how to _get_ a file object in the first place. This is most easily done by using string property `tofile`:

-------------------------------------

  'myfolder'.tofile

-------------------------------------

In this example of an EL expression, string `myfolder` is converted in a File object using property `tofile`. Then, having a file object at your finger tips, the following properties are available:

[cols="2*15%,70%"]
|=================================
| Property | Type | Description 
| `absoluteFile` | File | The absolute form of this abstract pathname
| `absolutePath` | String | The absolute form of this abstract pathname
| `canonicalFile` | File | The canonical form of this abstract pathname
| `canonicalPath` | String | The canonical form of this abstract pathname
| `delete` | bool | deletes the file or folder (true); false otherwise 
| `exists` | bool | check whether file or folder exists 
| `isdir`  | bool | check whether a folder (directory) 
| `isfile` | bool | check whether a file 
| `ishidden` | bool | check whether a hidden file or folder 
| `isread` | bool | check whether a file or folder is readable 
| `iswrite` | bool | check whether a file or folder is writable 
| `length` | int  | same as `size` 
| `list`   | File | array of files in folder  
| `mkdir`  | bool | creates the folder (and intermediate) folders (true); false otherwise 
| `mtime`  | Date | last modification date  
| `name`   | String | The basename 
| `parent` | File | parent of file or folder as file object 
| `path`   | String |abstract pathname into a pathname string.
| `size`   | int  | number of bytes in a (existing) file; 0 otherwise
| `toabs`| File | file or folder as absolute file object 
| `tostr` | String | file name as string object 
| `touri`    | URI  | file as URI object 
| `tourl`    | URL  | file as URL object 
|=================================

[[el_matcher_properties,Matcher Properties]]
==== Matcher Properties ====

A _matcher object_ is created by task <<task_switch>> if a regular expression matches a input value. Such a matcher object contains details of the match like the start and end position, the pattern used to match and it allows to explore details of capturing groups (also known as _marked subexpression).

[cols="2*15%,70%"]
|=================================
| Property | Type     | Description 
| `start`   | int     | The position within the input where the match starts. 
| `s`       | int     | Same as `start` 
| `end`     | int     | The position within the input where the match ends (the character at `end` is the last matching character)  
| `e`       | int     | Same as `end`   
| `groups`  | int     | The number of capturing groups in the (regular) expression. 
| `size`    | int     | Same as `groups` 
| `length`  | int     | Same as `groups` 
| `n`       | int     | Same as `groups` 
| `pattern` | string  | The regular expression that was used for this match. Notice that glob expressions are translated into regular expressions. 
| `p`       | string  | Same as `pattern` 
| _i_       | matcher | The matcher object for _i_'th capturing group. See task <<task_switch>> for examples. 
|=================================

[[el_type_conversion,Type Conversion]]
=== Type Conversion ===

Every EL expression is evaluated in the context of an _expected_ type. When a evaluated expression does not match it\'s expected type, implicit type conversion takes place. The following sections list the rules which apply.

==== Type boolean ====

The following table describes the conversion of object `obj` into an boolean value:

[cols="30%,70%"]
|=================================
| actual type | result 
| null        | `false`
| string      | `false` if obj is `""`, otherwise `Boolean.valueof(obj)`
| boolean     | obj
| file        | `true` if the file described by obj exists
| object      | false
|=================================

