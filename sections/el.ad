
The _Unified Expression Language_ footnote:[http://en.wikipedia.org/wiki/Unified_Expression_Language], further in this document abbreviated as _EL_, is a special purpose programming language typically used for embedding expressions in web applications. While EL is part of the JSP Specification, it does not depend on JSP and can therefore be used in a varity of other contexts. One such context is Ant. Conside the following example:

-------------------------------------
<echo>
  Modified #{ format('%tA, %1$tD', file(project).mtime) }
<echo>
-------------------------------------

The EL expression - here a function call with two arguments - utilizes two standard functions provided by Flaka, namely function `format()` for creating a string and function `file()` for creating a file object. Function `format()` accepts an arbitrary number of arguments. Two arguments are provided in this example. A string argument as the first argument while the second argument is the object returned by querying property `mtime` on the object returned by calling standard function `file()` with one argument, namely `project`. `project` is an implict object representing the current Ant project. The evaluation of `file(project)` is the project\'s base directory as file object. Such a file object has various properties. One property is the file\'s last modification time available as property `mtime`. The whole EL expression is embedded in a textual context, here the standard Ant echo task is used for demonstration footnote:[To make this example work, one need to globally enable EL for all string contexts. By default, EL is _not_ globally enabled. To enable it globally, use Flaka\'s task `<c:install-property-handler/>`] and enclosed by `#{` and `}` respectively. This indicates that within this textual context, everything wrapped by `#{..}` must be evaluated as EL expression while everything outside is left as is. When executed, this snippet produces something like
 
-------------------------------------
[echo] Modified Friday, 10/29/10
-------------------------------------

Here are some further examples, demonstrating the power EL offers:

-------------------------------------
7 * (5.0+x) >= 0             ; (1)
a and not (b || false)       ; (2)
empty L ? null : L[0]        ; (3)
list('a','b')                ; (4)
split('a,b',',')             ; (5)
project.name                 ; (6)
size(file('.').list)         ; (7)
-------------------------------------

The first expression (1) shows a algebraic equation. Notice the usage of `5.0` being of type float, `7` being an integral type and furthermore `x` as variable. A boolean expression is shown in the second example using operators `and`, `not` and operator `||`. The same expression could also have been written like `a && !(b or false)`. Example (3) shows operator `empty` and conditional operator `?:`. The expression could be read like: check whether a (list) object is empty. If empty, return `null`, otherwise return the list\'s first item. The fourth and fifth expression shows two list generating functions - `list()` just collects all arguments into a list while `split()` breaks a string apart based on a regular expression. The project\'s name is queried in example (6) while example (7), calculates the number of files and folders in the current working directory.

[[el_enabling_el,Embedding EL]]
=== Embedding ===

At this point of reading the probably most important question to be answered is, 

* _Where and under what conditions can I embed EL in my build file?_

If you globally enabled EL in your build file footnote:[see task <<task_install_property_handler,`install-property-handler`>> for how to do this] then the answer is simply, that you can embed an EL expression everwhere where you can use an Ant property reference `${..}`. An EL expression must then be written as EL reference, i.e. must be enclosed by `#{` and `}`. Consider:
---------------------------
<property name="twelve" value="#{ 3 * 4 }" />
<echo message="${twelve} = #{ 3 * 4}">   ; 12 = 12
---------------------------

As mentioned before, EL references can be used in any context one can apply Ant property references. Ant properties are strings, thus Ant properties are used in string contexts and consequently the same applies for EL references. When an EL reference is seen, then the expression is evaluated according to EL rules into an object of some type _T_. Then, in a second step, that object value is coerced footnote::[implicitly type converted] into a string.

Flaka on the other hand is EL aware. This means that regardless of whether EL has been globally enabled or not, do all tasks provided by Flaka understand EL references `#{..}`.

In addition, attributes of tasks provided by Flaka can be _typed_. This means that the argument of such an attribute is treated as EL expression. Evaluating that expression is expected to result in a value of an _expected type_. Consider attribute `test` of Flaka\'s <<task_when,`when`>> task:

-------------------------------------
<c:when test=" file(path).isdir ">
  <!-- do something whith that dir folder .. -->
</c:when>
-------------------------------------

The underlying semantic of attribute `test` is that of a condition. If the condition evalutes to _true_, then all tasks embedded in _when_ are carried out and otherwise ignored. The expected type of that attribute is obviously `boolean`. The EL expression `file(path).isdir` is evaluated into an object and then implicitly converted into a boolean value.

Notice that Ant and EL references can be used in typed attributes. After all, a typed attribute is a regular attribute as far as Ant is concerned. It is just Flaka who is evaluating the expression as EL. Thus consider this kind of meta-programming , that all attributes are handled by the currently installed property handler. Thus even for attribute `test` the normal attribute rules apply. Consider this kind of meta-programming where by default an object is queried for property `isdir` subject to whether variable `prop` is empty or not. If not empty, then the value is queried for property `prop`:

-------------------------------------
<c:when test=" obj.#{ empty prop ? 'isdir' : prop} ">
 ..
</c:when>
-------------------------------------

The following sections will handle some advanced issues regarding EL references and especially their relation with Ant property references.

==== Nested EL References? ====

Nested references are _not_ supported. The following example, which tries to do some sort of meta-programming on implicit object `project`, is therefore illegal

-------------------------------------
<c:echo>
     #{ project.#{ property } }   ; illegal
</c:echo>
-------------------------------------

==== Evaluation Order ====

All Ant property references `${..}` are resolved before any EL reference is resolved:

-------------------------------------
<c:echo>
     #{ project.${ property } }   ; good
     ${ project.#{ 'basedir' }}   ; no
</c:echo>
-------------------------------------

==== The Great Escape ====

Assume that EL references have been globally enabled and your task is to echo a text sequence like `#{ 3 * 4}`. How can you disable EL references from being evaluated? The following example snippet provides the answer:
-------------------------------------
<c:echo>
     #{ 3 * 4 }        ; 12
    \#{ 3 * 4 }        ; #{ 3 * 4 }
  #{'{'}3 * 4 }        ; #{ 3 * 4 }
</c:echo>
-------------------------------------

[[el_data_types,EL Data Types]]
=== Data Types ===

The following types can be used when writing EL expressions:

* _null_ to represent the absence of any data  
* _integer_ for integer values
* _float_ for any floating point values
* _boolean_ to express boolean logic
* _string_ to represent char sequences
* _list_ for iterable types
* _map_ for dictionary like types
* _file_ representing file objects
* _project_ representing Ant project instances
* _object_ for all other data values

The question is how to get a element of those? EL defines literals denoting elements of type `null`, `integer`, `float`, `boolean`, and `string`. Furthermore there are implicit objects and functions, see below.


==== Null Literals ====

The `null` type contains only one data element also called `null`. From a semantic point of view it is used to represent the absence of any data. Within EL, `null` has an interesting characteristic: it can be asked whether it has a certain property and the answer will always be `null` again. Consider:

-------------------------------------
null['any property']   ; null
null.mtime             ; null
-------------------------------------

This rather different from other languages where asking `null` for a property is asking for trouble, i.e. null pointer exception and the like. Notice also the following differences between operator `empty` and function `nullp()` when working with value `null`:

-------------------------------------
empty null     ; true
empty list()   ; true
empty ''       ; true
nullp(null)    ; true
nullp(list())  ; false
nullp('')      ; false
-------------------------------------

==== String Literals ====

A string literal starts and ends with the same quotation character. Quotation characters are either the single quote `'` or the double quote `"` character. If the quotation character is needed within the literal, then the escape character `\\` must be used. The escape character must also be used if the escape character itself is to be expressed in the literal. The escape character can\'t be used to escape other characters than the quotation character and the escape character.
-------------------------------------
"abc"        ; abc
'abc'        ; abc
'abc"        ; illegal
"a'c"        ; a'c
'a"c'        ; a"c
'a\'c'       ; a'c
'a\"c'       ; a\"c
"a\"c"       ; a"c
'a\bc'       ; a\bc
'a\\bc'      ; a\bc
'ab\'        ; illegal
'ab\\'       ; ab\
-------------------------------------

==== Object  Literals ====

Well, EL has no notation for _object_ literals like literals for type integer and boolean. So, how to get an object in the first place? There are two possibilities:

* use an implicit object; and
* use a function 

Once you have an object, you can in addition
* use an object\'s property 
to retrieve another object. When does a property exist and how to retrieve it? This and other questions are answered in section <<el_properties>> while section <<el_implicit_objects>> lists available implicit objects and section <<el_functions>> is about functions to be used.

Notice that EL does also not provide a notation for arrays or list objects nor is there a `list` data type. Nevertheless, Flaka provides a `list()` function to create a collection of arbitrary objects. There is also task `for` able to iterate over collection types and there is function `size()` which returns the number of items in a collection. How does this work? EL uses a concept called _duck typing_ where a object\'s type is not given by a class but rather by it\'s properties: _I call every object that walks, swims and quacks like a duck, a duck_. Thus properties are looked up during runtime and a object provides all required properties, the object is applied.


[[el_operators]]
=== Operators ===

This are the most important operators defined in EL:

* `empty` checks whether a variable is empty or not and returns either `true` or `false`. It is important to understand that `null` is considered empty.
*  condition operator `c ? a : b` evaluates `c` in a boolean context and returns the evaluation of expression `a` if `c` evaluates to `true`; otherwise `eval(b)` will be the result of this operator.
* `.` and  `[]` are property operators described in <<el_properties,section _Properties_>> below.
* logical operators `not`, `and` and `or`
* relational operators `==`, '!=`, `<`, `>`, `<=` and `>=` (resp. `eq`, `ne`, `lt`, `gt`, `le` and `ge`).
* usual arithmetic operators like `+`, `-`, `*`, `/`, `mod` and `div` etc.


[[el_implicit_objects,EL Implicit Object]]
=== Implicit Objects ===

Flaka provides implicit objects that can be utilized writing <<el>> expressions:

[cols="1*25%,75%",frame="topbot",grid="none",options="header,footer"]
|==================================
| Implicit Object | Description 
| project         | The current Ant project as object. To query the project\'s default target, base folder and other things (see also <<el_project_properties,project properties>> and <<el_natural_properties,natural properties>>). 
| property | Use this object to query project properties. 
| e | The mathematical number http://en.wikipedia.org/wiki/E_(mathematical_constant)[e], also known as http://en.wikipedia.org/wiki/Euler[Euler]'s number.
| pi | The number http://en.wikipedia.org/wiki/PI[PI] 
|==================================

The following implicit objects are deprecated:

[cols="1*25%,75%",frame="topbot",grid="none",options="header,footer"]
|==================================
| Implicit Object | Alternative
| reference | `project.references`
| var | `project.references`
| target| `project.targets`
| taskdef| `project.taskdefs`
| macrodefs| `project.macrodefs`
| tasks| `project.tasks`
| filter| `project.filters`
|==================================


[[el_functions,EL Functions]]
=== Functions ===

This sections presents functions defined by Flaka and which are available without any further action. Notice that providing own functions is currently not possible. A note about the conventions used in the notation of function signatures:

* _T_ is a placeholder meaning any type
* _T.._ means that a variable list of arguments of type _T_ can be used 
* _name:T_ is used to give a parameter a name which is then used in the follow up explanation of this function. 



==== Generic Functions ====

===== `typeof(T):string` =====

A function to determine the object\'s type:
-------------------------------------
typeof(null)               ; 'null'
typeof('')                 ; 'string'
typeof(3)                  ; 'int'
typeof(pi)                 ; 'float'
typeof(true)               ; 'bool'
typeof(list())             ; 'list'
typeof(file('.'))          ; 'file'
typeof(project)            ; 'project'
typeof(project.properties) ; 'map'
typeof(other)              ; 'object'
-------------------------------------

===== `nativetype(T):string` =====

Use this function to determine native type, the type of the underlying implementation, of the given argument.
-------------------------------------
nativetype(null)                ; ''
nativetype('')                  ; 'java.lang.String'
nativetype(3)                   ; 'java.lang.Long'
nativetype(pi)                  ; 'java.lang.Double'
nativetype(true)                ; 'java.lang.Boolean'
nativetype(list())              ; 'java.util.ArrayList'
nativetype(file(project))       ; 'java.io.File'
nativetype(project)             ; 'org.apache.ant.tools.Project'
nativetype(project.properties)  ; 'java.util.Hashtable'
nativetype(file(project).mtime) ; 'java.util.Date'
-------------------------------------


===== `size(T):integer` =====

The size of the object is given by the number of entities it contains. This is 0 (zero) for all primitive typeslike `int`, `null`, `float`, `bool`. Otherwise the object\'s size is determined via a `size` or `length` property.
-------------------------------------
size(null)            ; 0
size(3)               ; 0
size(pi)              ; 0
size(true)            ; 0
size(file(..))        ; 0
size(project)         ; 0
size(object)          ; object.size or object.length or 0
-------------------------------------
 
===== `nullp(T):boolean` =====

Evaluates to `true` if object is the `null` entity and `false` otherwise. Compare this function with operator `empty` which returns `true` if eiher the object in question does not exist or if literally empty, for example the empty list or the empty string.

-------------------------------------
nullp(null)            ; true
nullp(list())          ; false
nullp('')              ; false
empty null             ; true
empty list()           ; true
empty ''               ; true
-------------------------------------

==== File and Folder Functions ====

===== `file(T):file` =====
Creates and returns a file object out of `object`. If `object` is already a file, the object is simply returned. Otherwise if the object is not of type Project, the object is stringized and that string is taken as the file\'s path name. 

If the argument is an Ant project, then the project\'s base directory is returned as file object. Thus the following example iterates over all files and folders in the project\'s base directory:
-------------------------------------
<c:for var="f" in=" file(project).list ">
 <c:echo>#{f}</c:echo>
</c:for>
-------------------------------------
This function can be used to return the current working directory - which might be very different from the project\'s base directory. To do so, simply try `file('.')`.

If no argument is given, then object `null` is returned.


==== String Functions ====

===== `concat(T..):string` =====
Creates a string by concatenating all _stringized_ objects. If no object is provided, the empty string is returned. Thus to create the string `foobar`, try
-------------------------------------
concat('foo','bar')  ; `foobar'
-------------------------------------

===== `format(string,T..):string` =====
This function is a swiss army knife for creating a string based on existing objects. The functions expects a format string as first argument followed by any number of arguments. The optional arguments are used to construct the result string based on format instructions embedded in the first argument. Some examples:
-------------------------------------
format('foobar')           ; `foobar'
format('foo%s','bar')      ; `foobar'
format('%s%S','foo','bar'  ; `fooBAR'
format('%s',list('a',2))   ; `[a, 2]'
-------------------------------------

The number of format options to be used are almost infinite footnote:[Compare http://download.oracle.com/javase/1.5.0/docs/api/java/util/Formatter.html].

===== `replace(string, subst:T, regex:T):string` =====

Create a new string by replacing substrings. Substrings to be replaced are described via regular expressions. If no substitute string is given, the empty string is used. The default regular expression is `\s*,\s*` which means, that all commas - including leading and trailing whitespace - are replaced. Arguments are stringized before used.
-------------------------------------
replace('a, b')              ; 'ab'
replace('a, b','')           ; 'ab'
replace('a, b','','\s*,\s*)  ; 'ab'
replace(true,'false','true') ; 'false' 
-------------------------------------

The behaviour of this function is undefined if called without arguments.

===== `split(string, regex:T):list` =====

A function to tokenize a string into a list of strings. Tokens are seperated from each other by text matching a given regular expression. Arguments are stringized before used. If no regular expression is given, then `\*s,\s*` is used. The behaviour is undefined if no arguments are given.
-------------------------------------
split('a,b')          ; list('a','b')
split('a:b',':')      ; list('a','b')
-------------------------------------

===== `trim(string):string` =====

A convenience function to remove leading and trailing whitespice from a string (stringized object). This function can be expressed in terms of function `replace()` like
-------------------------------------
trim(s)              ; replace(s,'','^\s*|\s*$')
-------------------------------------

===== `ltrim(string):string` =====
Similar to function `trim()` above but only leading whitespace is being removed.
-------------------------------------
ltrim(s)              ; replace(s,'','^\s*')
-------------------------------------

===== `rtrim(string):string` =====
Similar to function `trim()` above but only trailing whitespace is being removed.
-------------------------------------
rtrim(s)              ; replace(s,'','\s*$')
-------------------------------------

==== List Functions ====

This sections lists EL functions operating on lists where a list is a synonym for any collection of elements. In case you are missing a function to retrieve the n-th list element, then try 
-------------------------------------
list('a','b','c')[1]           ; 'b'
-------------------------------------


===== `list(T..):list` ===== 
A function taking a arbitrary number of elements to create a list object. Returns the empty list when called without arguments.
-------------------------------------
list()                ; []
list('a',2)           ; ['a',2]
list(list('a',2))     ; [['a',2]]
-------------------------------------

===== `append(T..):list` ===== 
This function is similar to `list` by creating a list based on given arguments. However, each argument being a list is treated in a special way by appending the list elements rather the list itself.

-------------------------------------
append()                       ; list()
append('a',2)                  ; list('a',2)
append(1,list('a',2),true)     ; list(1,'a',2,true)
-------------------------------------

===== `join(string,list):string` =====

This functions creates a string by joining elements in `list` with the first argument. The first argument is stringized. If the second argument not given, the empty string is returned. Otherwise, if the second argument is not a list, then the stringized second argument is returned. The behaviour is undefined if called without arguments.
-------------------------------------
join(':')                    ; `'
join(':',5)                  ; `5'
join(':',list('a',2))        ; `a:2'
-------------------------------------

If this function is called with more then two arguments, then all arguments but the first are collected into a list object and then processed like described above. 
-------------------------------------
join(':','a',2)              ; join(':',list('a',2))  
-------------------------------------


==== Mathematical Functions ====
[cols="45%,55%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Function | Description 
| `sin(double):double` | The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[sine] function 
| `cos(double):double` | The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[cosine] function 
| `tan(double):double` | The mathematical http://en.wikipedia.org/wiki/Trigonometric_functions[tangent] function 
| `exp(double):double` | The mathematical exponential function, `e` raised to the power of the given argument 
| `log(double):double` | The mathematical logarithm function of base `e` 
| `pow(double,double):double` | Returns the value of the first argument raised to the power of the second argument. 
| `sqrt(double):double` | Returns the correctly rounded positive square root of a double value. 
| `abs(double):double` | Returns the absolute value of a double value. 
| `min(double, double):double` | Returns the smaller of two double values. 
| `max(double, double):double` | Returns the larget of two double values. 
| `rand():double` | Returns a double value with a positive sign, greater than or equal to 0.0 and less than 1.0. 
|=================================

[[el_properties,EL Properties]]
=== Properties ===

It\'s best to introduce properties with three simple examples. It\'s about to ask a string about his uppercase variant, about it\'s length and about to create a folder with the string\'s value. 

-------------------------------------
'abc'.toupper           => 'ABC'
'abc'.length            => 3
'abc'['tofile'].mkdir   => true/false
-------------------------------------

The specification of EL provides only a notation to query an object for a property. EL does not specfic which properties must exists nor does it require that an object must have any properties. Each implementation is free to define properties according to the underlying implementation and usage domain. What is specified however is, how the query a property must be written. Consider:

-------------------------------------
obj.name
obj['name.with.dot']
-------------------------------------

The first variation is the standard notation to lookup property `name` on object `obj`. Here `name` can be composed of almost any character but character `.` itself. After all, `.` is the lookup operator here. This limitation can cause problems in certain domains. Therefore, an alternative lookup operator `[]` has been defined by the specification.

Another important point to keep in mind is about looking up a property on the `null` object and what is the result of asking for a property which does not exist? The perhaps surprising answer is that both case do not cause an error or worse but are perfectly legal and well defined. The result is in both cases the `null` object. Consider:

-------------------------------------
null.someproperty        ; null
obj.notexisting          ; null
-------------------------------------

Now it\'s about time to tell, which properties are available.

[[el_natural_properties,Natural Properties]]
==== Natural Properties ====

A _natural_ property `x` exits if the underlaying Java object has a public getter method with the same name as `x` and where the names are compared caseinsensitively. Assume that we have on object `f` of type `java.io.File` footnote:[see http://download.oracle.com/javase/1.5.0/docs/api/java/io/File.html]. The following listing shows two natural properties on object `f` and how `f` will be used by the underlying EL implementation:

-------------------------------------
f.name             ; f.getName()
f['parentfile]     ; f.getParentFile()
-------------------------------------


==== Primitve Type Properties ====

Primite data types (integer, float, boolean and null) have no properties.

==== List and Array Properties ====

Besides _natural_ properties can lists and arrays be queried with an _index_ returning the element at that position or `null` if the index is out of range. Consider:

-------------------------------------
list('a','b')[1]    ; 'b'
list('a','b')[-1]   ; null
list('a','b')[2]    ; null
-------------------------------------

[[el_string_properties,String Properties]]
==== String Properties ====

Table above lists properties that can be queried besides natural properties:

[cols="2*15%,70%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Property | Type | Description 
| length   | int  | number of characters in this string 
| size     | int  | same as property `length` 
| tolower  | string | return this string in lowercase characters only 
| toupper  | string | return this string in uppercase characters only 
| trim     | string | remove leading and trailing whitespace characters 
| tofile   | file  | create a file based on this string; the so created will be relative to the current build file\'s base folder if the string\'s value does not denote a absolute path. Furthermore, the empty string will create a file object denoting the project\'s base folder (i.e. the folder containing the build script currently executed). Notice that `.` and `..` denote absolute paths, not relative ones. 
|=================================

[[el_file_properties,File Properties]]
==== File Properties ====

Files and folders is Ant\'s bread and butter. A couple of properties are defined on file objects to simplify scripting (see below). Most important is however how to _get_ a file object in the first place. Consider:

-------------------------------------
'myfolder'.tofile
file('myfolder')
-------------------------------------

Then, having a file object at your finger tips, the following properties are available:

[cols="30%,10%,60%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Property | Type | Description 
| `absolutefile` | file | The absolute form of this abstract pathname
| `absolutepath` | string | The absolute form of this abstract pathname
| `canonicalfile` | file | The canonical form of this abstract pathname
| `canonicalPpath` | string | The canonical form of this abstract pathname
| `delete` | boolean | deletes the file or folder (true); false otherwise 
| `exists` | boolean | check whether file or folder exists 
| `isdir`  | boolean | check whether a folder (directory) 
| `isfile` | boolean | check whether a file 
| `ishidden` | boolean | check whether a hidden file or folder 
| `isread` | boolean | check whether a file or folder is readable 
| `iswrite` | boolean | check whether a file or folder is writable 
| `length` | integer  | same as `size` 
| `list`   | list | array of files in folder  
| `mkdir`  | boolean | creates the folder (and intermediate) folders (true); false otherwise 
| `mtime`  | Date | last modification date  
| `name`   | string | The basename 
| `parent` | file | parent of file or folder as file object 
| `path`   | string |abstract pathname into a pathname string.
| `size`   | integer  | number of bytes in a (existing) file; 0 otherwise
| `toabs`| file | file or folder as absolute file object 
| `tostr` | string | file name as string object 
| `touri`    | URI  | file as URI object 
| `tourl`    | URL  | file as URL object 
|=================================

[[el_matcher_properties,Matcher Properties]]
==== Matcher Properties ====

A _matcher object_ is created by task <<task_switch>> if a regular expression matches a input value. Such a matcher object contains details of the match like the start and end position, the pattern used to match and it allows to explore details of capturing groups (also known as _marked_ subexpression).

[cols="2*15%,70%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Property | Type     | Description 
| `start`   | int     | The position within the input where the match starts. 
| `s`       | int     | Same as `start` 
| `end`     | int     | The position within the input where the match ends (the character at `end` is the last matching character)  
| `e`       | int     | Same as `end`   
| `groups`  | int     | The number of capturing groups in the (regular) expression. 
| `size`    | int     | Same as `groups` 
| `length`  | int     | Same as `groups` 
| `n`       | int     | Same as `groups` 
| `pattern` | string  | The regular expression that was used for this match. Notice that glob expressions are translated into regular expressions. 
| `p`       | string  | Same as `pattern` 
| _i_       | matcher | The matcher object for _i_\'th capturing group. See task <<task_switch>> for examples. 
|=================================

[[el_project_properties,Project Properties]]
==== Project Properties ====

This sections lists additional properties that can be queried on an object of type `project`, i.e. of an Ant project. For natural properties, checkout the Javadoc of class org.apache.tools.ant.Project footnote:[for example http://javadoc.haefelinger.it/org.apache.ant/1.7.1/org/apache/tools/ant/Project.html].

[cols="25%,15%,60%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Property  | Type | Description 
| `basedir` | file     | The project\'s base directory as file object. 
| `targets` | list     | A list of all target names
| `tasks`   | list     | A list of all taskdef and macrodef names
| `taskdefs`| list     | A list of all taskdef names 
| `macrodefs` | list   | A list of all macrodef names
|=================================


[[el_type_conversion,Type Conversion]]
=== Type Conversion ===

Every EL expression is evaluated in the context of an _expected_ type. When a evaluated expression does not match it\'s expected type, implicit type conversion takes place. The following sections list the rules which apply.

==== Type boolean ====

The following table describes the conversion of object `obj` into an boolean value:

[cols="30%,70%",frame="topbot",grid="none",options="header,footer"]
|=================================
| Type        | Result 
| null        | `false`
| string      | `false` if obj is `""`, otherwise `Boolean.valueof(obj)`
| boolean     | obj
| file        | `true` if the file described by obj exists
| _other_      | false
|=================================

