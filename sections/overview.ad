

=== An Expression Language ===

The http://en.wikipedia.org/wiki/Unified_Expression_Language[Java Unified Expression Language] is a special purpose programming language offering a simple way of accessing data objects. The language has its roots in Java web applications for embedding expressions into web pages. While the expression language is part of the JSP specification, it does in no way depend on the JSP itself. To the contrary, the language can be made available in a variety of contexts.

One such context is Ant scripting. Ant makes it difficult to access data objects. For example, there is no way of querying the underlying data object for the base folder (the folder containing the build script). All that Ant offers is the path name of this folder as _string_ object. This makes it for example rather cumbersome to report the last modification time of this folder. With the help of EL (short for _Expression Language_) this becomes an easy task:

-------------------------------------
<c:echo>
  ;; basedir is a standard Ant property 
  basedir is ${basedir}

  ;; report last modification time (as Date object)
  was last modified at #{ '${basedir}'.tofile.mtime }

  ;; dump the full name of this build file 
  ;; where 'ant.file' is a standard property
  this is #{property['ant.file'] } reporting!
</c:echo>
-------------------------------------

Being executed, this snippet produces something like 

-------------------------------------
[c:echo] basedir is /projects/flaka/test
[c:echo] 
[c:echo] was last modified at Mon Mar 09 13:52:29 CET 2009
[c:echo] 
[c:echo] this is /projects/flaka/test/tryme.xml reporting!
-------------------------------------

Notice that Flaka\'s <<task_echo>> task has been used for this illustration because <<el>> is by default only available on Flaka tasks. If http://ant.apache.org/manual/CoreTasks/echo.html[Ant\'s standard echo] task is used, all `#{..}` constructs are left as they are. It is however possible and recommended to turn <<el>> on for _all_ tasks footnote::[[See <<el_enable_el,how to enable EL>> for details]].

The next code example shows another _EL in action_ sample. The programming problem is to list all unreadable (sub)folders in a certain folder - here being the _root_ folder:

-------------------------------------
<c:let>
  ; The root folder as file object. Notice that the right side of each
  ; assignment is an EL expression.
  root = '/'.tofile
  ; This creates an empty list
  list = list()
</c:let>

<c:for var="file" in=" root.list ">
  <c:when test=" file.isdir and not file.isread ">
    <c:let>
      ;; The condition above is a EL expression and so is this
      ;; `append` function.
      list = append(file,list)
    </c:let>
  </c:when>
</c:for>

<c:echo>
  ;; how many unreadable directories ??
  There are #{size(list)} unreadable directories in #{root}.
  And here they are #{list}.
</c:echo>
-------------------------------------

Executed on MacOS 10.5.6 (aka "Leopard") gives:

-------------------------------------
[c:echo] There are 2 unreadable directories in /.
[c:echo] And here they are [/.Trashes, /.Spotlight-V100].
-------------------------------------

Have a look at <<el>> for further EL examples and details.


[[conditionals]]
=== Conditionals ===

With standard Ant, task http://ant.apache.org/manual/CoreTasks/condition.html[condition] is used to set a property if a condition is given. Then a macro, task or target can be conditionally executed  by checking the existence or absence of that property (using standard attributes _if_ or _unless_. Flaka defines a couple of control structures to handle conditionals in a simpler way.

==== when and unless ====

Task <<task_when>> evaluates an <<el>> expressio. If the evaluation gives `true`, the sequence of tasks are executed. Nothing else happens in case of `false`. 


-------------------------------------

<c:when test=" expr ">
   -- executed if expr evaluates to true
</c:when>

-------------------------------------


The logical negation of `when` is task <<task_unless>> which executes the sequence of tasks only in case the evaluation of _expr_ returns `false`.


-------------------------------------

 <c:unless test=" expr ">
   -- executed if expr evaluates to false
 </c:unless>

-------------------------------------


The body of `when` and `unset` may contain any sequence of tasks or macros (or a combination of both).

==== choose ====

Task <<task_choose>> tests each `when` condition in turn until an _expr_ evalutes to `true`. It executes then the body of that when condition. Subsequent `whens` are then not further tested (nor executed). If all expressions evaluate to `false`, an optional _catch-all_ clause gets executed.


-------------------------------------

 <c:choose>
  <when test="expr_1">
    -- body_1
  </when>
  ..
  <otherwise> -- optional_
    -- catch all body
  </otherwise>
 <c:/choose>

-------------------------------------


==== switch ====

A programming task often seen is to check whether a (string) value matches a given (string) value. If so, a particular action shall be carried out. This can be done via a series of _when_ statements. The nasty thing is to keep track of whether a value matched already. Flaka provides a handy task for this common scenario, the <<task_switch>> task:


-------------------------------------

 <c:switch value=" 'some string' ">
  <matches re="regular expression or pattern" >
    -- body_1
  </case>
  ..
  <otherwise> -- optional
    -- catch all body
  </otherwise>
 </c:switch>

-------------------------------------


Each case is tried in turn _to match_ the string value (given as <<el>> expression). If a case matches, the appropriate case body is executed. If it happens that no case matches, then the optional default body is executed. To be of greater value, a regular expression or pattern expression can be used in a case condition.

[[looping]]
=== Repetition ===

Flaka has a looping statement. Use task <<task_for>> to iterate over a _list_ of items. Use <<task_break>> and <<task_continue>> to terminate the loop or to continue the loop with the next item.


-------------------------------------

 <c:for var=" name " in=" ''.tofile.list ">
    -- sequence of task or macros
    -- used <c:continue /> to continue ; and
    -- <c:break /> to stop looping
    -- use #{name} to refer to current item (as shown below)
    <c:echo>#{name}</c:echo>
 </c:for>

-------------------------------------


Attribute `in` will be evaluated as <<el>> expression. In the example above, that <<el>> expression is `''.tofile.list` which, when evaluated, creates a list of all files in the folder containing the current build script. To understand the expression, have a look at <<el_string_properties,properties>> of a string] and <<el_file_properties,properties>> of a file.

[[exception_handling]]
=== Exception Handling ===

Flaka has been charged with exception handling tasks.

==== trycatch ====

Flaka contains a task to handle exceptions thrown by tasks, <<task_trycatch>>. This task implements the usual _try/catch/finally_ trinity found in various programming languages (like in Java for example):


-------------------------------------

 <c:trycatch>
   <try>
     -- sequence of task or macros
   </try>
   <catch>
     -- sequence of task or macros
   </catch>
   <finally>
     -- sequence of task or macros
   </finally>
 </c:trycatch> 

-------------------------------------


Element _try_, _catch_ and _finally_ are all optional or can appear multiple times. If _catch_ is used without any argument, then that catch clause will match any *build exception*. To differentiate between different exception types, _catch_ can additionally be used with a _type_ and _match_ argument. The former can be used to select a particular exception type (like a 'java.lang.NullPointerException), the latter can be used to select an exception based on the message carried. Both arguments are interpreted as pattern expression. For example:


-------------------------------------

 <c:trycatch>
   <try>
      ..
      <fail message="#PANIC!" unless="ant.file"/>
      ..
   </try>
   <catch match="*#PANIC!*">
      <echo>Ant initialization problem!!</echo>
      <fail/>
   <catch type="java.lang.*">
     -- handle Java runtime problems
   </catch>
   <catch>
     -- handle all other build exceptions
   </catch>
  </c:trycatch>

-------------------------------------


Property _ant.file_ is a standard Ant property that should always be set. If not, there's something seriously wrong and it does not make much sense to continue. Use attribute _type_ to catch (runtime) exceptions thrown by the underlying implementation.

==== throw ====

Task <<task_throw>> throws a (build) exception.


-------------------------------------

 <c:throw [var="sym"] />

-------------------------------------


This task can also be used to rethrow an existing exception.



[[macros]]
=== Procedures ===

==== Ant Macros ====
The (almost) equivalent of a procedure is a macro in Ant and Flaka. For example:

-------------------------------------

 <macrodef name="hello">
  <attribute name="msg" />
  <element name="body" implicit="true" />
  <sequential>
   <body />
  </sequential>
 </macrodef>

-------------------------------------


Once defined, simply use it:

-------------------------------------

<hello msg="Hello, world!">
 <echo>@{msg}</echo>
</hello>

-------------------------------------


This macro evaluates into 

-------------------------------------

 <echo>Hello, world!</echo>

-------------------------------------

which eventually prints the desired greeting.

Macros are a standard feature of Ant.

[[sequencing]]
==== Sequencing ====

To evaluate a sequence of expressions (tasks or macros) where only one expression is allowed, use http://ant.apache.org/manual/CoreTasks/sequential.html[Ant's sequential task]:


-------------------------------------

 <sequential>
   -- any sequence of tasks or macros
 </sequential>

-------------------------------------


Note that _sequential_ returns nothing. Use properties to communicate with the caller if necessary.



