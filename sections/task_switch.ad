
[[task_switch,switch]]
== switch ==

Task `switch` has been designed to provide for simple pattern matching. The idea is to match a series of patterns - either http://en.wikipedia.org/wiki/Regular_expression[regular] or a http://en.wikipedia.org/wiki/Glob_(programming)[glob] expressions -  against a _string value_ and carry out a sequence of actions in case of a hit. Here is an illustrative example:

--------------------------------------
 <c:switch value=" a${string}#{value} ">
  <matches glob="*.jar">          -- #1
   -- string ending in .jar
  </matches>
  <matches re="1|2|3">            -- #2
    -- one or two or three
  </matches>
  <matches re="-\d+">             -- #3
    -- negative integral number
  </matches>
  <otherwise>
   -- no match so far ..
  </otherwise>
 <c:case>
--------------------------------------

Notice the usage of a glob expression in the first and the usage of regular expressions in the second and third `matches` element. Utilization of glob and regular expressions make `switch` a very flexible and powerful conditional statement.

=== Attributes ===
// cols=5
[cols="15%,2*11%,63%"]
|===========================
| Attribute | Type   | Default | Description 
| `value`   | string |    ""   | The string value that needs to be matched against.
| `var`     | string |       - | Save details of this match as `matching object` using the variable name given. 
| `ignorecase` | bool | false  | Enables case-insensitive matching. 
| `comments`   | bool | false  | Permits whitespace and comments in pattern. 
| `dotall`     | bool | false  | In dotall mode, the literal `.` matches any character, including a line terminator. 
| `unixlines`  | bool | false  | In this mode, only character `LF` is accepted as line terminator character when using `.`, `^`, and `$`. 
| `multiline`  | bool | false | In multiline mode, the literals `^` and `$` match just after or just before, respectively, a line terminator or the end of the input sequence.
| `debug`      | bool  | false | Turn on extra debug information 
| _matches_.`re`  | string |    | Element `matches`: Specify a matching pattern as regular expression. 
| _matches_.`pat` | string |   | Element `matches`: Specify a matching pattern as glob expression 
|===========================

Note that switch\'s *value( given is _normalized_. Leading and trailing whitespace is removed. This attribute is <<el>> enabled but notice that you have to use EL references like `a#{ expr }b`.

A matcher object is saved in variable *var*. This matcher object allows to access matching details like the number of capturing groups and the like. See <<el_matcher_properties,matcher properties>> for a list of available properties; see also below for examples. The variable name must be a string which may contain EL references.

By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched. Unicode-aware case-insensitive matching can be enabled by specifying the UNICODE_CASE flag in conjunction with this flag. Case-insensitive matching can also be enabled via the embedded flag expression `(?i)`.

In this mode, whitespace is ignored, and embedded comments starting with # are ignored until the end of a line. Comments mode can also be enabled via the embedded flag expression `(?x)`.

By default does `.` (the dot) match any character but line terminators. This can be changed by setting the *dotall* attribute to `true`. Dotall mode can also be enabled via the embedded flag expression `(?s)`, where `s` is a mnemonic for _single-line_ mode, which is what this mode is called in http://en.wikipedia.org/wiki/Perl[Perl]. 

Unix lines mode can also be enabled via the embedded flag expression (?d). 

By default do `^` and `$` only match at the beginning and the end of the entire input sequence. By setting *multiline* to `true` do they match just after and just before a line termination character. Multiline mode can also be enabled via the embedded flag expression (?m). 

Note that each of the above `switch` attributes can also be applied to a `matches` element. Applied on `switch` has the effect of providing the default value for subsequenct `matches` elements.

=== Elements ===

// cols=3
[cols="15%,1*35%,50%"]
|===========================
| Element   | Cardinality | Description 
| `matches` | 0..infinity | An element to specify pattern. 
| `default` | 0..1        | The default statement will be executed if no `matches` element matched the input value.
| `otherwise` | 0..1     | This element is a synonym for element `default` 
|===========================

Element *matches* supports all the attributes of the enclosing `switch` with the exception of `value`. It may contain any number of tasks or macros as sub elements. They are carried out if the pattern matches the given switch value.

The *default* element is carried out if no pattern matched. This element is optional and can only be specified once. A build exception will be raised if used more than once. It does not accept any attributes.  It may contain any number of tasks or macros as sub elements. 

=== Behaviour ===

Attribute `value` is the basis for all further matching. It is a string value which may contain <<glossary_property_references,property >> or <<glossary_expression_reference,EL>> references. 

Any number of `matches` elements are allowed and at most one `otherwise` or `default` element. Whether the `otherwise` element is at the end, in the middle or at the begin does not matter. The order of `matches`  is relevant however. Each `matches` element is tried against the value in the order given. Then, if no element matched, a given `otherwise` or `default` element is carried out. Otherwise the winning matching elment will while remaining elements are ignored.

Carrying out an element means that all enclosed tasks or macros are executed in the order given. 

The underlying regular expression engine is the one given by Java. It's http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html[Javadoc] documentation is a pretty good source of information if you are familiar with regular expressions. For all the gory details, have a look at http://oreilly.com/catalog/9780596528126/index.html[Mastering Regular Expressions] by Jeffrey E. F. Friedl. 

Be aware that there is no need to escape the escape character. For example, people using regular expressions in Java are used to write `\\*` if they want match the literal `*` character and thus escaping from the usual semantics (match zero or more times). This is not necessary in Flaka where the input sequence `\*` remains `\*`.

So called _globs_ are a kind of simplified regular expressions. They lack the full power while simplifying the expression. For example, to specify whether a name input string end in `jar`, we can simply write 

--------------------------------------
 <c:switch value=" #{myfile}.name ">
  <matches glob="*.jar">
    -- do something with jar file ..
  </matches>
 </c:switch>
--------------------------------------

The very same can also be expressed as `re="\.jar$"` using regular expressions. The biggest disadvange of globs are that capturing groups are not supported. Thus the match above just indicates that the file name ends in `.jar` while there is nothing to figure the file's basename. Compare this with 

--------------------------------------
 <c:switch value=" #{myfile}.name ">
  <matches re="^(.*)\.jar$" var="m">
    <c:echo>
      basename = #{m[1]}
    </c:echo>       
  </matches>
 </c:switch>
--------------------------------------

Here we use a capturing group for the basename. A matcher object will be associated with variable `m`. This object can then <<el_matcher_properties,evaluated using properties>> for matching details.

Here is a more complicated example. It was used once to examine a CVS tag which was supposed to follow the convetion `schema-(env_)version`, where `(env_)` was optional, `schema` indicated the tag's semantic and where `version` was the products version or build number: 
--------------------------------------
 <c:switch value=" 'v-uat_3_20_500' " var="m">
   <matches re="v-(?:([^\d][^_]*)_)?(\d.*)" >
     <c:echo>
       pattern      = #{m.p}         -- v-(?:([^\d][^_]*)_)?(\d.*)
       groups       = #{m.n}         -- 2
       matched text = #{m}           -- v-uat_3_20_500  (same as m[0])
       env          = #{m[1]}        -- uat
       version      = #{m[2]}        -- 3_20_500
       ;; refering to non existing group
       ??           = #{m[3]}        -- (empty string)
       ;; start and end index of first group
       start        = #{m[1].s}      -- 2
       end          = #{m[1].e}      -- 5
     </c:echo>
   </matches>
 </c:switch>
--------------------------------------

=== Further Links ===
 * http://javadoc.haefelinger.it/it.haefelinger.flaka/1.01/it/haefelinger/flaka/Switch.html[Javadoc] 
 * http://code.google.com/p/flaka/source/browse/tags/1.01/src/it/haefelinger/flaka/Switch.java[Source]


