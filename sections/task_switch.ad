
[[task_switch,switch]]
=== switch ===

Task `switch` provides text based pattern matching. An illustrative example:

--------------------------------------
 <c:switch value="${value}">
  <re expr="(+|-)?(0|[1-9]\d*)" var="g">        (1)    
    <c:echo>
      integer with absolute value: #{g[2]}
    </c:echo>
  </re>
  <glob expr"*.jar">                            (2)
   <echo>It's a -- jar!</echo>
  </glob>
  <cmp eq="foo" lt="foo">                       (3)
    <!-- less or equals "foo" -->
  </cmp>
  <otherwise>
    <! none of the above clauses matched -->
  </otherwise>
 </c:switch>
--------------------------------------

This example demonstrates, that a given value can be compared using a regular expression (1), using a glob expression (2) or compared for equality, less or greater sort order (3). Why providing alternatives for regular expressions? Cause the biggest drawback of regular expressions is their complexity. Compare this two variations to check whether a string value ends in `.jar`:

--------------------------------------
<re="(.*)\.jar" var="g">
  <c:echo>
    basename is #{g[1]}.
  </c:echo>
</re>

<glob="*.jar" var="g">
  <c:echo>
    filename is #{g[0]}.
  </c:echo>
</glob>
--------------------------------------

The latter one, the glob expression, is much easier to grasp. There, a `*` just stands for a sequence of arbitrary characters. In most pattern recognitzion tasks, this is all what is needed to get going. If more power is required, then regular expressions are the tool to be applied.

// allows for basic pattern matching only. In a glob expression, meta-character `*` just stands for an arbitrary long sequence of arbitrary characters footnote::[other meta-characters are `?` and `[]` - for details continue to read section Behaviour].

// Glob expression do have on big disadvange besides their lack of power. That is that capturing groups are not supported. This is als o illustrated in the example given above. By using a caputuring group `(.*)`, we are able to break the input apart in well defined pieces - the _basename_ and the _extension_ (.jar). Match details are saved in a (EL) object and can the be used in EL ready tasks like shown in the echo task above.

Eventually `cmp` allows for simple text comparison without any meta-characters. It also allows to check whether the input string is before or after a given test string.

// and `?` for a single character. Glob expressions do also support character sets, i.e. `[ab]` expresses either character `a` or `b` while `[!ab]` means neither of them. Glob expressions can easily be translated into regular expressions and it's common to make them use the same underlying regular expression engine.
//Using a regular expression is the most powerfull alternative. The underlying regular expression engine is the one given by Java. It's http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html[Javadoc] documentation is a pretty good source of informatio. Gory details are described in http://oreilly.com/catalog/9780596528126/index.html[Mastering Regular Expressions] by Jeffrey E. F. Friedl. 

==== Attributes ====
// cols=5
[cols="20%,2*11%,58%"]
|===========================
| Attribute | Type   | Default | Description 
| `value`   | string |    ""   | The string value that needs to be matched against.
| `var`     | string |       - | Save details of this match as `matching object`. 
| `not`     | bool | false | Whether to invert the test result or not.
| `find`    | bool | false | Whether to match the input value partially (true) or as a whole (false) 
| `debug`      | bool  | false | Whether to turn on extra debug information 
| `literally` | bool | false | Whether to take an invalid expression literally or not.
| `ignorecase` | bool | false  | Whether to enable case-insensitive matching. 
| `comments`   | bool | false  | Whether to allow whitespace and comments in an _regex_. 
| `dotall`     | bool | false  | Whether literal `.` matches _any_ character.
| `unixlines`  | bool | false  | Whether _only_ `nl` is accepted as line terminator 
| `multiline`  | bool | false | Whether `^` and `$` shall _only_ match begin and end of input
| _re_.`expr`  | string |    | Element `matches`: Specify a matching pattern as regular expression. 
| _glob_.`expr` | string |   | Element `matches`: Specify a matching pattern as glob expression 
| _cmp_.`lt` | string | -  | `<cmp/>`: Specify a matching pattern as glob expression 
| _cmp_.`eq` | string | -  | `<cmp/>`: Specify a matching pattern as glob expression 
| _cmp_.`gt` | string | -  | `<cmp/>`: Specify a matching pattern as glob expression 
|===========================

Attribute *value* defines the test (string) value. EL <<el>> references can be used. Leading and trailing whitespace is always removed. A test of a clause will always evaluate to `false` if this attribute is not set. It is legal however to have a switch without this attribute.

The default settings of attributes *var*, .., *debug* have been shown in table above. A default setting can be changed by using the attribute on switch element level. Those default settings are inherited by each clause-element - `<re/>`, `<glob/>` or `<cmp/>`. Each attribute *var*,.., *debug* can be applied on clause-elements where they override their inherited setting:

--------------------------------------
 <c:switch .. not="true">
  ..
  <cmp eq="foo" lt="foo" not="false">    
    <!-- still less then "foo" or equal "foo" -->
  </cmp>
 </c:switch>
--------------------------------------

Use attribute *var* to specify the name of an EL variable to hold match details like the number of capturing groups, the value of the first capturing group and the like. See <<el_matcher_properties,matcher properties>> for a list of available properties; see also below for examples. The attribute value may contain EL references.

Attribute *not* can be used to invert the result of a test match.
--------------------------------------
 <c:switch ..>
  <cmp eq="foo" lt="foo" not="true">    
    <!-- greater then "foo"  -->
  </cmp>
 </c:switch>
--------------------------------------

When applying a regular or glob expression on a test value, then by default, the expression must describe the whole test value for a sucessful match. Attribute *find* can be used to change this behaviour. Set to `true`, then a sucessful match is given if the expression describes a part of the input string:

--------------------------------------
 <c:switch value="foobar">
  <glob find="true" expr="foo">    
    <!-- matches foobar -->
  </glob>
 </c:switch>
--------------------------------------

Attribute *find* does not apply on clause `cmp`.

Use attribute *debug* to enable extra output of debug information on your attached standard error stream, bypassing Ant's logging mechanics.

The semantics of attribute *literally* varies depending on it's context. A build failure is thrown if an illegal regular expression pattern - like `*` - is seen. If literally is enabled, the regular expression string is taken literally instead, no exception is thrown while a warning message is reported. If attribute *literally* is enabled in context of a glob expression, then any meta characters are taken as regular characters. Attribute *literally* has no meaning in the context of clause `cmp`. 

The remaining part of this section describes attributes *ignorecase*, .., *multiline*. This attributes can be used to change the characteristics of the underlying regular expression engine. Modern regular expression engines also allow to their characteristics on the fly by using embedded flags. Embedded flag alternatives are also listed.

Attribute *ignorecase* can be used to enable case-insensitive matching. This attribute also applies to clause `cmp`. Case-insensitive matching is enabled on the US-ASCII charset only. Unicode-aware matching can not be enabled. The embedded flag expression equivalent flag of this attribute is `(?i)`.

Use attribute *comment* to enrich regular expressions by comments. When set, whitespace is ignored and embedded comments starting with # are ignored until the end of a line. Comments mode can also be enabled via the embedded flag expression `(?x)`.

Attribute *dotall* can be used to change the characteristics of metacharacter `.`, the dot. By default all characters but line terminators are matched by this meta-character. When set, all characters are matched. The embedded equivalent is `(?s)` . 

Use attribute *unixlines* to let the regular expression engine accept `\n` as line termination character. The embedded flag expression is `(?d)`. 

Attribute *multiline* changes the characteristics of meta-character `^` and `$`. By default they match at the beginning and the end of the entire input sequence. When set, they match just after and just before a line termination character. Multiline mode can also be enabled via the embedded flag expression (?m). 


==== Elements ====

// cols=3
[cols="15%,1*35%,50%"]
|===========================
| Element     | Cardinality | Description 
| `re`        | arbitrary  | Regular expression based test clause.
| `glob`      | arbitrary  | Glob expression based test clause.
| `cmp`       | arbitrary  | Clause for basic equality and ordering.
| `otherwise` | arbitrary  | Task container, executed if all tests failed.
| `matches`   | arbitrary  | Legacy test clause (deprecated).
|===========================

Element *re* is a task container. Embedded tasks are conditionally carried out. The condition is satisfied if the regular expression expressed in attribute *expr* matches the given input value _switch_.`value`. If attribute *expr* is not used, then the condition is satisfied. Use attribute *not* to negate the condition. Be aware of the following pathological case:
--------------------------------------
 <c:switch value=..>
  <re>
    <!-- always carried out -->
  </re>
 <c:case>
--------------------------------------

Element *glob* is a task container similar to element *re*. The only difference is, that attribute *expr* is interpreted as glob expression instead of a regular expression as in *re*.

Element *cmp* is a task container similar to element *re* and *glob*. This element supports attributes *lt*, *eq* and *gt* in addition to inherited attributes. Embedded tasks are carried out if each comparison in each used attribute evaluates to true. If none of the attributes is used, then the condition is also satisfied.

Element *otherwise* does not express a test clause and does not support any attributes. This element is a task container. Embedded tasks are carried out if attribute _switch_.`value` has been set and if none of the test-clauses matched. This element can be present more than once. Elements are carried out in syntatical order.

Element *default* is an alias name for element `otherwise`.

==== Behaviour ====

Attribute `value` is applied against a series of _case_-clauses. A _case_-clause can be a 
* glob expression `<glob />` (simplified regular expression), 
* regular expression `<re />` or 
* simple textual comparison <cmp />. 
Case-clauses are applied in syntactial order from to to bottowm until a match is available. If a clause matches, then tasks associated with that clause are carried out and no further clauses are applied.

If no case-clause matches, then all optional available <otherwise />-clauses are carried out.

A case- and otherwise-clause are Ant-task containers and may contain an arbitrary number of tasks. There can be more than one otherwise-clause in a <switch /> and they do not need to occur after all cases-clauses. Therefore the follwing <switch /> is perfectly legal.

--------------------------------------
 <c:switch value=" bar ">
  <otherwise>
    <echo>Hello, </echo>
  </otherwise>
  <glob expr"baz" />         
  <otherwise>
    <echo>World</echo>
  </otherwise>
 <c:case>
--------------------------------------

Being executed, it would print 
--------------------------------------
[echo] Hello, 
[echo] World
--------------------------------------



Attribute `value` is the basis for all further matching. It is a string value which may contain <<glossary_property_references,property >> or <<glossary_expression_reference,EL>> references. 

Any number of `matches` elements are allowed and at most one `otherwise` or `default` element. Whether the `otherwise` element is at the end, in the middle or at the begin does not matter. The order of `matches`  is relevant however. Each `matches` element is tried against the value in the order given. Then, if no element matched, a given `otherwise` or `default` element is carried out. Otherwise the winning matching elment will while remaining elements are ignored.

Carrying out an element means that all enclosed tasks or macros are executed in the order given. 

The underlying regular expression engine is the one given by Java. It's http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html[Javadoc] documentation is a pretty good source of information if you are familiar with regular expressions. For all the gory details, have a look at http://oreilly.com/catalog/9780596528126/index.html[Mastering Regular Expressions] by Jeffrey E. F. Friedl. 

Be aware that there is no need to escape the escape character. For example, people using regular expressions in Java are used to write `\\*` if they want match the literal `*` character and thus escaping from the usual semantics (match zero or more times). This is not necessary in Flaka where the input sequence `\*` remains `\*`.

So called _globs_ are a kind of simplified regular expressions. They lack the full power while simplifying the expression. For example, to specify whether a name input string end in `jar`, we can simply write 

--------------------------------------
 <c:switch value=" #{myfile}.name ">
  <matches glob="*.jar">
    -- do something with jar file ..
  </matches>
 </c:switch>
--------------------------------------

The very same can also be expressed as `re="\.jar$"` using regular expressions. The biggest disadvange of globs are that capturing groups are not supported. Thus the match above just indicates that the file name ends in `.jar` while there is nothing to figure the file's basename. Compare this with 

--------------------------------------
 <c:switch value=" #{myfile}.name ">
  <matches re="^(.*)\.jar$" var="m">
    <c:echo>
      basename = #{m[1]}
    </c:echo>       
  </matches>
 </c:switch>
--------------------------------------

Here we use a capturing group for the basename. A matcher object will be associated with variable `m`. This object can then <<el_matcher_properties,evaluated using properties>> for matching details.

Here is a more complicated example. It was used once to examine a CVS tag which was supposed to follow the convetion `schema-(env_)version`, where `(env_)` was optional, `schema` indicated the tag's semantic and where `version` was the products version or build number: 
--------------------------------------
 <c:switch value=" 'v-uat_3_20_500' " var="m">
   <matches re="v-(?:([^\d][^_]*)_)?(\d.*)" >
     <c:echo>
       pattern      = #{m.p}         -- v-(?:([^\d][^_]*)_)?(\d.*)
       groups       = #{m.n}         -- 2
       matched text = #{m}           -- v-uat_3_20_500  (same as m[0])
       env          = #{m[1]}        -- uat
       version      = #{m[2]}        -- 3_20_500
       ;; refering to non existing group
       ??           = #{m[3]}        -- (empty string)
       ;; start and end index of first group
       start        = #{m[1].s}      -- 2
       end          = #{m[1].e}      -- 5
     </c:echo>
   </matches>
 </c:switch>
--------------------------------------

==== Further Links ====
 * http://javadoc.haefelinger.it/it.haefelinger.flaka/1.01/it/haefelinger/flaka/Switch.html[Javadoc] 
 * http://code.google.com/p/flaka/source/browse/tags/1.01/src/it/haefelinger/flaka/Switch.java[Source]


