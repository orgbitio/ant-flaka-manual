<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>The flaka manual</title>
    <date>February 2010</date>
    <author>
        <firstname>author</firstname>
        <surname>wh@haefelinger.it</surname>
    </author>
    <authorinitials>AW</authorinitials>
<revhistory><revision><revnumber>1.0</revnumber><date>February 2010</date><authorinitials>AW</authorinitials></revision></revhistory>
</articleinfo>
<section id="_introduction">
<title>Introduction</title>
<simpara>In the world of <ulink url="http://en.wikipedia.org/wiki/Java_(programming_language)">Java</ulink>, build scripts are traditionally written in <ulink url="http://en.wikipedia.org/wiki/Apache_Ant">Ant</ulink> and recently also in <ulink url="http://en.wikipedia.org/wiki/Apache_Maven">Maven</ulink>.</simpara>
<simpara>When it comes to write a build script using Ant, it feels like using a Shell script in a rather awkward language (XML). Each Ant task solves a particular problem. This is similar to a Shell where you have this small masterpieces like <literal>mkdir</literal>, <literal>cp</literal>, <literal>tar</literal> plus some control structures to eventually being able to put the one big thing together.</simpara>
<simpara>Writing a build script using a Shell is serious business. And so it is when using Ant. Ant does not provide you any abstraction how the project needs to be build. There is no underlying logic. In fact you, the author, need to know what to do. Step by step. What&#8217;s more, you have to use the unfriendly <ulink url="http://en.wikipedia.org/wiki/XML">XML</ulink> syntax and restrictions, a control structure is missing and you have to use immutable properties to communicate between tasks. Therefore, Ant scripts are large, notoriously difficult to understand, usually not portable (usuallyt they just work on the authors host) and each author uses a different set of targets and properties.</simpara>
<simpara>Maven on the other side provides a high abstraction of building a project. Instead of describing how the project needs to be build, just describe project details and reports you like to have and Maven figures out what needs to be done. This is probably the reason why Maven got so much attention recently.</simpara>
<simpara>Despite better knowledge I wrote that Maven figures out how a project needs to be build automatically. That’s actually not quite true. In fact, Maven only works fine when following conventions setup by the Maven team. When not “en route”, Maven gets difficult as well. But even when following conventions, the number of options in Maven are now endless and question the idear of a declarative approach. Have a look at Maven&#8217;s <ulink url="http://maven.apache.org/ref/current/maven-model/maven.html">POM</ulink> being a never ending series of XML tags]. At the end, I found myself using Ant again.</simpara>
<simpara>Still I&#8217;m not happy with Ant.</simpara>
<simpara>What I&#8217;m missing is the full power of a programming language. Yes, I want to have conditionals, loops and exception handling. I want to have variables which I can set or remove for pleasure. Such variables can reference any kind of object not only strings. And I need a nice expression language to retrieve and calculate in a simple yet elegant way. And there is no need to have each and everything expressed in XML. And then I want to have some kind of higher abstraction which does the right thing most of the time. This is what Flaka is about:</simpara>
<itemizedlist>
<listitem>
<simpara>
Programming Tasks (conditional, loops, exception handling, ..)
</simpara>
</listitem>
<listitem>
<simpara>
Embedded Expression Language (EL)
</simpara>
</listitem>
<listitem>
<simpara>
Framework to do the <emphasis>right</emphasis> thing, yet allows to use standard Ant when necessary
</simpara>
</listitem>
<listitem>
<simpara>
Dependency handling (legacy, to be replaced by Ivy)
</simpara>
</listitem>
</itemizedlist>
<simpara>This four pillars are Flakas approach to simplify the process of writing a build script with Ant. Notice that you are by no means forced to use all four pillars. You can for example just use the  programming tasks with or without elements of EL while you don&#8217;t need to get in touch with Flakas dependency handling instruments and neither with the framework.</simpara>
<simpara>The folling example of a complete build script shall demonstrate the idear how a build script using Flaka looks like:</simpara>
<screen>&lt;project xmlns:c="antlib:it.haefelinger.flaka"&gt;
 &lt;c:build /&gt;
 &lt;c:dependency alias="log4j" /&gt;
&lt;/project&gt;</screen>
<simpara>The author just lists the dependencies required to build the project. Flaka would do the rest by checking the underlying project structure:</simpara>
<itemizedlist>
<listitem>
<simpara>
figure out what type of project should be build (jar, war, ear ..)
</simpara>
</listitem>
<listitem>
<simpara>
figure out where project&#8217;s source code, test cases etc are
</simpara>
</listitem>
<listitem>
<simpara>
handle dependencies
</simpara>
</listitem>
<listitem>
<simpara>
create targets like <literal>clean</literal>, <literal>compile</literal>, <literal>package</literal>, <literal>test</literal> automatically
</simpara>
</listitem>
<listitem>
<simpara>
generate Javadoc and other reports
</simpara>
</listitem>
</itemizedlist>
<section id="_current_status">
<title>Current Status</title>
<simpara>Not all targets have been reached in the current version of Flaka (Release candidate 1). Programming tasks and EL are working fine and can be used. The other two pillars work partially but generally not recommended (yet) to be used.</simpara>
</section>
<section id="_where_to_go_from_here">
<title>Where to go from here?</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/downloads/list">Download</ulink> Flaka and read the <link linkend="installation">installation page</link>.
</simpara>
</listitem>
<listitem>
<simpara>
Have a look at the <link linkend="scripting">basic scripting elements</link> to get an overview of tasks, types and macros provided by Flaka. Have a closer look in the reference part of this manual for all the gory details of those tasks, types and macros.
</simpara>
</listitem>
<listitem>
<simpara>
Make sure to look into the chapter about the <link linkend="el">expression language</link>, it contains a lot of information on this enormous useful extension.
</simpara>
</listitem>
<listitem>
<simpara>
Start writing build scripts using Flaka and give <ulink url="mailto:flaka@haefelinger.it">feedback</ulink>.
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="_programming_constructs">
<title>Programming Constructs</title>
<simpara>This chapter provides an overview of programming constructs Flaka provides. This programming constructs are one of the Flaka&#8217;s pillars.</simpara>
<section id="_strings">
<title>Strings</title>
<simpara>Like Ant, Flaka supports currently strings and, when applicable, pointer to resources (by referencing a symbol). Ant provides no functionality manipulate a string value and neither does Flaka. However, Flaka&#8217;s expression language contains string functions to create new strings.</simpara>
</section>
<section id="_symbols">
<title>Symbols</title>
<simpara>Symbols are names carrying associated data. The name of a symbol is a sequence of characters. The allowed characters are basically unlimited. It is recommended to stick with well known characters [a-zA-Z0-9._-]. Symbols can be used as variables, target, task, type or macro names.</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>&lt;property name=sym value=expr /&gt;</literal> Use sym as variable: assign the value of <emphasis>expr</emphasis> to <emphasis>sym</emphasis>. <emphasis role="strong">A symbol associated with a string value is called a property</emphasis>. Notice that Ant and Flaka provide further ways of creating properties.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;macrodef name=sym&gt;</literal>  Use <emphasis>sym</emphasis> as macro name
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;target namesym&gt;</literal> Use <emphasis>sym</emphasis> as target name
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;taskdef name=sym&gt;</literal> Use <emphasis>sym</emphasis> as task name
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;typedef name=sym&gt;</literal> Use <emphasis>sym</emphasis> as type name
</simpara>
</listitem>
<listitem>
<simpara>
<literal>id=sym</literal> Use sym as reference: assign the evaluation of task (or macro) to <emphasis>id</emphasis>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_properties">
<title>Properties</title>
<simpara>To reference a property, enclose it&#8217;s symbol name with curly braces and prefix with the dollar character like:</simpara>
<screen>&lt;property name="x" value="99" /&gt;
&lt;echo&gt;
  value of property x is ${x}    -- .. is 99
&lt;/echo&gt;</screen>
<simpara></simpara>
<screen>&lt;property name="x" value="99" /&gt;
&lt;property name="x" value="The quick brown fox .."/&gt;
&lt;echo&gt;
  value of property x is ${x}    -- .. is 99
&lt;/echo&gt;</screen>
<simpara>It can be done using Flaka&#8217;s task <xref linkend="task_let"/> or <xref linkend="task_unset"/> as the following snippet demonstrates.</simpara>
<screen>&lt;property name="x" value="99" /&gt;
&lt;c:let&gt;
   x ::= "The quick brown fox .."
&lt;/c:let&gt;
&lt;echo&gt;
  value of property x is ${x}    -- .. is The quick brown ..
&lt;/echo&gt;</screen>
<simpara>Properties have their own symbol table (as targets, tasks, macros and types have). This means for example that it is possible to have a property and a task <emphasis>sharing</emphasis> the same symbol name:</simpara>
<screen>  &lt;property name="foobar" ../&gt;
  &lt;macrodef name="foobar" ../&gt;  -- property foobar not harmed!</screen>
</section>
<section id="_sequencing">
<title>Sequencing</title>
<simpara>To evaluate a sequence of expressions (tasks or macros) where only one expression is allowed, use <ulink url="http://ant.apache.org/manual/CoreTasks/sequential.html">Ant&#8217;s sequential task</ulink>:</simpara>
<screen> &lt;sequential&gt;
   -- any sequence of tasks or macros
 &lt;/sequential&gt;</screen>
<simpara>Note that <emphasis>sequential</emphasis> returns nothing. Use properties to communicate with the caller if necessary.</simpara>
</section>
<section id="_conditionals">
<title>Conditionals</title>
<simpara>With standard Ant, task <ulink url="http://ant.apache.org/manual/CoreTasks/condition.html">condition</ulink> is used to set a property if a condition is given. Then a macro, task or target can be conditionally executed  by checking the existence or absence of that property (using standard attributes <emphasis>if</emphasis> or <emphasis>unless</emphasis>. Flaka defines a couple of control structures to handle conditionals in a simpler way.</simpara>
</section>
<section id="_when_and_unless">
<title>when and unless</title>
<simpara>Task <xref linkend="task_when"/> evaluates an <xref linkend="el"/> expressio. If the evaluation gives <literal>true</literal>, the sequence of tasks are executed. Nothing else happens in case of <literal>false</literal>.</simpara>
<screen>&lt;c:when test=" expr "&gt;
   -- executed if expr evaluates to true
&lt;/c:when&gt;</screen>
<simpara>The logical negation of <literal>when</literal> is task <xref linkend="task_unless"/> which executes the sequence of tasks only in case the evaluation of <emphasis>expr</emphasis> returns <literal>false</literal>.</simpara>
<screen> &lt;c:unless test=" expr "&gt;
   -- executed if expr evaluates to false
 &lt;/c:unless&gt;</screen>
<simpara>The body of <literal>when</literal> and <literal>unset</literal> may contain any sequence of tasks or macros (or a combination of both).</simpara>
</section>
<section id="_choose">
<title>choose</title>
<simpara>Task <xref linkend="task_choose"/> tests each <literal>when</literal> condition in turn until an <emphasis>expr</emphasis> evalutes to <literal>true</literal>. It executes then the body of that when condition. Subsequent <literal>whens</literal> are then not further tested (nor executed). If all expressions evaluate to <literal>false</literal>, an optional <emphasis>catch-all</emphasis> clause gets executed.</simpara>
<screen> &lt;c:choose&gt;
  &lt;when test="expr_1"&gt;
    -- body_1
  &lt;/when&gt;
  ..
  &lt;otherwise&gt; -- optional_
    -- catch all body
  &lt;/otherwise&gt;
 &lt;c:/choose&gt;</screen>
</section>
<section id="_switch">
<title>switch</title>
<simpara>A programming task often seen is to check whether a (string) value matches a given (string) value. If so, a particular action shall be carried out. This can be done via a series of <emphasis>when</emphasis> statements. The nasty thing is to keep track of whether a value matched already. Flaka provides a handy task for this common scenario, the <xref linkend="task_switch"/> task:</simpara>
<screen> &lt;c:switch value=" 'some string' "&gt;
  &lt;matches re="regular expression or pattern" &gt;
    -- body_1
  &lt;/case&gt;
  ..
  &lt;otherwise&gt; -- optional
    -- catch all body
  &lt;/otherwise&gt;
 &lt;/c:switch&gt;</screen>
<simpara>Each case is tried in turn <emphasis>to match</emphasis> the string value (given as <xref linkend="el"/> expression). If a case matches, the appropriate case body is executed. If it happens that no case matches, then the optional default body is executed. To be of greater value, a regular expression or pattern expression can be used in a case condition.</simpara>
</section>
<section id="_repetition">
<title>Repetition</title>
<simpara>Flaka has a looping statement. Use task <xref linkend="task_for"/> to iterate over a <emphasis>list</emphasis> of items. Use <xref linkend="task_break"/> and <xref linkend="tasks_continue"/> to terminate the loop or to continue the loop with the next item.</simpara>
<screen> &lt;c:for var=" name " in=" ''.tofile.list "&gt;
    -- sequence of task or macros
    -- used &lt;c:continue /&gt; to continue ; and
    -- &lt;c:break /&gt; to stop looping
    -- use #{name} to refer to current item (as shown below)
    &lt;c:echo&gt;#{name}&lt;/c:echo&gt;
 &lt;/c:for&gt;</screen>
<simpara>Attribute <literal>in</literal> will be evaluated as <xref linkend="el"/> expression. In the example above, that <xref linkend="el"/> expression is <literal>''.tofile.list</literal> which, when evaluated, creates a list of all files in the folder containing the current build script. To understand the expression, have a look at <link linkend="el_string_properties">properties</link> of a string] and <link linkend="el_file_properties">properties</link> of a file.</simpara>
</section>
<section id="_exception_handling">
<title>Exception Handling</title>
<simpara>Flaka has been charged with exception handling tasks.</simpara>
</section>
<section id="_trycatch">
<title>trycatch</title>
<simpara>Flaka contains a task to handle exceptions thrown by tasks, <xref linkend="task_trycatch"/>. This task implements the usual <emphasis>try/catch/finally</emphasis> trinity found in various programming languages (like in Java for example):</simpara>
<screen> &lt;c:trycatch&gt;
   &lt;try&gt;
     -- sequence of task or macros
   &lt;/try&gt;
   &lt;catch&gt;
     -- sequence of task or macros
   &lt;/catch&gt;
   &lt;finally&gt;
     -- sequence of task or macros
   &lt;/finally&gt;
 &lt;/c:trycatch&gt;</screen>
<simpara>Element <emphasis>try</emphasis>, <emphasis>catch</emphasis> and <emphasis>finally</emphasis> are all optional or can appear multiple times. If <emphasis>catch</emphasis> is used without any argument, then that catch clause will match any <emphasis role="strong">build exception</emphasis>. To differentiate between different exception types, <emphasis>catch</emphasis> can additionally be used with a <emphasis>type</emphasis> and <emphasis>match</emphasis> argument. The former can be used to select a particular exception type (like a 'java.lang.NullPointerException), the latter can be used to select an exception based on the message carried. Both arguments are interpreted as pattern expression. For example:</simpara>
<screen> &lt;c:trycatch&gt;
   &lt;try&gt;
      ..
      &lt;fail message="#PANIC!" unless="ant.file"/&gt;
      ..
   &lt;/try&gt;
   &lt;catch match="*#PANIC!*"&gt;
      &lt;echo&gt;Ant initialization problem!!&lt;/echo&gt;
      &lt;fail/&gt;
   &lt;catch type="java.lang.*"&gt;
     -- handle Java runtime problems
   &lt;/catch&gt;
   &lt;catch&gt;
     -- handle all other build exceptions
   &lt;/catch&gt;
  &lt;/c:trycatch&gt;</screen>
<simpara>Property <emphasis>ant.file</emphasis> is a standard Ant property that should always be set. If not, there&#8217;s something seriously wrong and it does not make much sense to continue. Use attribute <emphasis>type</emphasis> to catch (runtime) exceptions thrown by the underlying implementation.</simpara>
</section>
<section id="_throw">
<title>throw</title>
<simpara>Task <xref linkend="task_throw"/> throws a (build) exception.</simpara>
<screen> &lt;c:throw [var="sym"] /&gt;</screen>
<simpara>This task can also be used to rethrow an existing exception.</simpara>
</section>
<section id="_macros">
<title>Macros</title>
<simpara>The (almost) equivalent of a function is a macro in Ant and Flaka. For example:</simpara>
<screen> &lt;macrodef name="hello"&gt;
  &lt;attribute name="msg" /&gt;
  &lt;element name="body" implicit="true" /&gt;
  &lt;sequential&gt;
   &lt;body /&gt;
  &lt;/sequential&gt;
 &lt;/macrodef&gt;</screen>
<simpara>Once defined, simply use it:</simpara>
<screen>&lt;hello msg="Hello, world!"&gt;
 &lt;echo&gt;@{msg}&lt;/echo&gt;
&lt;/hello&gt;</screen>
<simpara>This macro evaluates into</simpara>
<screen> &lt;echo&gt;Hello, world!&lt;/echo&gt;</screen>
<simpara>which eventually prints the desired greeting.</simpara>
<simpara>Macros are a standard feature of Ant.</simpara>
</section>
</section>
<section id="el" xreflabel="EL">
<title>EL, The Expression Language</title>
<simpara>The <ulink url="http://en.wikipedia.org/wiki/Unified_Expression_Language">Java Unified Expression Language</ulink> <ulink url="http://www.jcp.org/en/jsr/detail?id=245">(JSR-245)</ulink> is a special purpose programming (albeit not turing complete) language offering a simple way of accessing data objects. The language has its roots in Java web applications for embedding expressions into web pages. While the expression language is part of the JSP specification, it does in no way depend on the JSP specification. To the contrary, the language can be made available in a variety of contexts.</simpara>
<simpara>One such context is Ant scripting. Ant makes it difficult to access data objects. For example, there is no way of querying the underlying data object for the base folder (the folder containing the build script). All that Ant offers is the path name of this folder as <emphasis>string</emphasis> object. This makes it for example rather cumbersome to report the last modification time of this folder. With the help of EL (short for <emphasis>Unified Expression Language</emphasis>) this becomes an easy task:</simpara>
<screen>&lt;c:echo&gt;
  ;; basedir is a standard Ant property
  basedir is ${basedir}

  ;; report last modification time (as Date object)
  was last modified at #{ '${basedir}'.tofile.mtime }

  ;; dump the full name of this build file
  ;; where 'ant.file' is a standard property
  this is #{property['ant.file'] } reporting!
&lt;/c:echo&gt;</screen>
<simpara>Being executed, this snippet produces something like</simpara>
<screen>[c:echo] basedir is /projects/flaka/test
[c:echo]
[c:echo] was last modified at Mon Mar 09 13:52:29 CET 2009
[c:echo]
[c:echo] this is /projects/flaka/test/tryme.xml reporting!</screen>
<simpara>as output. Notice that Flaka's <xref linkend="task_echo"/> task has been used for this illustration because <xref linkend="el"/> is by default only available on Flaka tasks. If <ulink url="http://ant.apache.org/manual/CoreTasks/echo.html">Ant's standard echo task</ulink> is used, all <literal>#{..}</literal> constructs are left as they are. It is however possible and recommended to turn <xref linkend="el"/> on for <emphasis>all</emphasis> tasks. See <link linkend="el_enable_el">how to enable EL</link> for details.</simpara>
<simpara>The next code example shows another <emphasis>EL in action</emphasis> sample. The programming problem is to list all unreadable (sub)folders in a certain folder - here being the <emphasis>root</emphasis> folder:</simpara>
<screen>&lt;c:let&gt;
  ; the root folder as file object
  root = '/'.tofile
  ; create empty list
  list = list()
&lt;/c:let&gt;

&lt;c:for var="file" in=" root.list "&gt;
  &lt;c:when test=" file.isdir and not file.isread "&gt;
    &lt;c:let&gt;
      list = append(file,list)
    &lt;/c:let&gt;
  &lt;/c:when&gt;
&lt;/c:for&gt;

&lt;c:echo&gt;
  ;; how many unreadable directories ??
  There are #{size(list)} unreadable directories in #{root}.
  And here they are #{list}.
&lt;/c:echo&gt;</screen>
<simpara>Executed on MacOS 10.5.6 (aka "Leopard") gives:</simpara>
<screen>[c:echo] There are 2 unreadable directories in /.
[c:echo] And here they are [/.Trashes, /.Spotlight-V100].</screen>
<section id="el_ready_tasks">
<title>EL Ready Tasks</title>
<simpara>By default can EL expressions can only be used in tasks which are EL aware. This tasks are:</simpara>
<itemizedlist>
<listitem>
<simpara>
<xref linkend="task_echo"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="task_for"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="task_let"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="task_properties"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="task_unless"/>
</simpara>
</listitem>
<listitem>
<simpara>
<xref linkend="task_when"/>
</simpara>
</listitem>
</itemizedlist>
<simpara>It is possible though to enable <xref linkend="el"/> on a global level, i.e. for all tasks.</simpara>
</section>
<section id="el_enabling_el">
<title>Globally Enabling EL</title>
<simpara>To enable handling of EL references on a global level on all tasks, types or  macros and vector independent, use task <xref linkend="task_install_property_handler"/>:</simpara>
<screen>&lt;c:install-property-handler /&gt;</screen>
</section>
<section id="el_references">
<title>EL References</title>
<simpara>Those <emphasis>not</emphasis> familiar with the specification of <ulink url="http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf">EL</ulink>, <ulink url="http://en.wikipedia.org/wiki/JavaServer_Pages">JSP</ulink> or <ulink url="http://en.wikipedia.org/wiki/JavaServer_Faces">JSF</ulink> may safely skip this section. All other please read on, cause the implementation of EL has slightly be changed <footnote><simpara>EL has its roots in the context of Java Web Development and some specification details do not make sense when EL is used in a different domain content</simpara></footnote>.</simpara>
<simpara>For those familiar, the <emphasis>term EL expression</emphasis> is used in a slightly different way in this documentation than in the specification. According to the specification, <literal>#{..}</literal> is an EL expression.</simpara>
<simpara>Not so in this documentation. Here only the inner part, denoted by <literal>..</literal> is a <emphasis>EL expression</emphasis> while <literal>#{ ..}</literal> is considered a <emphasis>reference to an EL expression</emphasis>. A reference to an expression is used in contexts which are partially evaluated. Take task <xref linkend="task_echo"/> as example. Clearly, when writing</simpara>
<screen>&lt;c:echo&gt;
 I said 'Hello world'!
&lt;/c:echo&gt;</screen>
<simpara>we expect an output exactly as written. It would be nice to indicate however, that we want to have a part of the input evaluated as EL expression. This and only this is what <literal>#{..}</literal> is good for:</simpara>
<screen>&lt;c:let&gt;
 what = 'Hello world'
&lt;/c:let&gt;

&lt;c:echo&gt;
 I said '#{ what }'!
&lt;/c:echo&gt;</screen>
<simpara>In other contexts, like in <literal>&lt;c:when test=" condition " /&gt;</literal>, a EL expression is expected anyway and it does not make the slightest sense to require the expression to be referenced. As an example, assume that we want to check whether a property named <emphasis>foobar</emphasis> exists. Instead of writing</simpara>
<screen>&lt;c:when test=" #{has.property['foobar']} " /&gt;   -- don't!</screen>
<simpara>as seen in popular JSP tag libraries, just write</simpara>
<screen>&lt;c:when test=" has.property['foobar'] " /&gt;   -- yes!!!</screen>
<simpara>And forget about that unnecessary clutter.</simpara>
<simpara>Notice however, that in all contexts where a expression is expected, a expression reference can be used. This allows for advanced meta programming like shown in the following example:</simpara>
<screen>&lt;c:when test=" has.property['#{propertyname}'] " /&gt;   -- sic!</screen>
</section>
<section id="_handling_of_literal_literal">
<title>Handling of <literal>${..}</literal></title>
<simpara><emphasis>EL</emphasis> defines two types of references:</simpara>
<itemizedlist>
<listitem>
<simpara>
<emphasis role="strong">deferred</emphasis>, indicated by <literal>#{..}</literal> ; and
</simpara>
</listitem>
<listitem>
<simpara>
<emphasis role="strong">dynamic</emphasis>, indicated by <literal>${..}</literal>
</simpara>
</listitem>
</itemizedlist>
<simpara>Dynamic references <literal>${..}</literal> are handled by Ant to resolve properties. There are two execptions to this however. Ant will leave a dynamic reference as is if the reference value does not denote a (existing) property. Secondly, Ant allows to escape a reference by by doubling character <literal>$</literal> as in <literal>$${a}</literal>. In any case, <literal>${..}</literal> does not denote a legal EL reference and will be left as is. Be aware that you can install a property handler to get rit of unresolved <literal>${..}</literal> property references.</simpara>
</section>
<section id="_handling_of_literal_literal_2">
<title>Handling of <literal>#{..}</literal></title>
<simpara>Deferred references <literal>#{..}</literal> are evaluated according to regular EL rules. Each reference is evaluated independently. Thus</simpara>
<screen> The #{ 'Good' }, the Bad and the #{ 'Ug' 'ly' }, a well known #{ 'movie' }.</screen>
<simpara>Would print</simpara>
<screen> The Good, the Bad and the , a well known movie.</screen>
<simpara>cause the second reference is illegal. Notice however that all valid references are evaluated.</simpara>
</section>
<section id="_nested_references">
<title>Nested References</title>
<simpara>Nested references are not supported. The following reference is therefore illegal</simpara>
<screen> #{ item[ #{index} ] }</screen>
</section>
<section id="_the_great_escape">
<title>The Great Escape</title>
<simpara>This section is about how to stop a EL reference from being evaluated and treated as text instead:</simpara>
<itemizedlist>
<listitem>
<simpara>
Use character backslash like in <literal>\#{abc}</literal> ; or use this rather awkward
</simpara>
</listitem>
<listitem>
<simpara>
<literal>#{'#{'}abc}</literal> construct.
</simpara>
</listitem>
</itemizedlist>
<simpara>Both variants have the same result, the string <literal>#{abc}</literal>.</simpara>
</section>
<section id="_gory_el_details">
<title>Gory EL Details</title>
<simpara>The gory details of <emphasis>EL</emphasis> are laid out in the <ulink url="http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf">the official JSR 245 specification</ulink> and are not repeated here. In short however, <emphasis>EL</emphasis> let&#8217;s you formulate <ulink url="http://en.wikipedia.org/wiki/Expression_(programming)">programming expressions</ulink> like</simpara>
<screen>  7 * (5.0+x) &gt;= 0        ;; 1
  a and not (b || false)  ;; 2
  empty x ? 'foo' : x[0]  ;; 3</screen>
<simpara>The expression in line (1) is a algebraic while (2) contains a boolean expression. The result of (1) depends on the resolution of variable <literal>x</literal> and similar does (2) on <literal>a</literal> and <literal>b</literal>. Line (3) shows the usage of two built-in <link linkend="el_operators">operators (see below for details)</link>.</simpara>
<simpara>The rest of this chapter introduces relevant details of EL in order to use it within Flaka.</simpara>
</section>
<section id="_data_types">
<title>Data Types</title>
<simpara><emphasis>EL</emphasis>'s data types are integral and floating point numbers, strings, boolean and type <literal>null</literal>. Example data values of each type, except type <literal>null</literal>, are given above (1-3). Type <literal>null</literal> has once instance value also named <literal>null</literal>. While <literal>null</literal> can&#8217;t be used to formulate an expression, it is important to understand that the result of evaluating an expression can be <literal>null</literal>. For example, the evaluation of a variable named <literal>x</literal> is the data object associated with that name. If no data is associcated however (i.e. if <literal>x</literal> is undefined), then <literal>x</literal> evaluates to <literal>null</literal>.</simpara>
</section>
<section id="_strings_2">
<title>Strings</title>
<simpara>A EL string starts and ends with the same quotation character. Possible quotation characters are single the quote <literal>'</literal> and double quote <literal>"</literal> character. If string uses <literal>'</literal> as quotation character, then there is no need to <emphasis>escape</emphasis> quoation character <literal>"</literal> within that string. Thus the following strings are valid:</simpara>
<screen> "a'b"   --&gt; a'b
 'a"b'   --&gt; a"b</screen>
<simpara>If however the string&#8217;s quotation character is to be used within the string, then the quoation character needs to be escaped from it&#8217;s usual meaning. This is done by prepending character backslash:</simpara>
<screen> "a\"b"  --&gt; a"b
 'a\'b'  --&gt; a'b</screen>
<simpara>To escape the backslash character from it&#8217;s usual meaning (escaping that is), escape the backslash character with a backslash:</simpara>
<screen> "a\\"   --&gt; a\
 'a\\'   --&gt; a\</screen>
<simpara>Other characters than the quotation and backslash character can&#8217;t be escaped. Thus</simpara>
<screen> "a\bc"  --&gt; a\bc, NOT abc</screen>
<simpara>However, a escaped backslash evaluates always into a single backslash character:</simpara>
<screen> "a\\b"  --&gt; a\b,  NOT a\\b</screen>
<simpara>This rules allow for an easy handling of strings. Just take an quoation character. Then, escape any occurences of the quoation and escape character within the string to preserve the original input string.</simpara>
<simpara>Here are same further examples strings:</simpara>
<screen>"abc"        -- abc
'abc'        -- abc
"a'c'        -- illegal
"a'c"        -- a'c
'a\'c'       -- a'c
'a\bc'       -- a\bc
'a\\bc'      -- a\\bc
'a\"bc'      -- a\"bc
'a\\"bc'     -- a\\"bc
'ab\'        -- illegal
'ab\\'       -- ab\</screen>
</section>
<section id="el_operators">
<title>Operators</title>
<simpara>Four <emphasis>operators</emphasis> are defined in <emphasis>EL</emphasis>:</simpara>
<orderedlist numeration="arabic">
<listitem>
<simpara>
<literal>empty</literal> checks whether a variable is empty or not and returns either <literal>true</literal> or <literal>false</literal>. It is important to understand that <literal>null</literal> is considered empty.
</simpara>
</listitem>
<listitem>
<simpara>
condition operator <literal>c ? a : b</literal> evaluates <literal>c</literal> in a boolean context and returns the evaluation of expression <literal>a</literal> if <literal>c</literal> evaluates to <literal>true</literal>; otherwise <literal>eval(b)</literal> will be the result of this operator.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>.</literal> and ;
</simpara>
</listitem>
<listitem>
<simpara>
<literal>[]</literal> are property operators described in <link linkend="el_properties">section <emphasis>Properties</emphasis></link> below.
</simpara>
</listitem>
</orderedlist>
</section>
<section id="el_properties">
<title>Properties</title>
<simpara>Every data object in <emphasis>EL</emphasis> may have properties associated. Which properties are available has not been standardized in the <ulink url="http://flaka.googlecode.com/files/jsp-2_1-fr-spec-el.pdf">specification</ulink>. In fact, this depends heavily on the underlying implementation and usage domain. What <emphasis>EL</emphasis> specifies however, is how to query a property:</simpara>
<screen>a.b.c</screen>
<simpara>This expression can be translated into pseudo code as</simpara>
<screen> (property 'c' (property 'b' (eval a)))</screen>
<simpara>which means that first variable <literal>a</literal> is evaluted, then property <literal>b</literal> is looked up on the evaluation result (giving a new evaluation result) and finally <literal>c</literal> is looked up giving the final result.</simpara>
<simpara>Perhaps the most important point to notice is looking up a property on <literal>null</literal> is not an error but perfectly legal. No exception gets raised and no warning message generated. In fact, the result of such a operation is just <literal>null</literal> again.</simpara>
<simpara>From a practial point a question might be asked how to query a property which happens to contain the dot (<literal>.</literal>) character. In <literal>a.b.c</literal> example shown above, how would we lookup property <literal>b.c</literal> on <literal>a</literal>? Operator <literal>[]</literal> comes to rescue:</simpara>
<screen> a['b']        =&gt; a.b
 (a['b'])['c'] =&gt; a.b.c
 a['b']['c']   =&gt; a.b.c
 a[b]          =&gt; can't be expressed using '.'
 a[b.c]        =&gt; neither this ..
 a['b.c']      =&gt; query property 'b.c' on a</screen>
<simpara>So far, properties don&#8217;t seem of any good use. The picture changes perhaps with this example:</simpara>
<screen> 'abc'.toupper           =&gt; 'ABC'
 'abc'.length*4          =&gt; 12
 'abc'['tofile'].mkdir   =&gt; true/false</screen>
<simpara>The last example demonstrates that there might also be <ulink url="http://en.wikipedia.org/wiki/Side_effect_(computer_science)">side effects</ulink> querying a property. In the example above, which is specific for Flaka, a directory <literal>abc</literal> gets created and the whole expression evaluates to <literal>true</literal> if the directory could get created and <literal>false</literal> otherwise.</simpara>
<simpara>See further down which properties are available on various data types.</simpara>
</section>
<section id="el_implicit_objects">
<title>Implicit Objects</title>
<simpara>Properties are good to query the state of data objects. The question is however, how do we get a data object to query in the first place? To start with <emphasis>something</emphasis>, <xref linkend="el"/> allows the implementation to provide <emphasis>implicit</emphasis> objects and <link linkend="el_functions">top level functions (see below)</link>.</simpara>
<simpara>The following implicit objects are defined by Flaka:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="15*"/>
<colspec colname="col_3" colwidth="70*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Implicit Object</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>name</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>If <emphasis>name</emphasis> is not a predefined name as listed in the rest of this table, then <emphasis>name</emphasis> will be the same as <literal>var[name]</literal>, i.e. <emphasis>name</emphasis> will resolve to the object associated with variable <emphasis>name</emphasis>.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>project</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>Ant&#8217;s underlying project object. It can be used to query the default target, base folder and other things. If you want to query properties, references, targets, tasks, taskdefs, macrodefs, filters etc., use appropriate implicit object instead.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>property</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>Use this object to query project properties.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>var</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>A object containing all project references.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>reference</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>var</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>target</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>Use this object to query a target</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>taskdef</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>Query taskdefs</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>macrodefs</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>Macros</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>tasks</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>Either taskdef or macrodef. Macros are specialized task and thus same the same namespace.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>filter</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>A object containing all filters defined in this project.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>e</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>The mathematical <ulink url="http://en.wikipedia.org/wiki/E_(mathematical_constant)">constant e</ulink>, also known as <ulink url="http://en.wikipedia.org/wiki/Euler">Euler</ulink>'s number.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>pi</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>The  mathematical <ulink url="http://en.wikipedia.org/wiki/P">constant pi</ulink></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>An example for an EL expression fetching property <literal>foo</literal> is:</simpara>
<screen>property.foo
project.properties.foo</screen>
<simpara>Similar, a variable named <literal>foo</literal> is fetched like</simpara>
<screen>foo                     -- (1)
var.foo                 -- (2)
reference.foo           -- (3)
project.references.foo  -- (4)</screen>
</section>
<section id="el_functions">
<title>Functions</title>
<simpara><emphasis>EL</emphasis> also allows the implementation to provide top level functions. The following sections describe functions provided by Flaka. Some functions take an arbitrary number of arguments (inclusive no argument at all). This is denoted by two dots (<literal>..</literal>). An example of such a function is <literal>list(object..)</literal> which takes an arbitrary number of object to create a list.</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="25*"/>
<colspec colname="col_2" colwidth="10*"/>
<colspec colname="col_3" colwidth="65*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Function</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Meaning</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>typeof(object)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>The type of <literal>object</literal>, <literal>int</literal>, <literal>string</literal>, <literal>file</literal> etc</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>size(object)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>Returns the object&#8217;s size. The size of the object is given by the number of entities it contains. This is 0 (zero) for all primitive types. Otherwise the size is determined by an underlying <literal>size()</literal> method or <literal>size</literal> or <literal>length</literal> attribute of the object in question.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>sizeof(object)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>same as <literal>size(object)</literal>, see above</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>null(object)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>Evaluates to <literal>true</literal> if object is the <literal>nil</literal> entity; otherwise <literal>false</literal>. This function can be used to check whether a reference (var) or property exists. Operator <literal>empty</literal> can&#8217;t be used for this task, cause <literal>empty</literal> returns <literal>true</literal> if either not existing or if literatly <emphasis>empty</emphasis> (for example the empty string).</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>file(object)</literal></simpara></entry>
<entry align="left" valign="top"><simpara>File</simpara></entry>
<entry align="left" valign="top"><simpara>Creates and returns a file object out of <literal>object</literal>. If <literal>object</literal> is already a file, the object is simply returned. Otherwise, the object is streamed into a string and that string is taken as the file&#8217;s path name.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>concat(object..)</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>Creates a string by concatenating all stringized objects. If no object is provided, the empty string is returned.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>list(object..)</simpara></entry>
<entry align="left" valign="top"><simpara>list</simpara></entry>
<entry align="left" valign="top"><simpara>Returns a list where the list&#8217;s elements consists of the objects provided. If no objects are provided, the empty list is returned.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>append(object..)</simpara></entry>
<entry align="left" valign="top"><simpara>list</simpara></entry>
<entry align="left" valign="top"><simpara>This function is similar to <literal>list</literal>. It takes the objects in order and creates a list elements out of them. If a object is a list, then elements of that list are inserted instead of the list object itself. For example <literal>append('a,list('b'),'c')</literal> evaluates to list <literal>('a','b','c')</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Some mathematical functions are defined as well:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="15*"/>
<colspec colname="col_3" colwidth="65*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>sin(double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>The mathematical <ulink url="http://en.wikipedia.org/wiki/Trigonometric_functions">sine</ulink> function</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>cos(double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>The mathematical <ulink url="http://en.wikipedia.org/wiki/Trigonometric_functions">cosine</ulink> function</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>tan(double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>The mathematical <ulink url="http://en.wikipedia.org/wiki/Trigonometric_functions">tangent</ulink> function</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>exp(double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>The mathematical exponential function, <literal>e</literal> raised to the power of the given argument</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>log(double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>The mathematical logarithm function of base <literal>e</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>pow(double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>Returns the value of the first argument raised to the power of the second argument.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>sqrt(double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>Returns the correctly rounded positive square root of a double value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>abs(double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>Returns the absolute value of a double value.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>min(double, double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>Returns the smaller of two double values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>max(double, double)</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>Returns the larget of two double values.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>rand()</simpara></entry>
<entry align="left" valign="top"><simpara>double</simpara></entry>
<entry align="left" valign="top"><simpara>Returns a double value with a positive sign, greater than or equal to 0.0 and less than 1.0.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_available_properties">
<title>Available Properties</title>
<simpara>In general properties are mapped as <emphasis>attribute</emphasis> on the underlying data object. In Java, every <emphasis>getX</emphasis> method taking no arguments identifies property <emphasis>x</emphasis>. As an example, assume that we have</simpara>
<screen>public class Foo {
 public .. getBar() { .. }
}</screen>
<simpara>then an data object of type <emphasis>Foo</emphasis> will have property <emphasis>bar</emphasis> and thus the following expression <literal>x.bar</literal> would eventually call <literal>Foo.getBar()</literal> assuming that <literal>x</literal> evaluates to an object of type <literal>Foo</literal>. Such properties are the <emphasis role="strong">natural</emphasis> properties of a type.</simpara>
</section>
<section id="_primitve_types">
<title>Primitve Types</title>
<simpara>Primite data types (int, double, bool, null) have no properties.</simpara>
</section>
<section id="_list_and_arrays">
<title>List and Arrays</title>
<simpara>Besides their <emphasis>natural</emphasis> properties (see discussion above) are <emphasis>index</emphasis> properties available:</simpara>
<screen>list('a','b')[1]  =&gt; 'b'</screen>
<simpara>Negative indexes are currently not supported. If an index is specfies an not existing element, <literal>null</literal> is returned.</simpara>
</section>
<section id="el_string_properties">
<title>String Properties</title>
<simpara>Besides <emphasis>natural</emphasis> properties (see discussion above) are the following properties supported:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="15*"/>
<colspec colname="col_3" colwidth="70*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Property</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>length</simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>number of characters in this string</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>size</simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>same as property <literal>length</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>tolower</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>return this string in lowercase characters only</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>toupper</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>return this string in uppercase characters only</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>trim</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>remove leading and trailing whitespace characters</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>tofile</simpara></entry>
<entry align="left" valign="top"><simpara>file</simpara></entry>
<entry align="left" valign="top"><simpara>create a file based on this string; the so created will be relative to the current build file&#8217;s base folder if the string&#8217;s value does not denote a absolute path. Furthermore, the empty string will create a file object denoting the project&#8217;s base folder (i.e. the folder containing the build script currently executed). Notice that <literal>.</literal> and <literal>..</literal> denote absolute paths, not relative ones.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="el_file_properties">
<title>File Properties</title>
<simpara>Files and folders is Ant&#8217;s bread and butter. A couple of properties are defined on file objects to simplify scripting (see below). Most important is however how to <emphasis>get</emphasis> a file object in the first place. This is most easily done by using string property <literal>tofile</literal>:</simpara>
<screen>  'myfolder'.tofile.isdir</screen>
<simpara>In this example of an EL expression, string <literal>myfolder</literal> is converted in a File object using property <literal>tofile</literal>. In addition, the so created object is checked whether it is a folder or not.</simpara>
<simpara>The following <emphasis>properties</emphasis> are defined on File objects:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="15*"/>
<colspec colname="col_3" colwidth="70*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Property</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>parent</literal></simpara></entry>
<entry align="left" valign="top"><simpara>File</simpara></entry>
<entry align="left" valign="top"><simpara>parent of file or folder as file object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>toabs</literal></simpara></entry>
<entry align="left" valign="top"><simpara>File</simpara></entry>
<entry align="left" valign="top"><simpara>file or folder as absolute file object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>exists</literal></simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>check whether file or folder exists</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>isfile</literal></simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>check whether a file</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>isdir</literal></simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>check whether a folder (directory)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>ishidden</literal></simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>check whether a hidden file or folder</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>isread</literal></simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>check whether a file or folder is readable</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>iswrite</literal></simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>check whether a file or folder is writable</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>number of bytes in a (existing) file; 0 otherwise</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>length</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>same as <literal>size</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mtime</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Date</simpara></entry>
<entry align="left" valign="top"><simpara>last modification date</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>list</literal></simpara></entry>
<entry align="left" valign="top"><simpara>File</simpara></entry>
<entry align="left" valign="top"><simpara>array of files in folder ; otherwise <literal>null</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tostr</literal></simpara></entry>
<entry align="left" valign="top"><simpara>String</simpara></entry>
<entry align="left" valign="top"><simpara>file name as string object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>touri</literal></simpara></entry>
<entry align="left" valign="top"><simpara>URI</simpara></entry>
<entry align="left" valign="top"><simpara>file as URI object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>tourl</literal></simpara></entry>
<entry align="left" valign="top"><simpara>URL</simpara></entry>
<entry align="left" valign="top"><simpara>file as URL object</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>delete</literal></simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>deletes the file or folder (true); false otherwise</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>mkdir</literal></simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>creates the folder (and intermediate) folders (true); false otherwise</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_matcher_properties">
<title>Matcher Properties</title>
<simpara>A <emphasis>matcher object</emphasis> is created by task <xref linkend="task_switch"/> if a regular expression matches a input value. Such a matcher object contains details of the match like the start and end position, the pattern used to match and it allows to explore details of capturing groups (also known as _marked subexpression).</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="15*"/>
<colspec colname="col_3" colwidth="70*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Property</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>start</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>The position within the input where the match starts.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>s</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>start</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>end</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>The position within the input where the match ends (the character at <literal>end</literal> is the last matching character)</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>e</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>end</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>groups</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>The number of capturing groups in the (regular) expression.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>size</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>groups</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>length</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>groups</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>n</literal></simpara></entry>
<entry align="left" valign="top"><simpara>int</simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>groups</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>pattern</literal></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>The regular expression that was used for this match. Notice that glob expressions are translated into regular expressions.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>p</literal></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>pattern</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>i</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>matcher</simpara></entry>
<entry align="left" valign="top"><simpara>The matcher object for <emphasis>i</emphasis>'th capturing group. See task <xref linkend="task_switch"/> for examples.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_evaluating_in_a_boolean_context">
<title>Evaluating in a boolean context</title>
<simpara>When evaluation a expr in a string context, a string representation of the final object is created. Similar, when a evaluation in a boolean context takes place, a conversion into a boolean value of the evaluated object takes place. The following table describes this boolean conversion:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="15*"/>
<colspec colname="col_3" colwidth="70*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>evaluated object type</simpara></entry>
<entry align="left" valign="top"><simpara><literal>true</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>file</simpara></entry>
<entry align="left" valign="top"><simpara>if the file exists</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal> otherwise</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>if string is empty</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal> otherwise</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>null</simpara></entry>
<entry align="left" valign="top"><simpara>never</simpara></entry>
<entry align="left" valign="top"><simpara>always</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>boolean</simpara></entry>
<entry align="left" valign="top"><simpara>if true</simpara></entry>
<entry align="left" valign="top"><simpara>otherwise</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><emphasis>other</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>always</simpara></entry>
<entry align="left" valign="top"><simpara>never</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
</section>
<section id="_part_ii">
<title>Part II</title>
<simpara>Each of the following chapters describes a task in all it's details.</simpara>
</section>
<section id="task_echo" xreflabel="echo">
<title>echo</title>
<simpara>Ant has an echo task to dump some text on a screen or into a file. A problem with this task is, that the output produced is rather fragile when it comes to reformatting your XML source. Here is a simple example.</simpara>
<screen>&lt;echo&gt;foobar&lt;/echo&gt;</screen>
<simpara>When executed by Ant, this dumps</simpara>
<screen>[echo] foobar</screen>
<simpara>However, one day you reformat your XML build file <footnote><simpara><ulink url="http://xmlsoft.org/xmllint.html">xmlint</ulink> is a good choice</simpara></footnote> and you end up in</simpara>
<screen>&lt;echo&gt;
...foobar
&lt;/echo&gt;</screen>
<simpara>Notice the usage of character <literal>.</literal> (dot) in this example and the rest of this (and only this) chapter to visualize a <emphasis>space</emphasis> <footnote><simpara>Also known as <emphasis>blank</emphasis> character</simpara></footnote> character. If you execute this, you will get</simpara>
<screen>[echo]
[echo] ...foobar
[echo]</screen>
<simpara>This is definitly not what you had in mind.</simpara>
<simpara>Task <literal>&lt;c:echo/&gt;</literal> is an extension of Ant's standard <literal>echo</literal> task. That standard task is used for doing all that low level work, i.e. dumping text on streams on loggers. On top of it, some features have been implemented intented to generate nicly formatted output.</simpara>
<simpara>Here is the <literal>foobar</literal> example again:</simpara>
<screen>&lt;c:echo&gt;

  foo\
  bar
  ; supports continuation and \
  comment lines
&lt;/c:echo&gt;</screen>
<simpara>This would output</simpara>
<screen>[c:echo] foobar</screen>
<simpara>which I believe is just what you had in mind.</simpara>
<section id="_attributes">
<title>Attributes</title>
<simpara>This tasks supports all attributes inherited from Ant&#8217;s echo task. In addition, further supported attributes are:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="15*"/>
<colspec colname="col_3" colwidth="15*"/>
<colspec colname="col_4" colwidth="55*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Attribute</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>debug</literal></simpara></entry>
<entry align="left" valign="top"><simpara>boolean</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Enables additional debug output for this particular task.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>comment</literal></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows for comments.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>shift</literal></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>``</simpara></entry>
<entry align="left" valign="top"><simpara>Allows to prefix each line with <literal>shift</literal> characters. See also Behaviour below.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Notice that <emphasis role="strong">debug</emphasis> output will be written on stream <literal>stderr</literal> regardless whether <literal>debug</literal> has been globally enabled on Ant or not. Also standard Ant loggers and listeneres are ignored. The default value is <literal>false</literal>, i.e. no additional output is created.</simpara>
<simpara>The trimmed <emphasis role="strong"><literal>comment</literal></emphasis> attribute value is used to construct a regular expression like <literal>^\s*\Q&lt;&lt;comment&gt;&gt;\E</literal>. Every line matching this regular expression will not show up in the output. Notice that the comment value given does not allow for regular expression meta characters. Thus something like <literal>(;|#)</literal> does <emphasis>not</emphasis> mean either <literal>;</literal> or <literal>#</literal>. Instead it means that a line starting with <literal>(;#)</literal> is ignored from output. By default, lines starting with character <literal>;</literal> - like in Lisp - are ignored.</simpara>
</section>
<section id="_elements">
<title>Elements</title>
<simpara>This task optionally accepts implicit text. That text may contain Ant property <literal>${..}</literal> or <xref linkend="el"/> <literal>#{..}</literal> references.</simpara>
</section>
<section id="_behaviour">
<title>Behaviour</title>
<simpara><emphasis role="strong">Continuation Lines</emphasis> are lines where the last character before the line termination character is the backslash character. Such a line is continued, i.e. the line will be merged with the next one (which could also be a continuation line).</simpara>
<simpara>A (merge continuation) line starting with an arbitrary number of whitespace characters followed by the characters given in attribute <literal>comment</literal> is a <emphasis role="strong">comment line</emphasis>. Such lines are removed from output. The characters given are taken literaly and have no meta character functionality. To disable comment lines altogether use an empty string <footnote><simpara>A string consisting only of whitespace characters</simpara></footnote>.</simpara>
<simpara>To allow a <emphasis role="strong">decent formatting</emphasis> unnecessary whitespace characters are removed. The process is illustrated <footnote><simpara>Again character dot <literal>.</literal> is used to illustrate a whitespace character with the exception of line ending characters</simpara></footnote> using the introduction example used above:</simpara>
<screen>&lt;c:echo&gt;

..foo\
..bar
&lt;/c:echo&gt;</screen>
<simpara>In a first step is the first non-whitespace character determined. In the example above, this is character <literal>f</literal>. From there Flaka counts backwards until a line termination character or the begin of input is reached. The counted number is the amount of whitespace characters stripped from the begin of each line. If a line starts with less than that amount of whitespace characters, then only those available are removed. Additionally, all whitespace characters before the first non-whitespace character are removed from the input.</simpara>
<simpara>There are two whitespace characters before <literal>foo\</literal>. If support for continuation lines would have been disabled, Flaka would dump the following:</simpara>
<screen>[c:echo] foo\
[c:echo] bar</screen>
<simpara>Handling of continuation lines takes place <emphasis role="strong">after</emphasis> whitespace has been stripped. Thus Flaka prints</simpara>
<screen>[c:echo] foobar</screen>
<simpara>as shown in the introduction example. A slight variation of the example above is given next:</simpara>
<screen>&lt;c:echo&gt;

..foo\
.bar
...indended by one character, right?
&lt;/c:echo&gt;</screen>
<simpara>Notice that in front of <literal>bar</literal> is only one whitespace character while there are three in the line after. What will be Flaka&#8217;s output?</simpara>
<screen>[c:echo] foobar
[c:echo] .indended by one character, right?</screen>
<simpara>As you can see, no more than the initial counted amount of whitespace is removed from each line.</simpara>
<simpara>However, assume that you really want to have a couple of empty lines dumped before any real content. How can this be done. There are two options. Firstly you can always fall back to use Ant&#8217;s standard <literal>echo</literal> task. Secondly, you can use a comment line like shown next</simpara>
<screen>&lt;c:echo&gt;
..; two empty lines following


..foobar
&lt;/c:echo&gt;</screen>
<simpara>which would dump:</simpara>
<screen>[c:echo]
[c:echo]
[c:echo] foobar</screen>
<simpara>This all works because comment lines are removed from the input <emphasis role="strong">after</emphasis> the position of the first non-whitespace character gets determined. It obviously means that this kind of comments do matter and can&#8217;t simply be stripped off. They may carry some semantics, so it&#8217;s probably best to avoid this kind of trick. Make use of it when approbriate.</simpara>
<simpara>We have seen how to force leading empty lines in the example above. What needs to be done if some leading whitespace is intended? Again there are two options. First you may attack the problem using the comment line trick:</simpara>
<screen>&lt;c:echo&gt;
..; dummy comment
.......foobar
&lt;/c:echo&gt;</screen>
<simpara>This would produce like <literal>[c:echo] .....foobar</literal>. Or you may use the <emphasis role="strong">shift</emphasis> attribute to right-shift the whole output by an arbitrary amount of characters like</simpara>
<screen>&lt;c:echo shift="5"&gt;
..foobar
&lt;/c:echo&gt;</screen>
<simpara>producing the same as before, namely</simpara>
<screen>[c:echo] .....foobar</screen>
<simpara>Attribute shift expects a unsigned integral number followed by an optinal arbitrary sequence of characters. This allows for a different <emphasis>shift</emphasis> character sequence as show next:</simpara>
<screen>&lt;c:echo shift="5&gt;"&gt;
..foobar
&lt;/c:echo&gt;</screen>
<simpara>This produces <literal>&gt;&gt;&gt;&gt;&gt;</literal> as shift character sequence for every line dumped as shown next:</simpara>
<screen>[c:echo] &gt;&gt;&gt;&gt;&gt;foobar</screen>
<simpara>Notice that every character after the integral number counts. Thus `5&gt; ` would produce</simpara>
<screen>[c:echo] &gt; &gt; &gt; &gt; &gt; foobar</screen>
<simpara>instead.</simpara>
<simpara>This feature also allows to create some horizontal lines which might be useful to get attention for a particular message of importance like</simpara>
<screen>[c:echo] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</screen>
<simpara>Those line of 40 per cent character <literal>%</literal> got created using</simpara>
<screen>&lt;c:echo shift="39%"&gt;
..%
&lt;/c:echo&gt;</screen>
</section>
<section id="_further_links">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelinger.it/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Echo.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Echo.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_let" xreflabel="let">
<title>let</title>
<simpara>XML is not particular easy to read for humans. When assigning a couple of varables and properties, this becomes obvious. This elementary task allows to set multiple variables and properties in one go. In addition, comments and continuation lines are allowed for additional readability and comfort. For example:</simpara>
<screen>  &lt;c:let&gt;
    f = 'folder'
    ; turn f into a file object
    f = f.tofile
    b = f.isdir ? true : false
    ; assign a *property*
    p := 'hello world'
    ; override a property if you dare
    p ::= "HELLO \
    WORLD"
  &lt;/c:let&gt;</screen>
<simpara>In this example, <literal>f</literal> is first assigned to be string <literal>"folder"</literal>. The comment line - the one starting with character <literal>;</literal> - tells what the next line is going to do: turn <literal>f</literal> into a file object which can then be used further. Here we assign a variable <literal>b</literal> which becomes <literal>true</literal> if <literal>f</literal> is a directory.</simpara>
<simpara>While character <literal>=</literal> is used to assign a variable, use character sequence <literal>:=</literal> to assign a property instead. If such a property already exists, it will not be changed in accordance with Ant&#8217;s standard behaviour.
If you dare and insist to override a property, use <literal>::=</literal> to do so.</simpara>
<simpara>Notice that the right side of <literal>=</literal>, <literal>:=</literal> and <literal>::=</literal> are in any cases a EL expression while the left side are expected to contain valid identifiers for variables and properties.</simpara>
<section id="_attributes_2">
<title>Attributes</title>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Attribute</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="el"/></simpara></entry>
<entry align="left" valign="top"><simpara>Meaning</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>comment</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>The comment character sequence.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>debug</simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Turn on extra debug information.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>All attributes follow the rule that leading and trailing whitespace is ignored. Any attribute combination is allowed and will not result necessarily in a build error. If in doubt, turn on extra debug information.</simpara>
</section>
<section id="_elements_2">
<title>Elements</title>
<simpara>This task accepts implicit text. Text may contain any amount of <xref linkend="el"/> and property references references. Continuation and comment lines are supported.</simpara>
</section>
<section id="_behaviour_2">
<title>Behaviour</title>
<simpara>The comment character sequence is <literal>";"</literal> by default. It can be changed to an arbitrary sequence using attribute <literal>comment</literal>. Once set, it can&#8217;t be changed during the execution of this task. A comment characters are used to identify lines to be ignored from execution. Such a line is given if the first non whitespace characters of that line are identical with the sequence of comment characters. In other words, a line is being ingnored if matches the regular expression <literal>^\s*&lt;comment&gt;</literal>. The comment characters itself are not interpreted as regular expression characters. Therefore a given comment sequence like <literal>"(#|;)"</literal> does not mean that either <literal>";"</literal> or <literal>"#"</literal> start a comment. Instead it means that a comment line starts with the characters <literal>"(#|;)"</literal> which would be rather awkward (while perfectly <emphasis>legal</emphasis>).</simpara>
<simpara>To support readability continuation lines are supported. Such a line is indicated by having <literal>\</literal> as last character. Be careful not to put any whitespace characters after <literal>\</literal>, otherwise the line will not be recognized as such. Continuation lines are also working on comments as the example above shows. If a line is a continuation line, the last character <literal>\</literal> is removed, the line is accumulated and the next line is read. If finally a non-continuation line is red (and only then), an evaluation of the accumulated line takes place: If the accumlated line is a comment it will be ignored and otherwise either treated as property or variable assignment.</simpara>
<simpara>Leading and trailing whitespace characters ignored in every (accumulated) line. For example, the property assignment  <literal>x := 'foo bar'</literal> will assign the string <literal>foo bar</literal> to property <literal>x</literal>. Notice that whitespace before and after <literal>x</literal> and before and <emphasis>after</emphasis> <literal>'foo bar'</literal> is ignored. This is slightly different from reading Java properties where whitespace after <literal>'foo bar'</literal> would <emphasis>not</emphasis> have been ignored!</simpara>
<simpara>When evaluating, each line is independent of other lines evaluated. Each line is evaluated in the order written. Evaluating means that the right side of the assignment is evaluated as <xref linkend="el"/> expression and the resulting object is assigned to the variable stated on the left side. When evaluating properties, then the right side is evaluted into an object and additionally streamed into a sequence of characters (string).</simpara>
<simpara>Notice that it is perfectly legal to use property or variable references as the following example shows:</simpara>
<screen>&lt;c:let&gt;
 f = '${ant.file}'
 F = '#{f}'
&lt;/c:let&gt;</screen>
<simpara>Be aware that property references are evaluated <emphasis>before</emphasis> <xref linkend="el"/> expressions. Consider:</simpara>
<screen>&lt;c:let&gt;
  ;; let s hold string ant.file
  s = 'ant.file'
  ;; bad, f will not assigned
  f = ${#{s}}
&lt;/c:let&gt;</screen>
<simpara>The second assignment will not work as expected because, in a first step, all occurrences of <literal>${..}</literal> are resolved by Ant itself. In a second step, the expression <literal>${#{s}}</literal> will be evaluated. Since this expression is invalid, <literal>f</literal> will not be assigned.</simpara>
<simpara>Each line is evaluated in order. Therefore the following works as expected:</simpara>
<screen>&lt;c:let&gt;
  s := '3 * 5'
  ;; defines r as 15
  r = ${s}
&lt;/c:let&gt;</screen>
<simpara>The following kind of meta programming will not work for <literal>let</literal>:</simpara>
<screen>&lt;c:let&gt;
  property_or_var := condition ? '=' : ':='

  name ${property_or_var} expr
&lt;/c:let&gt;</screen>
<simpara>In a first step all continuation lines are accumulated. Then each line is split in left and right part and in addition the assignment type. After that, properties are resolved on both sides by Ant&#8217;s property resolver. In an additonal step are <emphasis>EL references</emphasis> evaluated on both sides. Eventually, the right side is evaluated as EL expression and its result is assigned to the stringized and whitespace-chopped left side.</simpara>
</section>
<section id="_then_meaning_of_literal_null_literal_and_emphasis_void_emphasis">
<title>Then meaning of <literal>null</literal> and <emphasis>void</emphasis></title>
<simpara>Task <literal>let</literal> can also be used to <emphasis>remove</emphasis> variables and even properties. To illustrate this, here are example behaviours:</simpara>
<screen>&lt;c:let&gt;
 x = 3 * 5
 ;; remove x
 x =
 ;; remove x
 x = null

 ;; let property p to '3*5' (a string)
 p := 3 * 5
 ;; ignored
 p := null
 ;; remove property 'p'
 p ::= null
 ;; .. same as
 p ::=
&lt;/c:let&gt;</screen>
<simpara>The following table gives an overview of the meaning of <literal>null</literal> and <emphasis>void</emphasis> <footnote><simpara><emphasis>void</emphasis> means that the absense of any characters</simpara></footnote> on the right side of an assignement:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Assignment</simpara></entry>
<entry align="left" valign="top"><simpara>Right Side</simpara></entry>
<entry align="left" valign="top"><simpara>Result</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If the right side evaluates to <literal>null</literal>, then the variable will be removed if existing.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>void</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>The evaluation of an empty expression is <literal>null</literal>. See above how <literal>null</literal> is handled`</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>:=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Cause a <emphasis>read only</emphasis> property can&#8217;t be removed, nothing will happen with this assignment. The property will also not be created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>:=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>void</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>:= null</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>::=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Removes the property denoted by the left side</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>::=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>void</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>::= null</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_further_links_2">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/MSet.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/MSet.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_list" xreflabel="list">
<title>list</title>
<simpara>A elementary task to create a variable containing a <emphasis>list</emphasis> of objects.</simpara>
<screen>&lt;c:list var="mylist"&gt;
  ;; each line is a EL expression
  3 * 5
  ;; each line defines a list element
  list('a',1,''.tofile)
&lt;/c:list&gt;</screen>
<section id="_attributes_3">
<title>Attributes</title>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Attribute</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="el"/></simpara></entry>
<entry align="left" valign="top"><simpara>Meaning</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>var</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>r</simpara></entry>
<entry align="left" valign="top"><simpara>The name of the variabled to be assigned.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>comment</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>;</literal></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>The comment character</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>debug</simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>Turn on extra debug information.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>el</simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Enable evaluation as EL expression</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_elements_3">
<title>Elements</title>
<simpara>This task may contain a implicit text element.</simpara>
</section>
<section id="_behaviour_3">
<title>Behaviour</title>
<simpara>This task creates and assigns in any case a (possible) empty list, especially if no text element is present. The variable&#8217;s name is given by attribute <literal>var</literal>. This attribute may contain references to EL expressions.</simpara>
<simpara>If given text element is parsed on a line by line basis, honouring comments and continuation lines. Each line will be evaluated as EL expression after having resolved <literal>${..}</literal> and <literal>#{..}</literal> references. A illegal EL expression will be discarded while the evaluation of lines continues. Turn on extra debug information in case of problems.</simpara>
<simpara>The evaluation of a valid EL expression results in an object. Each such object will be added to a list in the order imposed by the lines.</simpara>
<simpara>A single line can&#8217;t have more than one EL expressions. Thus the following example is invalid:</simpara>
<screen>&lt;c:list var="mylist"&gt;
 ;; not working
 3 * 5  'hello, world'
&lt;/c:list&gt;</screen>
<simpara>Use attribute <literal>el</literal> to disable the interpretation of a line as <xref linkend="el"/> expression:</simpara>
<screen>&lt;c:list var="mystrings" el="false"&gt;
 3 * 5
 ;; assume that variable message has (string) value 'world'
 hello, #{message}
&lt;/c:list&gt;</screen>
<simpara>This creates a list variable <literal>mystrings</literal> containing two elements. The first element will be string <literal>3 * 5</literal> and the second element will be string <literal>hello, world</literal>. Notice thateven if EL evaluation has been turned off, EL references can still be used.</simpara>
</section>
<section id="_further_links_3">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelinger.it/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/List.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/it/haefelinger/flaka/List.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="_install_property_handler">
<title>install-property-handler</title>
<simpara>A task to install Flaka&#8217;s property handler. When installed, Ant <emphasis>understands</emphasis>  <xref linkend="el"/> references like <literal>#{..}</literal> in addition to standard property references <literal>${..}</literal>.</simpara>
<simpara>An example will illustrate this:</simpara>
<screen> &lt;c:let&gt;
    ;; let variable foo to string 'bar'
    foo = 'bar'
 &lt;c:let&gt;
 &lt;echo&gt;
    [1] #{foo}
 &lt;/echo&gt;
 &lt;c:install-reference-handler /&gt;
 &lt;echo&gt;
    [2] #{foo}
 &lt;/echo&gt;</screen>
<simpara>Assume in this example, that the standard Ant property handler is installed. In the first <literal>&lt;c:let/&gt;</literal> task you can use EL because this task is provided by Flaka and thus EL aware. This is not the case for the <literal>&lt;echo/&gt;</literal> task following. Thus something like <literal>#{foo}</literal> has no meaning. However, after Flaka&#8217;s property handler is installed, the situation changed.</simpara>
<simpara>This is the output of above&#8217;s snippet:</simpara>
<screen> [echo] [1] #{foo}
 [echo] [2] bar</screen>
<section id="_attributes_4">
<title>Attributes</title>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Attributes</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>EL</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>type</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>elonly</literal></simpara></entry>
<entry align="left" valign="top"><simpara>#{}</simpara></entry>
<entry align="left" valign="top"><simpara>Install handler with certain additional features  enabled (see below)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_behaviour_4">
<title>Behaviour</title>
<simpara>If <literal>type</literal> is <literal>elonly</literal> (exactly as written), then the new handler will only handle <literal>#{..}</literal> in addition. If <literal>type</literal> is <literal>remove</literal>, then unresolved property references are discarded.</simpara>
</section>
<section id="_further_links_4">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelinger.it/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/PropertyHelper.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/PropertyHelper.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</article>
