<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<?asciidoc-toc?>
<?asciidoc-numbered?>

<article lang="en">
<articleinfo>
    <title>The flaka manual</title>
    <date>February 2010</date>
    <author>
        <firstname>author</firstname>
        <surname>wh@haefelinger.it</surname>
    </author>
    <authorinitials>AW</authorinitials>
<revhistory><revision><revnumber>1.0</revnumber><date>February 2010</date><authorinitials>AW</authorinitials></revision></revhistory>
</articleinfo>
<section id="_introduction">
<title>Introduction</title>
<simpara>In the world of <ulink url="http://en.wikipedia.org/wiki/Java_(programming_language)">Java</ulink>, build scripts are traditionally written in <ulink url="http://en.wikipedia.org/wiki/Apache_Ant">Ant</ulink> and recently also in <ulink url="http://en.wikipedia.org/wiki/Apache_Maven">Maven</ulink>.</simpara>
<simpara>When it comes to write a build script using Ant, it feels like using a Shell script in a rather awkward language (XML). Each Ant task solves a particular problem. This is similar to a Shell where you have this small masterpieces like <literal>mkdir</literal>, <literal>cp</literal>, <literal>tar</literal> plus some control structures to eventually being able to put the one big thing together.</simpara>
<simpara>Writing a build script using a Shell is serious business. And so it is when using Ant. Ant does not provide you any abstraction how the project needs to be build. There is no underlying logic. In fact you, the author, need to know what to do. Step by step. What&#8217;s more, you have to use the unfriendly <ulink url="http://en.wikipedia.org/wiki/XML">XML</ulink> syntax and restrictions, a control structure is missing and you have to use immutable properties to communicate between tasks. Therefore, Ant scripts are large, notoriously difficult to understand, usually not portable (usuallyt they just work on the authors host) and each author uses a different set of targets and properties.</simpara>
<simpara>Maven on the other side provides a high abstraction of building a project. Instead of describing how the project needs to be build, just describe project details and reports you like to have and Maven figures out what needs to be done. This is probably the reason why Maven got so much attention recently.</simpara>
<simpara>Despite better knowledge I wrote that Maven figures out how a project needs to be build automatically. That’s actually not quite true. In fact, Maven only works fine when following conventions setup by the Maven team. When not “en route”, Maven gets difficult as well. But even when following conventions, the number of options in Maven are now endless and question the idear of a declarative approach. Have a look at Maven&#8217;s <ulink url="http://maven.apache.org/ref/current/maven-model/maven.html">POM</ulink> being a never ending series of XML tags]. At the end, I found myself using Ant again.</simpara>
<simpara>Still I&#8217;m not happy with Ant.</simpara>
<simpara>What I&#8217;m missing is the full power of a programming language. Yes, I want to have conditionals, loops and exception handling. I want to have variables which I can set or remove for pleasure. Such variables can reference any kind of object not only strings. And I need a nice expression language to retrieve and calculate in a simple yet elegant way. And there is no need to have each and everything expressed in XML. And then I want to have some kind of higher abstraction which does the right thing most of the time. This is what Flaka is about:</simpara>
<itemizedlist>
<listitem>
<simpara>
Programming Tasks (conditional, loops, exception handling, ..)
</simpara>
</listitem>
<listitem>
<simpara>
Embedded Expression Language (EL)
</simpara>
</listitem>
<listitem>
<simpara>
Framework to do the <emphasis>right</emphasis> thing, yet allows to use standard Ant when necessary
</simpara>
</listitem>
<listitem>
<simpara>
Dependency handling (legacy, to be replaced by Ivy)
</simpara>
</listitem>
</itemizedlist>
<simpara>This four pillars are Flakas approach to simplify the process of writing a build script with Ant. Notice that you are by no means forced to use all four pillars. You can for example just use the  programming tasks with or without elements of EL while you don&#8217;t need to get in touch with Flakas dependency handling instruments and neither with the framework.</simpara>
<simpara>The folling example of a complete build script shall demonstrate the idear how a build script using Flaka looks like:</simpara>
<screen>&lt;project xmlns:c="antlib:it.haefelinger.flaka"&gt;
 &lt;c:build /&gt;
 &lt;c:dependency alias="log4j" /&gt;
&lt;/project&gt;</screen>
<simpara>The author just lists the dependencies required to build the project. Flaka would do the rest by checking the underlying project structure:</simpara>
<itemizedlist>
<listitem>
<simpara>
figure out what type of project should be build (jar, war, ear ..)
</simpara>
</listitem>
<listitem>
<simpara>
figure out where project&#8217;s source code, test cases etc are
</simpara>
</listitem>
<listitem>
<simpara>
handle dependencies
</simpara>
</listitem>
<listitem>
<simpara>
create targets like <literal>clean</literal>, <literal>compile</literal>, <literal>package</literal>, <literal>test</literal> automatically
</simpara>
</listitem>
<listitem>
<simpara>
generate Javadoc and other reports
</simpara>
</listitem>
</itemizedlist>
<section id="_current_status">
<title>Current Status</title>
<simpara>Not all targets have been reached in the current version of Flaka (Release candidate 1). Programming tasks and EL are working fine and can be used. The other two pillars work partially but generally not recommended (yet) to be used.</simpara>
</section>
<section id="_where_to_go_from_here">
<title>Where to go from here?</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/downloads/list">Download</ulink> Flaka and read the <link linkend="installation">installation page</link>.
</simpara>
</listitem>
<listitem>
<simpara>
Have a look at the <link linkend="scripting">basic scripting elements</link> to get an overview of tasks, types and macros provided by Flaka. Have a closer look in the reference part of this manual for all the gory details of those tasks, types and macros.
</simpara>
</listitem>
<listitem>
<simpara>
Make sure to look into the chapter about the <link linkend="el">expression language</link>, it contains a lot of information on this enormous useful extension.
</simpara>
</listitem>
<listitem>
<simpara>
Start writing build scripts using Flaka and give <ulink url="mailto:flaka@haefelinger.it">feedback</ulink>.
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="_programming_constructs">
<title>Programming Constructs</title>
<simpara>This chapter provides an overview of programming constructs Flaka provides. This programming constructs are one of the Flaka&#8217;s pillars.</simpara>
<section id="_strings">
<title>Strings</title>
<simpara>Like Ant, Flaka supports currently strings and, when applicable, pointer to resources (by referencing a symbol). Ant provides no functionality manipulate a string value and neither does Flaka. However, Flaka&#8217;s expression language contains string functions to create new strings.</simpara>
</section>
<section id="_symbols">
<title>Symbols</title>
<simpara>Symbols are names carrying associated data. The name of a symbol is a sequence of characters. The allowed characters are basically unlimited. It is recommended to stick with well known characters [a-zA-Z0-9._-]. Symbols can be used as variables, target, task, type or macro names.</simpara>
<itemizedlist>
<listitem>
<simpara>
<literal>&lt;property name=sym value=expr /&gt;</literal> Use sym as variable: assign the value of <emphasis>expr</emphasis> to <emphasis>sym</emphasis>. <emphasis role="strong">A symbol associated with a string value is called a property</emphasis>. Notice that Ant and Flaka provide further ways of creating properties.
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;macrodef name=sym&gt;</literal>  Use <emphasis>sym</emphasis> as macro name
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;target namesym&gt;</literal> Use <emphasis>sym</emphasis> as target name
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;taskdef name=sym&gt;</literal> Use <emphasis>sym</emphasis> as task name
</simpara>
</listitem>
<listitem>
<simpara>
<literal>&lt;typedef name=sym&gt;</literal> Use <emphasis>sym</emphasis> as type name
</simpara>
</listitem>
<listitem>
<simpara>
<literal>id=sym</literal> Use sym as reference: assign the evaluation of task (or macro) to <emphasis>id</emphasis>
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_properties">
<title>Properties</title>
<simpara>To reference a property, enclose it&#8217;s symbol name with curly braces and prefix with the dollar character like:</simpara>
<screen>&lt;property name="x" value="99" /&gt;
&lt;echo&gt;
  value of property x is ${x}    -- .. is 99
&lt;/echo&gt;</screen>
<simpara></simpara>
<screen>&lt;property name="x" value="99" /&gt;
&lt;property name="x" value="The quick brown fox .."/&gt;
&lt;echo&gt;
  value of property x is ${x}    -- .. is 99
&lt;/echo&gt;</screen>
<simpara>It can be done using Flaka&#8217;s task <xref linkend="task_let"/> or <xref linkend="task_unset"/> as the following snippet demonstrates.</simpara>
<screen>&lt;property name="x" value="99" /&gt;
&lt;c:let&gt;
   x ::= "The quick brown fox .."
&lt;/c:let&gt;
&lt;echo&gt;
  value of property x is ${x}    -- .. is The quick brown ..
&lt;/echo&gt;</screen>
<simpara>Properties have their own symbol table (as targets, tasks, macros and types have). This means for example that it is possible to have a property and a task <emphasis>sharing</emphasis> the same symbol name:</simpara>
<screen>  &lt;property name="foobar" ../&gt;
  &lt;macrodef name="foobar" ../&gt;  -- property foobar not harmed!</screen>
</section>
<section id="_sequencing">
<title>Sequencing</title>
<simpara>To evaluate a sequence of expressions (tasks or macros) where only one expression is allowed, use <ulink url="http://ant.apache.org/manual/CoreTasks/sequential.html">Ant&#8217;s sequential task</ulink>:</simpara>
<screen> &lt;sequential&gt;
   -- any sequence of tasks or macros
 &lt;/sequential&gt;</screen>
<simpara>Note that <emphasis>sequential</emphasis> returns nothing. Use properties to communicate with the caller if necessary.</simpara>
</section>
<section id="_conditionals">
<title>Conditionals</title>
<simpara>With standard Ant, task <ulink url="http://ant.apache.org/manual/CoreTasks/condition.html">condition</ulink> is used to set a property if a condition is given. Then a macro, task or target can be conditionally executed  by checking the existence or absence of that property (using standard attributes <emphasis>if</emphasis> or <emphasis>unless</emphasis>. Flaka defines a couple of control structures to handle conditionals in a simpler way.</simpara>
</section>
<section id="_when_and_unless">
<title>when and unless</title>
<simpara>Task <xref linkend="task_when"/> evaluates an <xref linkend="el"/> expressio. If the evaluation gives <literal>true</literal>, the sequence of tasks are executed. Nothing else happens in case of <literal>false</literal>.</simpara>
<screen>&lt;c:when test=" expr "&gt;
   -- executed if expr evaluates to true
&lt;/c:when&gt;</screen>
<simpara>The logical negation of <literal>when</literal> is task <xref linkend="task_unless"/> which executes the sequence of tasks only in case the evaluation of <emphasis>expr</emphasis> returns <literal>false</literal>.</simpara>
<screen> &lt;c:unless test=" expr "&gt;
   -- executed if expr evaluates to false
 &lt;/c:unless&gt;</screen>
<simpara>The body of <literal>when</literal> and <literal>unset</literal> may contain any sequence of tasks or macros (or a combination of both).</simpara>
</section>
<section id="_choose">
<title>choose</title>
<simpara>Task <xref linkend="task_choose"/> tests each <literal>when</literal> condition in turn until an <emphasis>expr</emphasis> evalutes to <literal>true</literal>. It executes then the body of that when condition. Subsequent <literal>whens</literal> are then not further tested (nor executed). If all expressions evaluate to <literal>false</literal>, an optional <emphasis>catch-all</emphasis> clause gets executed.</simpara>
<screen> &lt;c:choose&gt;
  &lt;when test="expr_1"&gt;
    -- body_1
  &lt;/when&gt;
  ..
  &lt;otherwise&gt; -- optional_
    -- catch all body
  &lt;/otherwise&gt;
 &lt;c:/choose&gt;</screen>
</section>
<section id="_switch">
<title>switch</title>
<simpara>A programming task often seen is to check whether a (string) value matches a given (string) value. If so, a particular action shall be carried out. This can be done via a series of <emphasis>when</emphasis> statements. The nasty thing is to keep track of whether a value matched already. Flaka provides a handy task for this common scenario, the <xref linkend="task_switch"/> task:</simpara>
<screen> &lt;c:switch value=" 'some string' "&gt;
  &lt;matches re="regular expression or pattern" &gt;
    -- body_1
  &lt;/case&gt;
  ..
  &lt;otherwise&gt; -- optional
    -- catch all body
  &lt;/otherwise&gt;
 &lt;/c:switch&gt;</screen>
<simpara>Each case is tried in turn <emphasis>to match</emphasis> the string value (given as <xref linkend="el"/> expression). If a case matches, the appropriate case body is executed. If it happens that no case matches, then the optional default body is executed. To be of greater value, a regular expression or pattern expression can be used in a case condition.</simpara>
</section>
<section id="_repetition">
<title>Repetition</title>
<simpara>Flaka has a looping statement. Use task <xref linkend="task_for"/> to iterate over a <emphasis>list</emphasis> of items. Use <xref linkend="task_break"/> and <xref linkend="tasks_continue"/> to terminate the loop or to continue the loop with the next item.</simpara>
<screen> &lt;c:for var=" name " in=" ''.tofile.list "&gt;
    -- sequence of task or macros
    -- used &lt;c:continue /&gt; to continue ; and
    -- &lt;c:break /&gt; to stop looping
    -- use #{name} to refer to current item (as shown below)
    &lt;c:echo&gt;#{name}&lt;/c:echo&gt;
 &lt;/c:for&gt;</screen>
<simpara>Attribute <literal>in</literal> will be evaluated as <xref linkend="el"/> expression. In the example above, that <xref linkend="el"/> expression is <literal>''.tofile.list</literal> which, when evaluated, creates a list of all files in the folder containing the current build script. To understand the expression, have a look at <link linkend="el_string_properties">properties</link> of a string] and <link linkend="el_file_properties">properties</link> of a file.</simpara>
</section>
<section id="_exception_handling">
<title>Exception Handling</title>
<simpara>Flaka has been charged with exception handling tasks.</simpara>
</section>
<section id="_trycatch">
<title>trycatch</title>
<simpara>Flaka contains a task to handle exceptions thrown by tasks, <xref linkend="task_trycatch"/>. This task implements the usual <emphasis>try/catch/finally</emphasis> trinity found in various programming languages (like in Java for example):</simpara>
<screen> &lt;c:trycatch&gt;
   &lt;try&gt;
     -- sequence of task or macros
   &lt;/try&gt;
   &lt;catch&gt;
     -- sequence of task or macros
   &lt;/catch&gt;
   &lt;finally&gt;
     -- sequence of task or macros
   &lt;/finally&gt;
 &lt;/c:trycatch&gt;</screen>
<simpara>Element <emphasis>try</emphasis>, <emphasis>catch</emphasis> and <emphasis>finally</emphasis> are all optional or can appear multiple times. If <emphasis>catch</emphasis> is used without any argument, then that catch clause will match any <emphasis role="strong">build exception</emphasis>. To differentiate between different exception types, <emphasis>catch</emphasis> can additionally be used with a <emphasis>type</emphasis> and <emphasis>match</emphasis> argument. The former can be used to select a particular exception type (like a 'java.lang.NullPointerException), the latter can be used to select an exception based on the message carried. Both arguments are interpreted as pattern expression. For example:</simpara>
<screen> &lt;c:trycatch&gt;
   &lt;try&gt;
      ..
      &lt;fail message="#PANIC!" unless="ant.file"/&gt;
      ..
   &lt;/try&gt;
   &lt;catch match="*#PANIC!*"&gt;
      &lt;echo&gt;Ant initialization problem!!&lt;/echo&gt;
      &lt;fail/&gt;
   &lt;catch type="java.lang.*"&gt;
     -- handle Java runtime problems
   &lt;/catch&gt;
   &lt;catch&gt;
     -- handle all other build exceptions
   &lt;/catch&gt;
  &lt;/c:trycatch&gt;</screen>
<simpara>Property <emphasis>ant.file</emphasis> is a standard Ant property that should always be set. If not, there&#8217;s something seriously wrong and it does not make much sense to continue. Use attribute <emphasis>type</emphasis> to catch (runtime) exceptions thrown by the underlying implementation.</simpara>
</section>
<section id="_throw">
<title>throw</title>
<simpara>Task <xref linkend="task_throw"/> throws a (build) exception.</simpara>
<screen> &lt;c:throw [var="sym"] /&gt;</screen>
<simpara>This task can also be used to rethrow an existing exception.</simpara>
</section>
<section id="_macros">
<title>Macros</title>
<simpara>The (almost) equivalent of a function is a macro in Ant and Flaka. For example:</simpara>
<screen> &lt;macrodef name="hello"&gt;
  &lt;attribute name="msg" /&gt;
  &lt;element name="body" implicit="true" /&gt;
  &lt;sequential&gt;
   &lt;body /&gt;
  &lt;/sequential&gt;
 &lt;/macrodef&gt;</screen>
<simpara>Once defined, simply use it:</simpara>
<screen>&lt;hello msg="Hello, world!"&gt;
 &lt;echo&gt;@{msg}&lt;/echo&gt;
&lt;/hello&gt;</screen>
<simpara>This macro evaluates into</simpara>
<screen> &lt;echo&gt;Hello, world!&lt;/echo&gt;</screen>
<simpara>which eventually prints the desired greeting.</simpara>
<simpara>Macros are a standard feature of Ant.</simpara>
</section>
</section>
<section id="_part_ii">
<title>Part II</title>
<simpara>Each of the following chapters describes a task in all it's details.</simpara>
</section>
<section id="task_break" xreflabel="break">
<title>break</title>
<simpara>A task mirroring a break statement. When used within a <link linkend="tasks_for">for</link>-loop, the loop will be terminated. If this task is used outside of a <link linkend="tasks_for">for</link>-loop, a build exception will be thrown.</simpara>
<screen>  &lt;c:for var="i" in=" list(1,2,3,4,5,6) "&gt;
    &lt;c:echo&gt;i = #{i}&lt;/echo&gt;
     &lt;c:when test=" i == 3 "&gt;
       &lt;c:break /&gt;
     &lt;/c:when&gt;
  &lt;/c:for&gt;</screen>
<simpara>Being executed, the following will be dumped on stdout:</simpara>
<screen>[c:echo] i = 1
[c:echo] i = 2
[c:echo] i = 3</screen>
<section id="_attributes">
<title>Attributes</title>
<simpara>|| Attribute || Type || Default || <xref linkend="el"/> || Description ||
|| <literal>test</literal>    || string || -     || expr || Terminate loop when <xref linkend="el"/> expression evaluates to <literal>true</literal> ||
|| <literal>if</literal>      || string || -     || #{}  || Terminate if property exists ||
|| <literal>unless</literal>  || string || -     || #{}  || Terminate if property does not exist ||</simpara>
</section>
<section id="_behaviour">
<title>Behaviour</title>
<simpara>When used without any attributes, the surrounding <link linkend="tasks_for">for</link> or <link linkend="tasks_while">while</link> loop will terminate at once. When used with attributes, then the loop will terminate if at least one attribute evaluates to <literal>true</literal>. Otherwise, the loop will not be terminated and continues as usual.</simpara>
<simpara>The example given above can thus be shortened to</simpara>
<screen>  &lt;c:for var="i" in=" list(1,2,3,4,5,6) "&gt;
    &lt;c:echo&gt;i = #{i}&lt;/echo&gt;
    &lt;c:break test=" i == 3 " /&gt;
  &lt;/c:for&gt;</screen>
</section>
<section id="_further_links">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Break.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Break.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_choose" xreflabel="choose">
<title>choose</title>
<simpara>A task implementing a series of <emphasis>ifelse</emphasis> statements, i.e. a generalized <emphasis>if-then-else</emphasis> statement.</simpara>
<section id="_attributes_2">
<title>Attributes</title>
<simpara>|| Attribute   || Type     || Default || EL || Description ||
|| <emphasis>when</emphasis>.test || string   || <literal>false</literal> ||  = || A EL condition. When <literal>true</literal> corresponding clause will be executed. ||
|| <emphasis>unless</emphasis>.text || string || <literal>true</literal>  ||  = || A EL condition. When <literal>false</literal> corresponding clause will be executed. ||
|| debug       || boolean  || <literal>false</literal> ||  = || Turn on extra debug information. ||</simpara>
</section>
<section id="_elements">
<title>Elements</title>
<simpara>|| Element   || Cardinality || Description ||
|| when      || infinite    || To be executed if condition evaluates to <literal>true</literal> ||
|| unless    || infinite    || To be executed if condition evaluates to <literal>false</literal> ||
|| otherwise || [0,1]       || To be executed if no <literal>when</literal> or <literal>unless</literal> clause got executed ||
|| default   || [0,1]       || Synonym for <literal>otherwise</literal> ||</simpara>
</section>
<section id="_behaviour_2">
<title>Behaviour===</title>
<simpara>Each <literal>when</literal> and <literal>unless</literal> clause&#8217;s conditions are evaluated in order given until a claus get&#8217;s executed. Then, further processing stops ignoring all further elements not taken into account so far. If no <literal>when</literal> or <literal>unless</literal> clause got executed, then a present <literal>otherwise</literal> or <literal>default</literal> clause gets executed.</simpara>
<simpara>The shortest possible <literal>choose</literal> statement is</simpara>
<screen> &lt;c:choose /&gt;</screen>
<simpara>It&#8217;s useless and does nothing, it&#8217;s completely harmless.</simpara>
<simpara>The following example would execute all macros or tasks listed in the <literal>otherwise</literal> clause cause no <literal>when</literal> or <literal>unless</literal> clause got executed.</simpara>
<screen> &lt;c:choose&gt;
  &lt;otherwise&gt;
    &lt;!-- macros/tasks --&gt;
  &lt;/otherwise&gt;
 &lt;/c:choose&gt;</screen>
<simpara>This would execute all macros and tasks listed in the otherwise clause since no when clause got executed.</simpara>
<screen> &lt;c:choose&gt;
   &lt;when test=" true == false" &gt;
     &lt;echo&gt;new boolean logic detected ..&lt;/echo&gt;
   &lt;/when&gt;
   &lt;unless test=" 'mydir'.tofile.isdir "&gt;
     &lt;echo&gt; directory mydir exists already &lt;/echo&gt;
   &lt;/when&gt;
   &lt;otherwise&gt;
     &lt;echo&gt; Hello,&lt;/echo&gt;
     &lt;echo&gt;World&lt;/echo&gt;
   &lt;/otherwise&gt;
 &lt;/c:choose&gt;</screen>
</section>
<section id="_further_links_2">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Choose.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Choose.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_continue" xreflabel="continue">
<title>continue</title>
<simpara>A task mirroring a continue statement. When used within a <link linkend="tasks_for">for</link>-loop, the loop will be continued with the next loop item (i.e. any statements after task continue are ignored). If this task is used outside of a for-loop, a build exception will be thrown.</simpara>
<screen> &lt;c:for var="i" in=" list(1,2,3,4,5,6) "&gt;
   &lt;c:when test=" i &gt; 3 "&gt;
     &lt;c:continue /&gt;
   &lt;/c:when&gt;
   &lt;c:echo&gt;i = #{i}&lt;/echo&gt;
  &lt;/c:for&gt;</screen>
<simpara>This would print:</simpara>
<screen>[c:echo] i = 1
[c:echo] i = 2
[c:echo] i = 3</screen>
<section id="_attributes_3">
<title>Attributes</title>
<simpara>|| Attribute || Type || Default || <xref linkend="el"/> || Description ||
|| <literal>test</literal>    || string || -     || expr || Continue loop when <xref linkend="el"/> expression evaluates to <literal>true</literal> ||
|| <literal>if</literal>      || string || -     || #{}  || Continue if property exists ||
|| <literal>unless</literal>  || string || -     || #{}  || Continue if property does not exist ||</simpara>
</section>
<section id="_behaviour_3">
<title>Behaviour</title>
<simpara>When used without any attributes, the surrounding <link linkend="tasks_for">for</link> or <link linkend="tasks_while">while</link> be continued while following tasks or macros are ignored in the current iteration step. When used with attributes, then the loop will be continued if at least one attribute evaluates to <literal>true</literal>. Otherwise, the subsequent tasks or macros are executed.</simpara>
<simpara>The example given above can thus be shortened to</simpara>
<screen> &lt;c:for var="i" in=" list(1,2,3,4,5,6) "&gt;
   &lt;c:continue test=" i &gt; 3 " /&gt;
   &lt;c:echo&gt;i = #{i}&lt;/echo&gt;
&lt;/c:for&gt;</screen>
</section>
<section id="_further_links_3">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Continue.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Continue.java">Source</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
Task <link linkend="tasks_for">for</link>
</simpara>
</listitem>
<listitem>
<simpara>
Task <link linkend="tasks_break">break</link>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_echo" xreflabel="echo">
<title>echo</title>
<simpara>Ant has an echo task to dump some text on a screen or into a file. A problem with this task is, that the output produced is rather fragile when it comes to reformatting your XML source. Here is a simple example.</simpara>
<screen>&lt;echo&gt;foobar&lt;/echo&gt;</screen>
<simpara>When executed by Ant, this dumps</simpara>
<screen>[echo] foobar</screen>
<simpara>However, one day you reformat your XML build file footnote::<ulink url="http://xmlsoft.org/xmllint.html">xmlint</ulink>[is a good choice] and you end up in</simpara>
<screen>&lt;echo&gt;
...foobar
&lt;/echo&gt;</screen>
<simpara>Notice the usage of character <literal>.</literal> (dot) in this example and the rest of this (and only this) chapter to visualize a <emphasis>space</emphasis> <footnote><simpara>Also known as <emphasis>blank</emphasis> character</simpara></footnote> character. If you execute this, you will get</simpara>
<screen>[echo]
[echo] ...foobar
[echo]</screen>
<simpara>This is definitly not what you had in mind.</simpara>
<simpara>Task <literal>&lt;c:echo/&gt;</literal> is an extension of Ant's standard <literal>echo</literal> task. That standard task is used for doing all that low level work, i.e. dumping text on streams on loggers. On top of it, some features have been implemented intented to generate nicly formatted output.</simpara>
<simpara>Here is the <literal>foobar</literal> example again:</simpara>
<screen>&lt;c:echo&gt;

  foo\
  bar
  ; supports continuation and \
  comment lines
&lt;/c:echo&gt;</screen>
<simpara>This would output</simpara>
<screen>[c:echo] foobar</screen>
<simpara>which I believe is just what you had in mind.</simpara>
<section id="_attributes_4">
<title>Attributes</title>
<simpara>This tasks supports all attributes inherited from Ant&#8217;s echo task. In addition, further supported attributes are:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="4">
<colspec colname="col_1" colwidth="15*"/>
<colspec colname="col_2" colwidth="15*"/>
<colspec colname="col_3" colwidth="15*"/>
<colspec colname="col_4" colwidth="55*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Attribute</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>debug</literal></simpara></entry>
<entry align="left" valign="top"><simpara>boolean</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara>Enables additional debug output for this particular task.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>comment</literal></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Allows for comments.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>shift</literal></simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara>``</simpara></entry>
<entry align="left" valign="top"><simpara>Allows to prefix each line with <literal>shift</literal> characters. See also Behaviour below.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>Notice that <emphasis role="strong">debug</emphasis> output will be written on stream <literal>stderr</literal> regardless whether <literal>debug</literal> has been globally enabled on Ant or not. Also standard Ant loggers and listeneres are ignored. The default value is <literal>false</literal>, i.e. no additional output is created.</simpara>
<simpara>The trimmed <emphasis role="strong"><literal>comment</literal></emphasis> attribute value is used to construct a regular expression like <literal>^\s*\Q&lt;&lt;comment&gt;&gt;\E</literal>. Every line matching this regular expression will not show up in the output. Notice that the comment value given does not allow for regular expression meta characters. Thus something like <literal>(;|#)</literal> does <emphasis>not</emphasis> mean either <literal>;</literal> or <literal>#</literal>. Instead it means that a line starting with <literal>(;#)</literal> is ignored from output. By default, lines starting with character <literal>;</literal> - like in Lisp - are ignored.</simpara>
</section>
<section id="_elements_2">
<title>Elements</title>
<simpara>This task optionally accepts implicit text. That text may contain Ant property <literal>${..}</literal> or <xref linkend="el"/> <literal>#{..}</literal> references.</simpara>
</section>
<section id="_behaviour_4">
<title>Behaviour</title>
<simpara><emphasis role="strong">Continuation Lines</emphasis> are lines where the last character before the line termination character is the backslash character. Such a line is continued, i.e. the line will be merged with the next one (which could also be a continuation line).</simpara>
<simpara>A (merge continuation) line starting with an arbitrary number of whitespace characters followed by the characters given in attribute <literal>comment</literal> is a <emphasis role="strong">comment line</emphasis>. Such lines are removed from output. The characters given are taken literaly and have no meta character functionality. To disable comment lines altogether use an empty string <footnote><simpara>A string consisting only of whitespace characters</simpara></footnote>.</simpara>
<simpara>To allow a <emphasis role="strong">decent formatting</emphasis> unnecessary whitespace characters are removed. The process is illustrated <footnote><simpara>Again character dot <literal>.</literal> is used to illustrate a whitespace character with the exception of line ending characters</simpara></footnote> using the introduction example used above:</simpara>
<screen>&lt;c:echo&gt;

..foo\
..bar
&lt;/c:echo&gt;</screen>
<simpara>In a first step is the first non-whitespace character determined. In the example above, this is character <literal>f</literal>. From there Flaka counts backwards until a line termination character or the begin of input is reached. The counted number is the amount of whitespace characters stripped from the begin of each line. If a line starts with less than that amount of whitespace characters, then only those available are removed. Additionally, all whitespace characters before the first non-whitespace character are removed from the input.</simpara>
<simpara>There are two whitespace characters before <literal>foo\</literal>. If support for continuation lines would have been disabled, Flaka would dump the following:</simpara>
<screen>[c:echo] foo\
[c:echo] bar</screen>
<simpara>Handling of continuation lines takes place <emphasis role="strong">after</emphasis> whitespace has been stripped. Thus Flaka prints</simpara>
<screen>[c:echo] foobar</screen>
<simpara>as shown in the introduction example. A slight variation of the example above is given next:</simpara>
<screen>&lt;c:echo&gt;

..foo\
.bar
...indended by one character, right?
&lt;/c:echo&gt;</screen>
<simpara>Notice that in front of <literal>bar</literal> is only one whitespace character while there are three in the line after. What will be Flaka&#8217;s output?</simpara>
<screen>[c:echo] foobar
[c:echo] .indended by one character, right?</screen>
<simpara>As you can see, no more than the initial counted amount of whitespace is removed from each line.</simpara>
<simpara>However, assume that you really want to have a couple of empty lines dumped before any real content. How can this be done. There are two options. Firstly you can always fall back to use Ant&#8217;s standard <literal>echo</literal> task. Secondly, you can use a comment line like shown next</simpara>
<screen>&lt;c:echo&gt;
..; two empty lines following


..foobar
&lt;/c:echo&gt;</screen>
<simpara>which would dump:</simpara>
<screen>[c:echo]
[c:echo]
[c:echo] foobar</screen>
<simpara>This all works because comment lines are removed from the input <emphasis role="strong">after</emphasis> the position of the first non-whitespace character gets determined. It obviously means that this kind of comments do matter and can&#8217;t simply be stripped off. They may carry some semantics, so it&#8217;s probably best to avoid this kind of trick. Make use of it when approbriate.</simpara>
<simpara>We have seen how to force leading empty lines in the example above. What needs to be done if some leading whitespace is intended? Again there are two options. First you may attack the problem using the comment line trick:</simpara>
<screen>&lt;c:echo&gt;
..; dummy comment
.......foobar
&lt;/c:echo&gt;</screen>
<simpara>This would produce like <literal>[c:echo] .....foobar</literal>. Or you may use the <emphasis role="strong">shift</emphasis> attribute to right-shift the whole output by an arbitrary amount of characters like</simpara>
<screen>&lt;c:echo shift="5"&gt;
..foobar
&lt;/c:echo&gt;</screen>
<simpara>producing the same as before, namely</simpara>
<screen>[c:echo] .....foobar</screen>
<simpara>Attribute shift expects a unsigned integral number followed by an optinal arbitrary sequence of characters. This allows for a different <emphasis>shift</emphasis> character sequence as show next:</simpara>
<screen>&lt;c:echo shift="5&gt;"&gt;
..foobar
&lt;/c:echo&gt;</screen>
<simpara>This produces <literal>&gt;&gt;&gt;&gt;&gt;</literal> as shift character sequence for every line dumped as shown next:</simpara>
<screen>[c:echo] &gt;&gt;&gt;&gt;&gt;foobar</screen>
<simpara>Notice that every character after the integral number counts. Thus `5&gt; ` would produce</simpara>
<screen>[c:echo] &gt; &gt; &gt; &gt; &gt; foobar</screen>
<simpara>instead.</simpara>
<simpara>This feature also allows to create some horizontal lines which might be useful to get attention for a particular message of importance like</simpara>
<screen>[c:echo] %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</screen>
<simpara>Those line of 40 per cent character <literal>%</literal> got created using</simpara>
<screen>&lt;c:echo shift="39%"&gt;
..%
&lt;/c:echo&gt;</screen>
</section>
<section id="_further_links_4">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelinger.it/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Echo.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Echo.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_fail" xreflabel="fail">
<title>fail</title>
<simpara>This task has been derived from <ulink url="http://ant.apache.org/manual/CoreTasks/fail.html">Ant&#8217;s standard fail task</ulink>. All attributes and elements are supported. When defining a message however, EL references can be used:</simpara>
<screen>&lt;c:fail message="illegal state #{whichstate} seen" /&gt;</screen>
<simpara>Furthermore, attribute <literal>test</literal> has been added. The value of <literal>test</literal> will be evaluated as EL expression in a boolean context. Being <literal>true</literal>, fail will throw a build exception. When used in this way, <literal>&lt;c:fail test='expr' /&gt;</literal> behaves exactly the same as</simpara>
<screen>&lt;c:when test="expr"&gt;
 &lt;fail /&gt;
&lt;/c:when&gt;</screen>
<section id="_further_links_5">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Fail.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Fail.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_for" xreflabel="for">
<title>for</title>
<simpara>A task that implements a loop statement. Iterating over a list of <emphasis>objects</emphasis>:</simpara>
<screen> &lt;c:for var="x" in=" list('a', 2, 'src'.tofile, typeof(list())) "&gt;
   &lt;c:echo&gt;
      #{x}
   &lt;/c:echo&gt;
 &lt;/c:for&gt;</screen>
<section id="_attributes_5">
<title>Attributes</title>
<simpara>|| Attribute || Type   || Default || EL    || Description ||
|| <literal>var</literal>     || string ||         || #{}   || The variable holding each loop item. This variable can be referenced within the body like <literal>#{var}</literal> where <literal>var</literal> is the string used in this attribute. If not used, then no iteration takes place and no warning is issued. Notice that you can use <literal>#{..}</literal> only in <xref linkend="el"/> enabled tasks. ||
|| <literal>in</literal>      || string ||         || expr  || The items to be iterated over as <xref linkend="el"/> expression. A iteration takes place except if <literal>null</literal> is the evaluation result. Otherwise, if the evaluation result is <emphasis>not iterable object</emphasis>, a temporary list containg that object is created on the fly. Iteration takes then place over that list and otherwise over the iterable collection. ||</simpara>
</section>
<section id="_elements_3">
<title>Elements</title>
<literallayout class="monospaced">The body of this task may contain an arbitrary number of tasks or macros.</literallayout>
</section>
<section id="_behaviour_5">
<title>Behaviour</title>
<simpara>This is the shortest possible for statement. It&#8217;s legal albeit completely useless.</simpara>
<screen> &lt;c:for /&gt;</screen>
</section>
<section id="_further_links_6">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/For.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/For.java">Source</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
Task <link linkend="tasks_for">for</link>
</simpara>
</listitem>
<listitem>
<simpara>
Task <link linkend="tasks_break">break</link>
</simpara>
</listitem>
<listitem>
<simpara>
Task <link linkend="tasks_continue">continue</link>
</simpara>
</listitem>
<listitem>
<simpara>
Quickref [BasicScriptingConstructs#Looping Looping] for an introduction to looping in Flaka
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_install_property_handler" xreflabel="property-handler">
<title>install-property-handler</title>
<simpara>A task to install Flaka&#8217;s property handler. When installed, Ant <emphasis>understands</emphasis>  <xref linkend="el"/> references like <literal>#{..}</literal> in addition to standard property references <literal>${..}</literal>.</simpara>
<simpara>An example will illustrate this:</simpara>
<screen> &lt;c:let&gt;
    ;; let variable foo to string 'bar'
    foo = 'bar'
 &lt;c:let&gt;
 &lt;echo&gt;
    [1] #{foo}
 &lt;/echo&gt;
 &lt;c:install-reference-handler /&gt;
 &lt;echo&gt;
    [2] #{foo}
 &lt;/echo&gt;</screen>
<simpara>Assume in this example, that the standard Ant property handler is installed. In the first <literal>&lt;c:let/&gt;</literal> task you can use EL because this task is provided by Flaka and thus EL aware. This is not the case for the <literal>&lt;echo/&gt;</literal> task following. Thus something like <literal>#{foo}</literal> has no meaning. However, after Flaka&#8217;s property handler is installed, the situation changed.</simpara>
<simpara>This is the output of above&#8217;s snippet:</simpara>
<screen> [echo] [1] #{foo}
 [echo] [2] bar</screen>
<section id="_attributes_6">
<title>Attributes</title>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Attributes</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara>EL</simpara></entry>
<entry align="left" valign="top"><simpara>Description</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>type</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>elonly</literal></simpara></entry>
<entry align="left" valign="top"><simpara>#{}</simpara></entry>
<entry align="left" valign="top"><simpara>Install handler with certain additional features  enabled (see below)</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_behaviour_6">
<title>Behaviour</title>
<simpara>If <literal>type</literal> is <literal>elonly</literal> (exactly as written), then the new handler will only handle <literal>#{..}</literal> in addition. If <literal>type</literal> is <literal>remove</literal>, then unresolved property references are discarded.</simpara>
</section>
<section id="_further_links_7">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelinger.it/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/PropertyHelper.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/PropertyHelper.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_let" xreflabel="let">
<title>let</title>
<simpara>XML is not particular easy to read for humans. When assigning a couple of varables and properties, this becomes obvious. This elementary task allows to set multiple variables and properties in one go. In addition, comments and continuation lines are allowed for additional readability and comfort. For example:</simpara>
<screen>  &lt;c:let&gt;
    f = 'folder'
    ; turn f into a file object
    f = f.tofile
    b = f.isdir ? true : false
    ; assign a *property*
    p := 'hello world'
    ; override a property if you dare
    p ::= "HELLO \
    WORLD"
  &lt;/c:let&gt;</screen>
<simpara>In this example, <literal>f</literal> is first assigned to be string <literal>"folder"</literal>. The comment line - the one starting with character <literal>;</literal> - tells what the next line is going to do: turn <literal>f</literal> into a file object which can then be used further. Here we assign a variable <literal>b</literal> which becomes <literal>true</literal> if <literal>f</literal> is a directory.</simpara>
<simpara>While character <literal>=</literal> is used to assign a variable, use character sequence <literal>:=</literal> to assign a property instead. If such a property already exists, it will not be changed in accordance with Ant&#8217;s standard behaviour.
If you dare and insist to override a property, use <literal>::=</literal> to do so.</simpara>
<simpara>Notice that the right side of <literal>=</literal>, <literal>:=</literal> and <literal>::=</literal> are in any cases a EL expression while the left side are expected to contain valid identifiers for variables and properties.</simpara>
<section id="_attributes_7">
<title>Attributes</title>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Attribute</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="el"/></simpara></entry>
<entry align="left" valign="top"><simpara>Meaning</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>comment</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>;</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>The comment character sequence.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>debug</simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara><literal>false</literal></simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Turn on extra debug information.</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
<simpara>All attributes follow the rule that leading and trailing whitespace is ignored. Any attribute combination is allowed and will not result necessarily in a build error. If in doubt, turn on extra debug information.</simpara>
</section>
<section id="_elements_4">
<title>Elements</title>
<simpara>This task accepts implicit text. Text may contain any amount of <xref linkend="el"/> and property references references. Continuation and comment lines are supported.</simpara>
</section>
<section id="_behaviour_7">
<title>Behaviour</title>
<simpara>The comment character sequence is <literal>";"</literal> by default. It can be changed to an arbitrary sequence using attribute <literal>comment</literal>. Once set, it can&#8217;t be changed during the execution of this task. A comment characters are used to identify lines to be ignored from execution. Such a line is given if the first non whitespace characters of that line are identical with the sequence of comment characters. In other words, a line is being ingnored if matches the regular expression <literal>^\s*&lt;comment&gt;</literal>. The comment characters itself are not interpreted as regular expression characters. Therefore a given comment sequence like <literal>"(#|;)"</literal> does not mean that either <literal>";"</literal> or <literal>"#"</literal> start a comment. Instead it means that a comment line starts with the characters <literal>"(#|;)"</literal> which would be rather awkward (while perfectly <emphasis>legal</emphasis>).</simpara>
<simpara>To support readability continuation lines are supported. Such a line is indicated by having <literal>\</literal> as last character. Be careful not to put any whitespace characters after <literal>\</literal>, otherwise the line will not be recognized as such. Continuation lines are also working on comments as the example above shows. If a line is a continuation line, the last character <literal>\</literal> is removed, the line is accumulated and the next line is read. If finally a non-continuation line is red (and only then), an evaluation of the accumulated line takes place: If the accumlated line is a comment it will be ignored and otherwise either treated as property or variable assignment.</simpara>
<simpara>Leading and trailing whitespace characters ignored in every (accumulated) line. For example, the property assignment  <literal>x := 'foo bar'</literal> will assign the string <literal>foo bar</literal> to property <literal>x</literal>. Notice that whitespace before and after <literal>x</literal> and before and <emphasis>after</emphasis> <literal>'foo bar'</literal> is ignored. This is slightly different from reading Java properties where whitespace after <literal>'foo bar'</literal> would <emphasis>not</emphasis> have been ignored!</simpara>
<simpara>When evaluating, each line is independent of other lines evaluated. Each line is evaluated in the order written. Evaluating means that the right side of the assignment is evaluated as <xref linkend="el"/> expression and the resulting object is assigned to the variable stated on the left side. When evaluating properties, then the right side is evaluted into an object and additionally streamed into a sequence of characters (string).</simpara>
<simpara>Notice that it is perfectly legal to use property or variable references as the following example shows:</simpara>
<screen>&lt;c:let&gt;
 f = '${ant.file}'
 F = '#{f}'
&lt;/c:let&gt;</screen>
<simpara>Be aware that property references are evaluated <emphasis>before</emphasis> <xref linkend="el"/> expressions. Consider:</simpara>
<screen>&lt;c:let&gt;
  ;; let s hold string ant.file
  s = 'ant.file'
  ;; bad, f will not assigned
  f = ${#{s}}
&lt;/c:let&gt;</screen>
<simpara>The second assignment will not work as expected because, in a first step, all occurrences of <literal>${..}</literal> are resolved by Ant itself. In a second step, the expression <literal>${#{s}}</literal> will be evaluated. Since this expression is invalid, <literal>f</literal> will not be assigned.</simpara>
<simpara>Each line is evaluated in order. Therefore the following works as expected:</simpara>
<screen>&lt;c:let&gt;
  s := '3 * 5'
  ;; defines r as 15
  r = ${s}
&lt;/c:let&gt;</screen>
<simpara>The following kind of meta programming will not work for <literal>let</literal>:</simpara>
<screen>&lt;c:let&gt;
  property_or_var := condition ? '=' : ':='

  name ${property_or_var} expr
&lt;/c:let&gt;</screen>
<simpara>In a first step all continuation lines are accumulated. Then each line is split in left and right part and in addition the assignment type. After that, properties are resolved on both sides by Ant&#8217;s property resolver. In an additonal step are <emphasis>EL references</emphasis> evaluated on both sides. Eventually, the right side is evaluated as EL expression and its result is assigned to the stringized and whitespace-chopped left side.</simpara>
</section>
<section id="_then_meaning_of_literal_null_literal_and_emphasis_void_emphasis">
<title>Then meaning of <literal>null</literal> and <emphasis>void</emphasis></title>
<simpara>Task <literal>let</literal> can also be used to <emphasis>remove</emphasis> variables and even properties. To illustrate this, here are example behaviours:</simpara>
<screen>&lt;c:let&gt;
 x = 3 * 5
 ;; remove x
 x =
 ;; remove x
 x = null

 ;; let property p to '3*5' (a string)
 p := 3 * 5
 ;; ignored
 p := null
 ;; remove property 'p'
 p ::= null
 ;; .. same as
 p ::=
&lt;/c:let&gt;</screen>
<simpara>The following table gives an overview of the meaning of <literal>null</literal> and <emphasis>void</emphasis> <footnote><simpara><emphasis>void</emphasis> means that the absense of any characters</simpara></footnote> on the right side of an assignement:</simpara>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="3">
<colspec colname="col_1" colwidth="33*"/>
<colspec colname="col_2" colwidth="33*"/>
<colspec colname="col_3" colwidth="33*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Assignment</simpara></entry>
<entry align="left" valign="top"><simpara>Right Side</simpara></entry>
<entry align="left" valign="top"><simpara>Result</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
<entry align="left" valign="top"><simpara>If the right side evaluates to <literal>null</literal>, then the variable will be removed if existing.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>void</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>The evaluation of an empty expression is <literal>null</literal>. See above how <literal>null</literal> is handled`</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>:=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Cause a <emphasis>read only</emphasis> property can&#8217;t be removed, nothing will happen with this assignment. The property will also not be created.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>:=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>void</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>:= null</literal></simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>::=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><literal>null</literal></simpara></entry>
<entry align="left" valign="top"><simpara>Removes the property denoted by the left side</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara><literal>::=</literal></simpara></entry>
<entry align="left" valign="top"><simpara><emphasis>void</emphasis></simpara></entry>
<entry align="left" valign="top"><simpara>Same as <literal>::= null</literal></simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_further_links_8">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/MSet.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/MSet.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_list" xreflabel="list">
<title>list</title>
<simpara>A elementary task to create a variable containing a <emphasis>list</emphasis> of objects.</simpara>
<screen>&lt;c:list var="mylist"&gt;
  ;; each line is a EL expression
  3 * 5
  ;; each line defines a list element
  list('a',1,''.tofile)
&lt;/c:list&gt;</screen>
<section id="_attributes_8">
<title>Attributes</title>
<informaltable
frame="all"
rowsep="1" colsep="1"
>
<tgroup cols="5">
<colspec colname="col_1" colwidth="20*"/>
<colspec colname="col_2" colwidth="20*"/>
<colspec colname="col_3" colwidth="20*"/>
<colspec colname="col_4" colwidth="20*"/>
<colspec colname="col_5" colwidth="20*"/>
<tbody>
<row>
<entry align="left" valign="top"><simpara>Attribute</simpara></entry>
<entry align="left" valign="top"><simpara>Type</simpara></entry>
<entry align="left" valign="top"><simpara>Default</simpara></entry>
<entry align="left" valign="top"><simpara><xref linkend="el"/></simpara></entry>
<entry align="left" valign="top"><simpara>Meaning</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>var</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>r</simpara></entry>
<entry align="left" valign="top"><simpara>The name of the variabled to be assigned.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>comment</simpara></entry>
<entry align="left" valign="top"><simpara>string</simpara></entry>
<entry align="left" valign="top"><simpara><literal>;</literal></simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>The comment character</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>debug</simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>false</simpara></entry>
<entry align="left" valign="top"><simpara></simpara></entry>
<entry align="left" valign="top"><simpara>Turn on extra debug information.</simpara></entry>
</row>
<row>
<entry align="left" valign="top"><simpara>el</simpara></entry>
<entry align="left" valign="top"><simpara>bool</simpara></entry>
<entry align="left" valign="top"><simpara>true</simpara></entry>
<entry align="left" valign="top"><simpara>no</simpara></entry>
<entry align="left" valign="top"><simpara>Enable evaluation as EL expression</simpara></entry>
</row>
</tbody>
</tgroup>
</informaltable>
</section>
<section id="_elements_5">
<title>Elements</title>
<simpara>This task may contain a implicit text element.</simpara>
</section>
<section id="_behaviour_8">
<title>Behaviour</title>
<simpara>This task creates and assigns in any case a (possible) empty list, especially if no text element is present. The variable&#8217;s name is given by attribute <literal>var</literal>. This attribute may contain references to EL expressions.</simpara>
<simpara>If given text element is parsed on a line by line basis, honouring comments and continuation lines. Each line will be evaluated as EL expression after having resolved <literal>${..}</literal> and <literal>#{..}</literal> references. A illegal EL expression will be discarded while the evaluation of lines continues. Turn on extra debug information in case of problems.</simpara>
<simpara>The evaluation of a valid EL expression results in an object. Each such object will be added to a list in the order imposed by the lines.</simpara>
<simpara>A single line can&#8217;t have more than one EL expressions. Thus the following example is invalid:</simpara>
<screen>&lt;c:list var="mylist"&gt;
 ;; not working
 3 * 5  'hello, world'
&lt;/c:list&gt;</screen>
<simpara>Use attribute <literal>el</literal> to disable the interpretation of a line as <xref linkend="el"/> expression:</simpara>
<screen>&lt;c:list var="mystrings" el="false"&gt;
 3 * 5
 ;; assume that variable message has (string) value 'world'
 hello, #{message}
&lt;/c:list&gt;</screen>
<simpara>This creates a list variable <literal>mystrings</literal> containing two elements. The first element will be string <literal>3 * 5</literal> and the second element will be string <literal>hello, world</literal>. Notice thateven if EL evaluation has been turned off, EL references can still be used.</simpara>
</section>
<section id="_further_links_9">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelinger.it/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/List.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/it/haefelinger/flaka/List.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_properties" xreflabel="properties">
<title>properties</title>
<simpara>A task to set multiple properties in one go. It is typically used to <emphasis>inline</emphasis> properties otherwise written in an additional properties file. Thus using this task reduces the clutter on your top level directory:</simpara>
<screen>&lt;c:properties&gt;
  ; this is \
  a comment

  ; assume that variable 'foo' has been defined here and that
  ; foo.name resolves into 'foo', then the next line will set
  ; property foo to be the string `foo'.
  foo     = #{foo.name}
  ; next lines creates property `foobar' to be the string `foobar'.
  foobar  = ${name}bar
&lt;/c:properties&gt;</screen>
<section id="_attributes_9">
<title>Attributes</title>
<simpara>|| Attribute || Type    || Default || EL || Description ||
|| debug     || boolean || <literal>false</literal> || no || Turn extra debug information on ||
|| comment   || String  || <literal>;</literal>     || no || The character that starts a comment line ||</simpara>
</section>
<section id="_elements_6">
<title>Elements</title>
<simpara>This task accepts a implicit text element.</simpara>
</section>
<section id="_behaviour_9">
<title>Behaviour</title>
<simpara>This task is similar to <link linkend="tasks_let">let</link>. The difference is that this task only allows to define properties while  <link linkend="tasks_let">let</link> also supports the creation of variables. Furthermore, the right side of <literal>=</literal> will be literally taken as string value. This is different from <link linkend="tasks_let">let</link> where the right side will be additionally evaluted as <xref linkend="el"/> expression. The following example defines each property foobar, once done with task  <link linkend="tasks_let">let</link> and once with this <emphasis>properties</emphasis> task:</simpara>
<screen>&lt;c:let&gt;
  foobar := 'foobar'
&lt;/c:let&gt;
&lt;c:properties&gt;
  foobar = foobar
&lt;/c:properties&gt;</screen>
<simpara>Notice the usage of the quote character <literal>'</literal> in the former example and the absence of it in the latter.</simpara>
<simpara>Task <emphasis>properties</emphasis> supports, like task <link linkend="tasks_let">let</link> does, continuation lines and comments. Furthermore, variable references <literal>#{..}</literal> and property references <literal>${..}</literal> are resolved on both sides of <literal>=</literal>.</simpara>
<simpara>If the right side is empty, then no property will be created and an existing property will not be changed. If the right side is <literal>null</literal>, a property with string value <literal>null</literal> will be assigned if the property does not already exist (this is very much different than when using task [#let let] to create properties.</simpara>
<simpara>Leading and trailing (!) whitespace characters are ignored. This is different from standard Ant where trailing whitespace is significant (and responsible for unexpected and hard to track script behaviour).</simpara>
</section>
<section id="_further_links_10">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelinger.it/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Properties.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Properties.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_rescue" xreflabel="rescue">
<title>rescue</title>
<simpara>Task <literal>rescue</literal> is essentially a container for an arbitrary number of tasks. In addition, it allows to rescue variables and properties.</simpara>
<screen>&lt;c:rescue&gt;
 &lt;vars&gt;
   foo
 &lt;/vars&gt;
 &lt;properties&gt;
   bar
 &lt;/properties&gt;
 task_1
   ..
 task_N
&lt;c:rescue&gt;</screen>
<simpara>No matter what will happen with property <literal>var</literal> and variable <literal>foo</literal> within <literal>sequential</literal>, this will be unoticable outside of <literal>rescue</literal> cause the values (or better: state) will be restored after having executed all embedded tasks. This will of course also work in case an exception is thrown by one of the tasks.</simpara>
<section id="_attributes_10">
<title>Attributes</title>
<simpara>This task does not define attributes.</simpara>
</section>
<section id="_elements_7">
<title>Elements</title>
<simpara>|| Name    || Cardinality || Description ||
|| <literal>vars</literal>  || 0..1        || Defines a [#list list] of variable names. Attributes and behaviour is that of task [#list list] except that interpretation of lines as <xref linkend="el"/> expressions are disabled. ||
|| <literal>properties</literal> || 0..1   || Defines a [#list list] of property names. Attributes and behaviour is that of task [#list list] except that interpretation of lines as <xref linkend="el"/> expressions are disabled. ||
|| <emphasis>task</emphasis>  || arbitrary   || A (arbitrary) task or macro to be excecuted ||</simpara>
</section>
<section id="_behaviour_10">
<title>Behaviour ==</title>
<simpara>Executes all embedded tasks. Variables and properties listed in <literal>vars</literal> and <literal>properties</literal> are restored to their previous state, i.e. if not existing before the execution, they will not exist afterwards. If existed, their value will be restored.</simpara>
</section>
<section id="_further_links_11">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Rescue.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Rescue.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
<simpara>&lt;hr/&gt;</simpara>
</section>
</section>
<section id="task_switch" xreflabel="switch">
<title>switch</title>
<simpara>Task <literal>switch</literal> has been designed to ease pattern matching. The idea is to try to match a pattern, a <ulink url="http://en.wikipedia.org/wiki/Regular_expression">regular expression</ulink> or <ulink url="http://en.wikipedia.org/wiki/Glob_(programming)">glob expression</ulink> against a given string value and carry out a sequence of actions in case of a hit.</simpara>
<screen> &lt;c:switch value=" 'a${string}#{value}' "&gt;
  &lt;matches glob="*.jar"&gt;          -- #1
   -- string ending in .jar
  &lt;/matches&gt;
  &lt;matches re="1|2|3"&gt;            -- #2
    -- one or two or three
  &lt;/matches&gt;
  &lt;matches re="-\d+"&gt;             -- #3
    -- negative integral number
  &lt;/matches&gt;
  &lt;otherwise&gt;
   -- no match so far ..
  &lt;/otherwise&gt;
 &lt;c:case&gt;</screen>
<simpara>Notice the usage of a glob expression in the first and the usage of regular expressions in the second and third <literal>matches</literal> element. Utilization of glob and regular expressions make <literal>switch</literal> a very flexible and powerful conditional statement.</simpara>
<section id="_attributes_11">
<title>Attributes</title>
<simpara>|| Attribute || Type   || Default || <xref linkend="el"/>  || Description ||
|| <literal>value</literal>   || string ||       - ||   el  || The (string) value that needs to be matched against. Note that the value given is <emphasis>normalized</emphasis>, i.e. leading and trailing whitespace is removed. Whitespace characters are controlled by the underlying implementation which is Java in this case.||
|| <literal>var</literal>     || string ||       - || #{..} || Save details of this match as <literal>matching object</literal> using the variable name given. See [EL#Matcher_Properties matcher properties] for a list of available properties; see also below for examples. ||
|| <literal>ignorecase</literal> || bool || false  ||    no || Enables case-insensitive matching. By default, case-insensitive matching assumes that only characters in the US-ASCII charset are being matched. Unicode-aware case-insensitive matching can be enabled by specifying the UNICODE_CASE flag in conjunction with this flag. Case-insensitive matching can also be enabled via the embedded flag expression <literal>(?i)</literal> ||
|| <literal>comments</literal>   || bool || false  ||    no || Permits whitespace and comments in pattern. In this mode, whitespace is ignored, and embedded comments starting with # are ignored until the end of a line. Comments mode can also be enabled via the embedded flag expression <literal>(?x)</literal> ||
|| <literal>dotall</literal>     || bool || false ||     no || In dotall mode, the literal <literal>.</literal> matches any character, including a line terminator. By default this expression does not match line terminators. Dotall mode can also be enabled via the embedded flag expression <literal>(?s)</literal>, where <literal>s</literal> is a mnemonic for <emphasis>single-line</emphasis> mode, which is what this mode is called in <ulink url="http://en.wikipedia.org/wiki/Perl">Perl</ulink>. ||
|| <literal>unixlines</literal>  || bool || false  ||    no || In this mode, only character <literal>LF</literal> is accepted as line terminator character when using <literal>.</literal>, <literal>^</literal>, and <literal>$</literal>. Unix lines mode can also be enabled via the embedded flag expression (?d). ||
|| <literal>multiline</literal>  || bool || false || no || In multiline mode, the literals <literal>^</literal> and <literal>$</literal> match just after or just before, respectively, a line terminator or the end of the input sequence. By default these expressions only match at the beginning and the end of the entire input sequence. Multiline mode can also be enabled via the embedded flag expression (?m). ||
|| <literal>debug</literal>      || bool  || false ||   no || Turn on extra debug information ||
|| <emphasis>matches</emphasis>.<literal>re</literal> || string ||    || #{..} || Element <literal>matches</literal>: Specify a matching pattern as regular expression. ||
|| <emphasis>matches</emphasis>.<literal>pat</literal> || string ||   || #{..} || Element <literal>matches</literal>: Specify a matching pattern as glob expression ||</simpara>
<simpara>Note that each <literal>switch</literal> attribute (but <literal>value</literal>) can be applied to a <literal>matches</literal> element. Applied on <literal>switch</literal> has the effect of providing the default value for subsequenct <literal>matches</literal> elements.</simpara>
</section>
<section id="_elements_8">
<title>Elements</title>
<simpara>|| Element   || Cardinality || Description ||
|| <literal>matches</literal> || 0..infinity || An element to specify a single regular or a glob expression. This element supports all the attributes of the enclosing <literal>switch</literal> (but <literal>value</literal>). It may contain any number of tasks or macros as sub elements. They are carried out if the expression matches. ||
|| <literal>default</literal> || 0..1        || The default statement will be executed if no <literal>matches</literal> element matched the input value. This element is optional. This element can only be specified once. A build exception will be raised if used more than once. This element does not accept any attributes.  It may contain any number of tasks or macros as sub elements. They are carried out if no expression matched. ||
|| <literal>otherwise</literal> || 0..1     || This element is a synonym for element <literal>default</literal> ||</simpara>
</section>
<section id="_behaviour_11">
<title>Behaviour</title>
<simpara>Attribute <literal>value</literal> is the basis for all further matching. It is a string value which may contain [Glossary#Property_Reference references to properties] or [Glossary#Expression_Reference EL expressions]. Leading and trailing whitespace will be discarded after having resolved all references.</simpara>
<simpara>All other attributes (see above) are default values for subsequent <literal>matches</literal> elements. For example, setting attribute <literal>debug</literal> to <literal>true</literal> will turn on debug on all <literal>matches</literal> elements.</simpara>
<simpara>Any number of <literal>matches</literal> elements are allowed and at most one <literal>otherwise</literal> (resp. <literal>default</literal>) element. Whether the <literal>otherwise</literal> element is at the end, in the middle or at the begin does not matter. The order of the <literal>matches</literal> elements are relevant however. Each <literal>matches</literal> element will be tried in the order given until no more untried elements are left. Then, if no element matched, a given <literal>otherwise</literal> element is carried out. Otherwise the matching elment will.</simpara>
<simpara>Carrying out an element means that all enclosed tasks or macros are executed in the order given.</simpara>
<simpara>The underlying regular expression engine is the one given by Java. It&#8217;s <ulink url="http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html">Javadoc</ulink> documentation is a pretty good source of information if you are familiar with regular expressions. For all the gory details, have a look at <ulink url="http://oreilly.com/catalog/9780596528126/index.html">Mastering Regular Expressions</ulink> by Jeffrey E. F. Friedl.</simpara>
<simpara>Be aware that there is no need to escape the escape character. For example, people using regular expressions in Java are used to write <literal>\\*</literal> if they want match the literal <literal>*</literal> character and thus escaping from the usual semantics (match zero or more times). This is not necessary in Flaka where the input sequence <literal>\*</literal> remains <literal>\*</literal>.</simpara>
<simpara>So called <emphasis>globs</emphasis> are a kind of simplified regular expressions. They lack the full power while simplifying the expression. For example, to specify whether a name input string end in <literal>jar</literal>, we can simply write</simpara>
<screen> &lt;c:switch value=" #{myfile}.name "&gt;
  &lt;matches glob="*.jar"&gt;
    -- do something with jar file ..
  &lt;/matches&gt;
 &lt;/c:switch&gt;</screen>
<simpara>The very same can also be expressed as <literal>re="\.jar$"</literal> using regular expressions. The biggest disadvange of globs are that capturing groups are not supported. Thus the match above just indicates that the file name ends in <literal>.jar</literal> while there is nothing to figure the file&#8217;s basename. Compare this with</simpara>
<screen> &lt;c:switch value=" #{myfile}.name "&gt;
  &lt;matches re="^(.*)\.jar$" var="m"&gt;
    &lt;c:echo&gt;
      basename = #{m[1]}
    &lt;/c:echo&gt;
  &lt;/matches&gt;
 &lt;/c:switch&gt;</screen>
<simpara>Here we use a capturing group for the basename. A matcher object will be associated with variable <literal>m</literal>. This object can then be <ulink url="http://code.google.com/p/flaka/wiki/EL#Matcher_Properties">evaluated using properties</ulink> for matching details.</simpara>
<simpara>Here is a more complicated example. It was used once to examine a CVS tag which was supposed to follow the convetion <literal>schema-(env_)version</literal>, where <literal>(env_)</literal> was optional, <literal>schema</literal> indicated the tag&#8217;s semantic and where <literal>version</literal> was the products version or build number:</simpara>
<screen> &lt;c:switch value=" 'v-uat_3_20_500' " var="m"&gt;
   &lt;matches re="v-(?:([^\d][^_]*)_)?(\d.*)" &gt;
     &lt;c:echo&gt;
       pattern      = #{m.p}         -- v-(?:([^\d][^_]*)_)?(\d.*)
       groups       = #{m.n}         -- 2
       matched text = #{m}           -- v-uat_3_20_500  (same as m[0])
       env          = #{m[1]}        -- uat
       version      = #{m[2]}        -- 3_20_500
       ;; refering to non existing group
       ??           = #{m[3]}        -- (empty string)
       ;; start and end index of first group
       start        = #{m[1].s}      -- 2
       end          = #{m[1].e}      -- 5
     &lt;/c:echo&gt;
   &lt;/matches&gt;
 &lt;/c:switch&gt;</screen>
</section>
<section id="_further_links_12">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Switch.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Switch.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_throw" xreflabel="throw">
<title>throw</title>
<simpara>A task to re-throw a previously thrown exception. If no exception has been thrown before, a new exception is thrown. In that case, throw acts like standard fail task .</simpara>
<simpara>Note that throw would re-throw the last thrown exception - regardless of the current context. The following would therefore work:</simpara>
<screen> &lt;c:trycatch&gt;
  &lt;try&gt;
    &lt;fail message="4711" /&gt;
  &lt;/try&gt;
  &lt;catch&gt;
    -- handle the exception ..
  &lt;catch&gt;
 &lt;/c:trycatch&gt;
 ..
 .. -- very much later
 ..
 &lt;c:throw /&gt; -- re-throws "4711" exception!!!</screen>
<section id="_attributes_12">
<title>Attributes</title>
<simpara>|| Attribute || Type || Default || <xref linkend="el"/> || Description ||
|| <literal>reference</literal> || string || <literal>trycatch.object</literal> || no || The name of the reference holding the previously thrown exception ||
|| <literal>var</literal> || || || no || Same as reference ||</simpara>
</section>
<section id="_behaviour_12">
<title>Behaviour</title>
<simpara>A typical usage example:</simpara>
<screen> &lt;c:trycatch&gt;
  &lt;try&gt; ..&lt;fail message="4711"/&gt; &lt;/try&gt;
  &lt;catch&gt;
    &lt;echo&gt;caught exception ..&lt;/echo&gt;
    &lt;c:throw /&gt;
  &lt;/c:catch&gt;
 &lt;/c:trycatch&gt;</screen>
<simpara>When being executed, Ant would receive a build exception (re-thrown within the catch clause) containing "4711" and terminate.</simpara>
</section>
<section id="_further_links_13">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Throw.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Throw.java">Source</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
Task <link linkend="tasks_trycatch">trycatch</link>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_trycatch" xreflabel="trycatch">
<title>trycatch</title>
<simpara>A task mirroring try-catch-finally exception handling found in various languages.</simpara>
<simpara>All tasks inside try are executed in order. If an exception is thrown by one of tehm, then several things may happen:</simpara>
<itemizedlist>
<listitem>
<simpara>
If there is a matching catch clause, then all tasks in that clause are executed. If there isn&#8217;t a catch clause, the exception will be passed to the enclosing environment (except if an exception is also thrown in the finally clause - see below).
</simpara>
</listitem>
<listitem>
<simpara>
An optional finally clause is always executed, regardless of whether an exception gets thrown or or whether a try or catch clause exists.
</simpara>
</listitem>
<listitem>
<simpara>
If a property is set, then that property will hold the message of the exception thrown in a try clause. If a reference is given, then that reference will hold the exception object thrown in the try clause. If an exception is also thrown in a catch or finally clause, then neither will the property or reference update nor set.
</simpara>
</listitem>
<listitem>
<simpara>
If a exception is thrown in a matching catch clause and in a finally clause, then the latter will be passed to the enclosing environment and the former will be discarded.
</simpara>
</listitem>
</itemizedlist>
<simpara>A catch clause can be given a type and a match argument. Both arguments expect a regular or pattern expression. A catch clauses matches if the type and match matches. The type argument is matched against the classname of the thrown exception. The match argument is matched against the exception message (if any). Both default values ensure that a build exception thrown by Ant is caught while an implementation dependent exception passes.</simpara>
<simpara>When matching against the error message, be aware that the actual error message might be slightly different from the actual message given: usually the error message contains also information about where the exception got thrown. It is therefore wise to accepted any leading and trailing space. For example:</simpara>
<screen> &lt;c:trycatch&gt;
  &lt;try&gt;&lt;fail message="4711" /&gt;&lt;/try&gt;
  &lt;catch match="4711"&gt;
    -- does (very likely) not match
  &lt;/catch&gt;
  &lt;catch match="4711*"&gt;
    -- neither this one ..
  &lt;/catch&gt;
  &lt;catch match="*4711"&gt;
    -- bon chance
  &lt;/catch&gt;
  &lt;catch match="*4711*"&gt;
    -- this is it!
  &lt;/catch&gt;
 &lt;/c:trycatch&gt;</screen>
<section id="_attributes_13">
<title>Attributes</title>
<simpara>|| Attribute || Type || Default || <xref linkend="el"/> || Description ||
|| <literal>property</literal> || string || || no || The name of the property that should hold the exception message ||
|| <literal>reference</literal> || string || <literal>trycatch.object</literal> || no || &gt;The name of the reference to hold the exception object ||
|| <literal>catch.type</literal> || glob || <literal>*.BuildException</literal> || no || A pattern against the type (Java classname) of the exception object ||
|| <literal>catch.match</literal> || glob || <literal>*</literal>  || no || A pattern to be applied against the exception message ||</simpara>
</section>
<section id="_elements_9">
<title>Elements</title>
<itemizedlist>
<listitem>
<simpara>
try&lt;br /&gt; A task container to hold tasks and macros to be given a try.
</simpara>
</listitem>
<listitem>
<simpara>
catch&lt;br /&gt; A task container to be executed if an exception gets thrown
</simpara>
</listitem>
<listitem>
<simpara>
finally&lt;br/&gt; A task container to be executed in any case
</simpara>
</listitem>
</itemizedlist>
<simpara>Note that all elements are optional. However, if there&#8217;s no try element, then there&#8217;s no chance to execute catch at all, so this constellation does not make too much sense. The optional finally clause will be executed regardless of whether a try clause exists or not.</simpara>
<simpara>It is allowed to have more multiple try, catch or finally clauses and further does the oder in which they appear not matter. Be aware though that eventually all try and finally clauses are merged into one try resp. finally clause.</simpara>
</section>
<section id="_behaviour_13">
<title>Behaviour</title>
<simpara>The following snippet demonstrates the usage of trycatch:</simpara>
<screen> &lt;c:trycatch property="reason"&gt;
   &lt;try&gt;
     &lt;echo&gt;1st try ..&lt;/echo&gt;
   &lt;/try&gt;
   &lt;try&gt;
     &lt;echo&gt;2nd try ..&lt;/echo&gt;
     &lt;fail message="fail within 2nd try" /&gt;
   &lt;/try&gt;
   &lt;try&gt;
     &lt;fail message="fail within 3rd try" /&gt;
   &lt;/try&gt;
   &lt;catch type="*.BuildException" match="*"&gt;
     &lt;echo&gt;..caught : ${reason}&lt;/echo&gt;
   &lt;/catch&gt;
   &lt;finally&gt;
     &lt;echo&gt;..finally&lt;/echo&gt;
   &lt;/finally&gt;
 &lt;/c:trycatch&gt;</screen>
<simpara>Giving:</simpara>
<screen>    [echo] 1st try ..
    [echo] 2nd try ..
    [echo] ..caught : fail within 2nd try
    [echo] ..finally</screen>
</section>
<section id="_further_links_14">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Trycatch.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Trycatch.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_unless" xreflabel="unless">
<title>unless</title>
<simpara>This task is the logical opposite of task <link linkend="tasks_when">when</link>. It&#8217;s body is only executed if the condition evaluates to false. See <link linkend="tasks_when">when</link> for details. This example shows how to create a folder named libdir if such a folder does not already exist.</simpara>
<screen> &lt;c:unless test=" 'libdir'.tofile.isdir "&gt;
  &lt;mkdir dir="libdir" /&gt;
 &lt;/c:unless&gt;</screen>
<section id="_further_links_15">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Unless.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Unless.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_unset" xreflabel="unet">
<title>unset</title>
<simpara>The unset statement allows the removal of properties. Use this task with care as properties are not meant to be changed during execution of a project.</simpara>
<screen> &lt;c:unset&gt;
   p1
   ;; use embedded EL references for dynamic names
   p#{ index }
 &lt;/c:unset&gt;</screen>
<simpara>This example demonstrates how to remove properties <literal>p1</literal> and a property whose name dependes on the curent value of <literal>index</literal>.</simpara>
<section id="_attributes_14">
<title>Attributes</title>
<simpara>|| Attribute || Type    || Default || EL || Description ||
|| debug     || boolean || <literal>false</literal> || no || Turn extra debug information on ||
|| comment   || String  || <literal>;</literal>     || no || The character that starts a comment line ||</simpara>
</section>
<section id="_elements_10">
<title>Elements</title>
<simpara>This element accepts implicit text.</simpara>
</section>
<section id="_behaviour_14">
<title>Behaviour</title>
<simpara>Each non comment line defines a property name to be removed. The property does not need to exist to be removed. User properties (i.e. given by command line) and system properties (i.e. <literal>ant.file</literal>) are also removed.</simpara>
<simpara>Comment lines and empty lines are ignored. Continuation lines, i.e. lines ending in <literal>\</literal> but not in <literal>\\</literal>, are accumulated before being processed.</simpara>
<simpara>References to properties <literal>${..}</literal> and expressions <literal>#{..}</literal> are resolved.</simpara>
<simpara>The content of a line defines the property name, for example:</simpara>
<screen>&lt;c:unset&gt;
 ;; property 'foo bar', not 'foo' and 'bar'
 foo bar

 ;; a line is *not* a EL expression (this will be property '3 * 5')
 3 * 5

 ;; use #{..} references for dynamic content (this will be 'p15')
 p#{3*5}
&lt;/c:unset&gt;</screen>
</section>
<section id="_further_links_16">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/Unset.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/Unset.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_when" xreflabel="when">
<title>when</title>
<simpara>Task when represents a else-less if statement. The following example dumps the content of a file to stdout via Ant&#8217;s echo task if the file exists.</simpara>
<screen> &lt;c:when test=" 'path/to/file'.tofile.isfile" &gt;
   &lt;c:let var="fname" property="true" value=" f " /&gt;
    &lt;loadfile property="__z__" srcFile="${fname}"/&gt;
    &lt;echo message="${__z__}" /&gt;
 &lt;/c:when&gt;</screen>
<simpara>Note that the example is bit artificial cause Ant&#8217;s loadfile task is sufficient.</simpara>
<section id="_attributes_15">
<title>Attributes</title>
<simpara>|| Attribute || Type   || Default || EL    || Description ||
|| <literal>test</literal>    || string || <literal>false</literal> || expr  || A <xref linkend="el"/> expression that must evaluate to <literal>true</literal> in order to execute the body of this if statement. ||</simpara>
</section>
<section id="_elements_11">
<title>Elements</title>
<itemizedlist>
<listitem>
<simpara>
Any tasks or macro instances.
</simpara>
</listitem>
</itemizedlist>
</section>
<section id="_further_links_17">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/When.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/When.java">Source</ulink>
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
<section id="task_while" xreflabel="while">
<title>while</title>
<simpara>A task implemening a <literal>while</literal> loop:</simpara>
<screen>&lt;c:let&gt;
  i = 3
&lt;/c:let&gt;
&lt;c:while test=" countdown &gt;= 0 "&gt;
  &lt;c:echo&gt;#{countdown &gt; 0 ? countdown : 'bang!' }&lt;/c:echo&gt;
&lt;c:while&gt;</screen>
<section id="_attributes_16">
<title>Attributes</title>
<simpara>|| Attribute || Type   || Default || EL    || Description ||
|| <literal>test</literal>    || string || <literal>false</literal> || expr  || The condition for looping as <xref linkend="el"/> expression ||</simpara>
</section>
<section id="_elements_12">
<title>Elements</title>
<literallayout class="monospaced">The body of this task may contain an arbitrary number of tasks or macros.</literallayout>
</section>
<section id="_behaviour_15">
<title>Behaviour</title>
<simpara>All tasks listed as elements are executed as long as the <xref linkend="el"/> expression evaluates to <literal>true</literal>.</simpara>
</section>
<section id="_further_links_18">
<title>Further Links</title>
<itemizedlist>
<listitem>
<simpara>
<ulink url="http://javadoc.haefelingerit.net/net.haefelingerit.flaka/1.00/net/haefelingerit/flaka/While.html">Javadoc</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<ulink url="http://code.google.com/p/flaka/source/browse/trunk/src/net/haefelingerit/flaka/While.java">Source</ulink>
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="tasks_break">break</link> to stop the iteration
</simpara>
</listitem>
<listitem>
<simpara>
<link linkend="tasks_continue">continue</link> to hide tasks from being executed during a iteration step.
</simpara>
</listitem>
<listitem>
<simpara>
See also [BasicScriptingConstructs#Looping Looping] for an introduction to looping in Flaka
</simpara>
</listitem>
</itemizedlist>
</section>
</section>
</article>
